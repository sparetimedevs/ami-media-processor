// Generated by <a href="http://scalaxb.org/">scalaxb</a>.
package musicxml

/** MusicXML W3C XML schema (XSD)

Version 3.1

Copyright Â© 2004-2017 the Contributors to the MusicXML Specification, published by the W3C Music Notation Community Group under the W3C Community Final Specification Agreement (FSA):

	https://www.w3.org/community/about/agreements/final/

A human-readable summary is available:

	https://www.w3.org/community/about/agreements/fsa-deed/

This is the W3C XML Schema (XSD) version of the MusicXML 3.1 language. Validation is tightened by moving MusicXML definitions from comments into schema data types and definitions. Character entities and other entity usages that are not supported in W3C XML Schema have been removed. The features of W3C XML Schema make it easier to define variations of the MusicXML format, either via extension or restriction.

This file defines the MusicXML 3.1 XSD, including the score-partwise and score-timewise document elements.
*/

sealed trait Aboveu45below

object Aboveu45below {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[musicxml.Aboveu45below]): Aboveu45below = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: Aboveu45below) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[Aboveu45below] = Seq(Above, BelowValue)
}

case object Above extends Aboveu45below { override def toString = "above" }
case object BelowValue extends Aboveu45below { override def toString = "below" }

sealed trait Cssu45fontu45size

object Cssu45fontu45size {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[musicxml.Cssu45fontu45size]): Cssu45fontu45size = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: Cssu45fontu45size) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[Cssu45fontu45size] = Seq(Xxu45small, Xu45small, Small, MediumValue, Large, Xu45large, Xxu45large)
}

case object Xxu45small extends Cssu45fontu45size { override def toString = "xx-small" }
case object Xu45small extends Cssu45fontu45size { override def toString = "x-small" }
case object Small extends Cssu45fontu45size { override def toString = "small" }
case object MediumValue extends Cssu45fontu45size { override def toString = "medium" }
case object Large extends Cssu45fontu45size { override def toString = "large" }
case object Xu45large extends Cssu45fontu45size { override def toString = "x-large" }
case object Xxu45large extends Cssu45fontu45size { override def toString = "xx-large" }

sealed trait Enclosureu45shape

object Enclosureu45shape {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[musicxml.Enclosureu45shape]): Enclosureu45shape = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: Enclosureu45shape) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[Enclosureu45shape] = Seq(RectangleValue, SquareValue3, Oval, Circle, BracketValue3, TriangleValue2, DiamondValue, Pentagon, Hexagon, Heptagon, Octagon, Nonagon, Decagon, NoneTypeValue9)
}

case object RectangleValue extends Enclosureu45shape { override def toString = "rectangle" }
case object SquareValue3 extends Enclosureu45shape { override def toString = "square" }
case object Oval extends Enclosureu45shape { override def toString = "oval" }
case object Circle extends Enclosureu45shape { override def toString = "circle" }
case object BracketValue3 extends Enclosureu45shape { override def toString = "bracket" }
case object TriangleValue2 extends Enclosureu45shape { override def toString = "triangle" }
case object DiamondValue extends Enclosureu45shape { override def toString = "diamond" }
case object Pentagon extends Enclosureu45shape { override def toString = "pentagon" }
case object Hexagon extends Enclosureu45shape { override def toString = "hexagon" }
case object Heptagon extends Enclosureu45shape { override def toString = "heptagon" }
case object Octagon extends Enclosureu45shape { override def toString = "octagon" }
case object Nonagon extends Enclosureu45shape { override def toString = "nonagon" }
case object Decagon extends Enclosureu45shape { override def toString = "decagon" }
case object NoneTypeValue9 extends Enclosureu45shape { override def toString = "none" }

sealed trait Fermatau45shape

object Fermatau45shape {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[musicxml.Fermatau45shape]): Fermatau45shape = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: Fermatau45shape) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[Fermatau45shape] = Seq(NormalValue3, Angled, SquareValue2, Doubleu45angled, Doubleu45square, Doubleu45dot, Halfu45curve, Curlew, BlankValue)
}

case object NormalValue3 extends Fermatau45shape { override def toString = "normal" }
case object Angled extends Fermatau45shape { override def toString = "angled" }
case object SquareValue2 extends Fermatau45shape { override def toString = "square" }
case object Doubleu45angled extends Fermatau45shape { override def toString = "double-angled" }
case object Doubleu45square extends Fermatau45shape { override def toString = "double-square" }
case object Doubleu45dot extends Fermatau45shape { override def toString = "double-dot" }
case object Halfu45curve extends Fermatau45shape { override def toString = "half-curve" }
case object Curlew extends Fermatau45shape { override def toString = "curlew" }
case object BlankValue extends Fermatau45shape { override def toString = "" }

sealed trait Fontu45style

object Fontu45style {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[musicxml.Fontu45style]): Fontu45style = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: Fontu45style) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[Fontu45style] = Seq(NormalValue2, Italic)
}

case object NormalValue2 extends Fontu45style { override def toString = "normal" }
case object Italic extends Fontu45style { override def toString = "italic" }

sealed trait Fontu45weight

object Fontu45weight {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[musicxml.Fontu45weight]): Fontu45weight = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: Fontu45weight) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[Fontu45weight] = Seq(NormalValue4, Bold)
}

case object NormalValue4 extends Fontu45weight { override def toString = "normal" }
case object Bold extends Fontu45weight { override def toString = "bold" }

sealed trait Leftu45centeru45right

object Leftu45centeru45right {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[musicxml.Leftu45centeru45right]): Leftu45centeru45right = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: Leftu45centeru45right) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[Leftu45centeru45right] = Seq(LeftTypeValue2, CenterValue, RightTypeValue2)
}

case object LeftTypeValue2 extends Leftu45centeru45right { override def toString = "left" }
case object CenterValue extends Leftu45centeru45right { override def toString = "center" }
case object RightTypeValue2 extends Leftu45centeru45right { override def toString = "right" }

sealed trait Leftu45right

object Leftu45right {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[musicxml.Leftu45right]): Leftu45right = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: Leftu45right) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[Leftu45right] = Seq(LeftTypeValue3, RightTypeValue3)
}

case object LeftTypeValue3 extends Leftu45right { override def toString = "left" }
case object RightTypeValue3 extends Leftu45right { override def toString = "right" }

sealed trait Lineu45length

object Lineu45length {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[musicxml.Lineu45length]): Lineu45length = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: Lineu45length) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[Lineu45length] = Seq(ShortTypeValue, Medium, LongType)
}

case object ShortTypeValue extends Lineu45length { override def toString = "short" }
case object Medium extends Lineu45length { override def toString = "medium" }
case object LongType extends Lineu45length { override def toString = "long" }

sealed trait Lineu45shape

object Lineu45shape {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[musicxml.Lineu45shape]): Lineu45shape = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: Lineu45shape) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[Lineu45shape] = Seq(StraightValue2, CurvedValue)
}

case object StraightValue2 extends Lineu45shape { override def toString = "straight" }
case object CurvedValue extends Lineu45shape { override def toString = "curved" }

sealed trait Lineu45type

object Lineu45type {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[musicxml.Lineu45type]): Lineu45type = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: Lineu45type) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[Lineu45type] = Seq(Solid, DashedValue, DottedValue, Wavy)
}

case object Solid extends Lineu45type { override def toString = "solid" }
case object DashedValue extends Lineu45type { override def toString = "dashed" }
case object DottedValue extends Lineu45type { override def toString = "dotted" }
case object Wavy extends Lineu45type { override def toString = "wavy" }

sealed trait Mute

object Mute {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[musicxml.Mute]): Mute = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: Mute) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[Mute] = Seq(On, Off, StraightValue, Cup, Harmonu45nou45stem, Harmonu45stem, Bucket, Plunger, Hat, Solotone, Practice, Stopu45mute, Stopu45hand, EchoValue, Palm)
}

case object On extends Mute { override def toString = "on" }
case object Off extends Mute { override def toString = "off" }
case object StraightValue extends Mute { override def toString = "straight" }
case object Cup extends Mute { override def toString = "cup" }
case object Harmonu45nou45stem extends Mute { override def toString = "harmon-no-stem" }
case object Harmonu45stem extends Mute { override def toString = "harmon-stem" }
case object Bucket extends Mute { override def toString = "bucket" }
case object Plunger extends Mute { override def toString = "plunger" }
case object Hat extends Mute { override def toString = "hat" }
case object Solotone extends Mute { override def toString = "solotone" }
case object Practice extends Mute { override def toString = "practice" }
case object Stopu45mute extends Mute { override def toString = "stop-mute" }
case object Stopu45hand extends Mute { override def toString = "stop-hand" }
case object EchoValue extends Mute { override def toString = "echo" }
case object Palm extends Mute { override def toString = "palm" }

sealed trait Overu45under

object Overu45under {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[musicxml.Overu45under]): Overu45under = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: Overu45under) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[Overu45under] = Seq(Over, Under)
}

case object Over extends Overu45under { override def toString = "over" }
case object Under extends Overu45under { override def toString = "under" }

sealed trait Semiu45pitched

object Semiu45pitched {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[musicxml.Semiu45pitched]): Semiu45pitched = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: Semiu45pitched) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[Semiu45pitched] = Seq(High, Mediumu45high, MediumValue2, Mediumu45low, Low, Veryu45low)
}

case object High extends Semiu45pitched { override def toString = "high" }
case object Mediumu45high extends Semiu45pitched { override def toString = "medium-high" }
case object MediumValue2 extends Semiu45pitched { override def toString = "medium" }
case object Mediumu45low extends Semiu45pitched { override def toString = "medium-low" }
case object Low extends Semiu45pitched { override def toString = "low" }
case object Veryu45low extends Semiu45pitched { override def toString = "very-low" }

sealed trait Startu45note

object Startu45note {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[musicxml.Startu45note]): Startu45note = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: Startu45note) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[Startu45note] = Seq(Upper, Main, Below)
}

case object Upper extends Startu45note { override def toString = "upper" }
case object Main extends Startu45note { override def toString = "main" }
case object Below extends Startu45note { override def toString = "below" }

sealed trait Startu45stop

object Startu45stop {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[musicxml.Startu45stop]): Startu45stop = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: Startu45stop) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[Startu45stop] = Seq(StartValue4, StopValue5)
}

case object StartValue4 extends Startu45stop { override def toString = "start" }
case object StopValue5 extends Startu45stop { override def toString = "stop" }

sealed trait Startu45stopu45continue

object Startu45stopu45continue {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[musicxml.Startu45stopu45continue]): Startu45stopu45continue = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: Startu45stopu45continue) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[Startu45stopu45continue] = Seq(StartValue3, StopValue4, ContinueValue4)
}

case object StartValue3 extends Startu45stopu45continue { override def toString = "start" }
case object StopValue4 extends Startu45stopu45continue { override def toString = "stop" }
case object ContinueValue4 extends Startu45stopu45continue { override def toString = "continue" }

sealed trait Startu45stopu45single

object Startu45stopu45single {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[musicxml.Startu45stopu45single]): Startu45stopu45single = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: Startu45stopu45single) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[Startu45stopu45single] = Seq(StartValue5, StopValue6, SingleValue2)
}

case object StartValue5 extends Startu45stopu45single { override def toString = "start" }
case object StopValue6 extends Startu45stopu45single { override def toString = "stop" }
case object SingleValue2 extends Startu45stopu45single { override def toString = "single" }

sealed trait Symbolu45size

object Symbolu45size {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[musicxml.Symbolu45size]): Symbolu45size = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: Symbolu45size) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[Symbolu45size] = Seq(Full, Cue, Graceu45cue, LargeValue)
}

case object Full extends Symbolu45size { override def toString = "full" }
case object Cue extends Symbolu45size { override def toString = "cue" }
case object Graceu45cue extends Symbolu45size { override def toString = "grace-cue" }
case object LargeValue extends Symbolu45size { override def toString = "large" }

sealed trait Textu45direction

object Textu45direction {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[musicxml.Textu45direction]): Textu45direction = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: Textu45direction) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[Textu45direction] = Seq(Ltr, Rtl, Lro, Rlo)
}

case object Ltr extends Textu45direction { override def toString = "ltr" }
case object Rtl extends Textu45direction { override def toString = "rtl" }
case object Lro extends Textu45direction { override def toString = "lro" }
case object Rlo extends Textu45direction { override def toString = "rlo" }

sealed trait Tiedu45type

object Tiedu45type {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[musicxml.Tiedu45type]): Tiedu45type = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: Tiedu45type) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[Tiedu45type] = Seq(StartValue2, StopValue3, ContinueValue3, Letu45ring)
}

case object StartValue2 extends Tiedu45type { override def toString = "start" }
case object StopValue3 extends Tiedu45type { override def toString = "stop" }
case object ContinueValue3 extends Tiedu45type { override def toString = "continue" }
case object Letu45ring extends Tiedu45type { override def toString = "let-ring" }

sealed trait Topu45bottom

object Topu45bottom {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[musicxml.Topu45bottom]): Topu45bottom = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: Topu45bottom) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[Topu45bottom] = Seq(TopValue, BottomValue)
}

case object TopValue extends Topu45bottom { override def toString = "top" }
case object BottomValue extends Topu45bottom { override def toString = "bottom" }

sealed trait Tremolou45type

object Tremolou45type {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[musicxml.Tremolou45type]): Tremolou45type = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: Tremolou45type) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[Tremolou45type] = Seq(StartValue6, StopValue7, SingleValue3, Unmeasured)
}

case object StartValue6 extends Tremolou45type { override def toString = "start" }
case object StopValue7 extends Tremolou45type { override def toString = "stop" }
case object SingleValue3 extends Tremolou45type { override def toString = "single" }
case object Unmeasured extends Tremolou45type { override def toString = "unmeasured" }

sealed trait Trillu45step

object Trillu45step {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[musicxml.Trillu45step]): Trillu45step = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: Trillu45step) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[Trillu45step] = Seq(WholeValue, HalfValue3, Unison)
}

case object WholeValue extends Trillu45step { override def toString = "whole" }
case object HalfValue3 extends Trillu45step { override def toString = "half" }
case object Unison extends Trillu45step { override def toString = "unison" }

sealed trait Twou45noteu45turn

object Twou45noteu45turn {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[musicxml.Twou45noteu45turn]): Twou45noteu45turn = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: Twou45noteu45turn) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[Twou45noteu45turn] = Seq(Whole, HalfValue2, NoneTypeValue8)
}

case object Whole extends Twou45noteu45turn { override def toString = "whole" }
case object HalfValue2 extends Twou45noteu45turn { override def toString = "half" }
case object NoneTypeValue8 extends Twou45noteu45turn { override def toString = "none" }

sealed trait Upu45down

object Upu45down {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[musicxml.Upu45down]): Upu45down = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: Upu45down) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[Upu45down] = Seq(UpValue, DownValue)
}

case object UpValue extends Upu45down { override def toString = "up" }
case object DownValue extends Upu45down { override def toString = "down" }

sealed trait Uprightu45inverted

object Uprightu45inverted {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[musicxml.Uprightu45inverted]): Uprightu45inverted = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: Uprightu45inverted) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[Uprightu45inverted] = Seq(Upright, Inverted)
}

case object Upright extends Uprightu45inverted { override def toString = "upright" }
case object Inverted extends Uprightu45inverted { override def toString = "inverted" }

sealed trait Valign

object Valign {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[musicxml.Valign]): Valign = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: Valign) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[Valign] = Seq(TopValue2, MiddleValue3, BottomValue2, Baseline)
}

case object TopValue2 extends Valign { override def toString = "top" }
case object MiddleValue3 extends Valign { override def toString = "middle" }
case object BottomValue2 extends Valign { override def toString = "bottom" }
case object Baseline extends Valign { override def toString = "baseline" }

sealed trait Valignu45image

object Valignu45image {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[musicxml.Valignu45image]): Valignu45image = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: Valignu45image) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[Valignu45image] = Seq(Top, MiddleValue2, Bottom)
}

case object Top extends Valignu45image { override def toString = "top" }
case object MiddleValue2 extends Valignu45image { override def toString = "middle" }
case object Bottom extends Valignu45image { override def toString = "bottom" }

sealed trait Cancelu45location

object Cancelu45location {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[musicxml.Cancelu45location]): Cancelu45location = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: Cancelu45location) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[Cancelu45location] = Seq(LeftTypeValue, RightTypeValue, Beforeu45barline)
}

case object LeftTypeValue extends Cancelu45location { override def toString = "left" }
case object RightTypeValue extends Cancelu45location { override def toString = "right" }
case object Beforeu45barline extends Cancelu45location { override def toString = "before-barline" }

sealed trait Clefu45sign

object Clefu45sign {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[musicxml.Clefu45sign]): Clefu45sign = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: Clefu45sign) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[Clefu45sign] = Seq(G, F, C, Percussion, TAB, Jianpu, NoneTypeValue10)
}

case object G extends Clefu45sign { override def toString = "G" }
case object F extends Clefu45sign { override def toString = "F" }
case object C extends Clefu45sign { override def toString = "C" }
case object Percussion extends Clefu45sign { override def toString = "percussion" }
case object TAB extends Clefu45sign { override def toString = "TAB" }
case object Jianpu extends Clefu45sign { override def toString = "jianpu" }
case object NoneTypeValue10 extends Clefu45sign { override def toString = "none" }

sealed trait Showu45frets

object Showu45frets {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[musicxml.Showu45frets]): Showu45frets = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: Showu45frets) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[Showu45frets] = Seq(Numbers, Letters)
}

case object Numbers extends Showu45frets { override def toString = "numbers" }
case object Letters extends Showu45frets { override def toString = "letters" }

sealed trait Staffu45type

object Staffu45type {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[musicxml.Staffu45type]): Staffu45type = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: Staffu45type) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[Staffu45type] = Seq(Ossia, CueValue, Editorial, RegularValue, Alternate)
}

case object Ossia extends Staffu45type { override def toString = "ossia" }
case object CueValue extends Staffu45type { override def toString = "cue" }
case object Editorial extends Staffu45type { override def toString = "editorial" }
case object RegularValue extends Staffu45type { override def toString = "regular" }
case object Alternate extends Staffu45type { override def toString = "alternate" }

sealed trait Timeu45relation

object Timeu45relation {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[musicxml.Timeu45relation]): Timeu45relation = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: Timeu45relation) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[Timeu45relation] = Seq(Parentheses, BracketValue2, Equals, SlashValue, Space, Hyphen)
}

case object Parentheses extends Timeu45relation { override def toString = "parentheses" }
case object BracketValue2 extends Timeu45relation { override def toString = "bracket" }
case object Equals extends Timeu45relation { override def toString = "equals" }
case object SlashValue extends Timeu45relation { override def toString = "slash" }
case object Space extends Timeu45relation { override def toString = "space" }
case object Hyphen extends Timeu45relation { override def toString = "hyphen" }

sealed trait Timeu45separator

object Timeu45separator {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[musicxml.Timeu45separator]): Timeu45separator = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: Timeu45separator) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[Timeu45separator] = Seq(NoneTypeValue11, Horizontal, Diagonal, Vertical, Adjacent)
}

case object NoneTypeValue11 extends Timeu45separator { override def toString = "none" }
case object Horizontal extends Timeu45separator { override def toString = "horizontal" }
case object Diagonal extends Timeu45separator { override def toString = "diagonal" }
case object Vertical extends Timeu45separator { override def toString = "vertical" }
case object Adjacent extends Timeu45separator { override def toString = "adjacent" }

sealed trait Timeu45symbol

object Timeu45symbol {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[musicxml.Timeu45symbol]): Timeu45symbol = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: Timeu45symbol) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[Timeu45symbol] = Seq(Common, Cut, Singleu45number, NoteValue, Dottedu45note, NormalValue)
}

case object Common extends Timeu45symbol { override def toString = "common" }
case object Cut extends Timeu45symbol { override def toString = "cut" }
case object Singleu45number extends Timeu45symbol { override def toString = "single-number" }
case object NoteValue extends Timeu45symbol { override def toString = "note" }
case object Dottedu45note extends Timeu45symbol { override def toString = "dotted-note" }
case object NormalValue extends Timeu45symbol { override def toString = "normal" }

sealed trait Backwardu45forward

object Backwardu45forward {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[musicxml.Backwardu45forward]): Backwardu45forward = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: Backwardu45forward) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[Backwardu45forward] = Seq(Backward, ForwardValue)
}

case object Backward extends Backwardu45forward { override def toString = "backward" }
case object ForwardValue extends Backwardu45forward { override def toString = "forward" }

sealed trait Baru45style

object Baru45style {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[musicxml.Baru45style]): Baru45style = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: Baru45style) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[Baru45style] = Seq(Regular, Dotted, Dashed, Heavy, Lightu45light, Lightu45heavy, Heavyu45light, Heavyu45heavy, TickValue, ShortType, NoneTypeValue7)
}

case object Regular extends Baru45style { override def toString = "regular" }
case object Dotted extends Baru45style { override def toString = "dotted" }
case object Dashed extends Baru45style { override def toString = "dashed" }
case object Heavy extends Baru45style { override def toString = "heavy" }
case object Lightu45light extends Baru45style { override def toString = "light-light" }
case object Lightu45heavy extends Baru45style { override def toString = "light-heavy" }
case object Heavyu45light extends Baru45style { override def toString = "heavy-light" }
case object Heavyu45heavy extends Baru45style { override def toString = "heavy-heavy" }
case object TickValue extends Baru45style { override def toString = "tick" }
case object ShortType extends Baru45style { override def toString = "short" }
case object NoneTypeValue7 extends Baru45style { override def toString = "none" }

sealed trait Rightu45leftu45middle

object Rightu45leftu45middle {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[musicxml.Rightu45leftu45middle]): Rightu45leftu45middle = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: Rightu45leftu45middle) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[Rightu45leftu45middle] = Seq(RightType, LeftType, MiddleValue)
}

case object RightType extends Rightu45leftu45middle { override def toString = "right" }
case object LeftType extends Rightu45leftu45middle { override def toString = "left" }
case object MiddleValue extends Rightu45leftu45middle { override def toString = "middle" }

sealed trait Startu45stopu45discontinue

object Startu45stopu45discontinue {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[musicxml.Startu45stopu45discontinue]): Startu45stopu45discontinue = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: Startu45stopu45discontinue) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[Startu45stopu45discontinue] = Seq(StartValue7, StopValue8, Discontinue)
}

case object StartValue7 extends Startu45stopu45discontinue { override def toString = "start" }
case object StopValue8 extends Startu45stopu45discontinue { override def toString = "stop" }
case object Discontinue extends Startu45stopu45discontinue { override def toString = "discontinue" }

sealed trait Winged

object Winged {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[musicxml.Winged]): Winged = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: Winged) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[Winged] = Seq(NoneTypeValue6, Straight, Curved, Doubleu45straight, Doubleu45curved)
}

case object NoneTypeValue6 extends Winged { override def toString = "none" }
case object Straight extends Winged { override def toString = "straight" }
case object Curved extends Winged { override def toString = "curved" }
case object Doubleu45straight extends Winged { override def toString = "double-straight" }
case object Doubleu45curved extends Winged { override def toString = "double-curved" }

sealed trait Beateru45value

object Beateru45value {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[musicxml.Beateru45value]): Beateru45value = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: Beateru45value) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[Beateru45value] = Seq(Bow, Chimehammer, Coin, Drumstick, Finger, Fingernail, Fist, Guiroscraper, HammerValue, Hand, Jazzstick, Knittingneedle, Metalhammer, Slidebrushongong, Snarestick, Spoonmallet, SuperballValue, Trianglebeater, Trianglebeaterplain, Wirebrush)
}

case object Bow extends Beateru45value { override def toString = "bow" }
case object Chimehammer extends Beateru45value { override def toString = "chime hammer" }
case object Coin extends Beateru45value { override def toString = "coin" }
case object Drumstick extends Beateru45value { override def toString = "drum stick" }
case object Finger extends Beateru45value { override def toString = "finger" }
case object Fingernail extends Beateru45value { override def toString = "fingernail" }
case object Fist extends Beateru45value { override def toString = "fist" }
case object Guiroscraper extends Beateru45value { override def toString = "guiro scraper" }
case object HammerValue extends Beateru45value { override def toString = "hammer" }
case object Hand extends Beateru45value { override def toString = "hand" }
case object Jazzstick extends Beateru45value { override def toString = "jazz stick" }
case object Knittingneedle extends Beateru45value { override def toString = "knitting needle" }
case object Metalhammer extends Beateru45value { override def toString = "metal hammer" }
case object Slidebrushongong extends Beateru45value { override def toString = "slide brush on gong" }
case object Snarestick extends Beateru45value { override def toString = "snare stick" }
case object Spoonmallet extends Beateru45value { override def toString = "spoon mallet" }
case object SuperballValue extends Beateru45value { override def toString = "superball" }
case object Trianglebeater extends Beateru45value { override def toString = "triangle beater" }
case object Trianglebeaterplain extends Beateru45value { override def toString = "triangle beater plain" }
case object Wirebrush extends Beateru45value { override def toString = "wire brush" }

sealed trait Degreeu45symbolu45value

object Degreeu45symbolu45value {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[musicxml.Degreeu45symbolu45value]): Degreeu45symbolu45value = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: Degreeu45symbolu45value) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[Degreeu45symbolu45value] = Seq(MajorValue, MinorValue, AugmentedValue, DiminishedValue, Halfu45diminishedValue)
}

case object MajorValue extends Degreeu45symbolu45value { override def toString = "major" }
case object MinorValue extends Degreeu45symbolu45value { override def toString = "minor" }
case object AugmentedValue extends Degreeu45symbolu45value { override def toString = "augmented" }
case object DiminishedValue extends Degreeu45symbolu45value { override def toString = "diminished" }
case object Halfu45diminishedValue extends Degreeu45symbolu45value { override def toString = "half-diminished" }

sealed trait Degreeu45typeu45value

object Degreeu45typeu45value {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[musicxml.Degreeu45typeu45value]): Degreeu45typeu45value = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: Degreeu45typeu45value) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[Degreeu45typeu45value] = Seq(Add, Alter, Subtract)
}

case object Add extends Degreeu45typeu45value { override def toString = "add" }
case object Alter extends Degreeu45typeu45value { override def toString = "alter" }
case object Subtract extends Degreeu45typeu45value { override def toString = "subtract" }

sealed trait Effect

object Effect {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[musicxml.Effect]): Effect = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: Effect) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[Effect] = Seq(Anvil, Autohorn, Birdwhistle, Cannon, Duckcall, Gunshot, Klaxonhorn, Lionsroar, Lotusflute, Megaphone, Policewhistle, Siren, Slidewhistle, Thundersheet, Windmachine, Windwhistle)
}

case object Anvil extends Effect { override def toString = "anvil" }
case object Autohorn extends Effect { override def toString = "auto horn" }
case object Birdwhistle extends Effect { override def toString = "bird whistle" }
case object Cannon extends Effect { override def toString = "cannon" }
case object Duckcall extends Effect { override def toString = "duck call" }
case object Gunshot extends Effect { override def toString = "gun shot" }
case object Klaxonhorn extends Effect { override def toString = "klaxon horn" }
case object Lionsroar extends Effect { override def toString = "lions roar" }
case object Lotusflute extends Effect { override def toString = "lotus flute" }
case object Megaphone extends Effect { override def toString = "megaphone" }
case object Policewhistle extends Effect { override def toString = "police whistle" }
case object Siren extends Effect { override def toString = "siren" }
case object Slidewhistle extends Effect { override def toString = "slide whistle" }
case object Thundersheet extends Effect { override def toString = "thunder sheet" }
case object Windmachine extends Effect { override def toString = "wind machine" }
case object Windwhistle extends Effect { override def toString = "wind whistle" }

sealed trait Glassu45value

object Glassu45value {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[musicxml.Glassu45value]): Glassu45value = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: Glassu45value) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[Glassu45value] = Seq(Glassharmonica, Glassharp, Windchimes)
}

case object Glassharmonica extends Glassu45value { override def toString = "glass harmonica" }
case object Glassharp extends Glassu45value { override def toString = "glass harp" }
case object Windchimes extends Glassu45value { override def toString = "wind chimes" }

sealed trait Harmonyu45type

object Harmonyu45type {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[musicxml.Harmonyu45type]): Harmonyu45type = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: Harmonyu45type) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[Harmonyu45type] = Seq(Explicit, Implied, AlternateValue)
}

case object Explicit extends Harmonyu45type { override def toString = "explicit" }
case object Implied extends Harmonyu45type { override def toString = "implied" }
case object AlternateValue extends Harmonyu45type { override def toString = "alternate" }

sealed trait Kindu45value

object Kindu45value {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[musicxml.Kindu45value]): Kindu45value = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: Kindu45value) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[Kindu45value] = Seq(Major, Minor, Augmented, Diminished, Dominant, Majoru45seventh, Minoru45seventh, Diminishedu45seventh, Augmentedu45seventh, Halfu45diminished, Majoru45minor, Majoru45sixth, Minoru45sixth, Dominantu45ninth, Majoru45ninth, Minoru45ninth, Dominantu4511th, Majoru4511th, Minoru4511th, Dominantu4513th, Majoru4513th, Minoru4513th, Suspendedu45second, Suspendedu45fourth, Neapolitan, Italian, French, German, PedalValue, Power, Tristan, OtherValue3, NoneTypeValue5)
}

case object Major extends Kindu45value { override def toString = "major" }
case object Minor extends Kindu45value { override def toString = "minor" }
case object Augmented extends Kindu45value { override def toString = "augmented" }
case object Diminished extends Kindu45value { override def toString = "diminished" }
case object Dominant extends Kindu45value { override def toString = "dominant" }
case object Majoru45seventh extends Kindu45value { override def toString = "major-seventh" }
case object Minoru45seventh extends Kindu45value { override def toString = "minor-seventh" }
case object Diminishedu45seventh extends Kindu45value { override def toString = "diminished-seventh" }
case object Augmentedu45seventh extends Kindu45value { override def toString = "augmented-seventh" }
case object Halfu45diminished extends Kindu45value { override def toString = "half-diminished" }
case object Majoru45minor extends Kindu45value { override def toString = "major-minor" }
case object Majoru45sixth extends Kindu45value { override def toString = "major-sixth" }
case object Minoru45sixth extends Kindu45value { override def toString = "minor-sixth" }
case object Dominantu45ninth extends Kindu45value { override def toString = "dominant-ninth" }
case object Majoru45ninth extends Kindu45value { override def toString = "major-ninth" }
case object Minoru45ninth extends Kindu45value { override def toString = "minor-ninth" }
case object Dominantu4511th extends Kindu45value { override def toString = "dominant-11th" }
case object Majoru4511th extends Kindu45value { override def toString = "major-11th" }
case object Minoru4511th extends Kindu45value { override def toString = "minor-11th" }
case object Dominantu4513th extends Kindu45value { override def toString = "dominant-13th" }
case object Majoru4513th extends Kindu45value { override def toString = "major-13th" }
case object Minoru4513th extends Kindu45value { override def toString = "minor-13th" }
case object Suspendedu45second extends Kindu45value { override def toString = "suspended-second" }
case object Suspendedu45fourth extends Kindu45value { override def toString = "suspended-fourth" }
case object Neapolitan extends Kindu45value { override def toString = "Neapolitan" }
case object Italian extends Kindu45value { override def toString = "Italian" }
case object French extends Kindu45value { override def toString = "French" }
case object German extends Kindu45value { override def toString = "German" }
case object PedalValue extends Kindu45value { override def toString = "pedal" }
case object Power extends Kindu45value { override def toString = "power" }
case object Tristan extends Kindu45value { override def toString = "Tristan" }
case object OtherValue3 extends Kindu45value { override def toString = "other" }
case object NoneTypeValue5 extends Kindu45value { override def toString = "none" }

sealed trait Lineu45end

object Lineu45end {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[musicxml.Lineu45end]): Lineu45end = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: Lineu45end) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[Lineu45end] = Seq(UpValue2, DownValue2, Both, Arrow, NoneTypeValue12)
}

case object UpValue2 extends Lineu45end { override def toString = "up" }
case object DownValue2 extends Lineu45end { override def toString = "down" }
case object Both extends Lineu45end { override def toString = "both" }
case object Arrow extends Lineu45end { override def toString = "arrow" }
case object NoneTypeValue12 extends Lineu45end { override def toString = "none" }

sealed trait Measureu45numberingu45value

object Measureu45numberingu45value {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[musicxml.Measureu45numberingu45value]): Measureu45numberingu45value = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: Measureu45numberingu45value) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[Measureu45numberingu45value] = Seq(NoneTypeValue4, MeasureValue, System)
}

case object NoneTypeValue4 extends Measureu45numberingu45value { override def toString = "none" }
case object MeasureValue extends Measureu45numberingu45value { override def toString = "measure" }
case object System extends Measureu45numberingu45value { override def toString = "system" }

sealed trait Membrane

object Membrane {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[musicxml.Membrane]): Membrane = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: Membrane) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[Membrane] = Seq(BassdrumValue, Bassdrumonside, Bongos, Chinesetomtom, Congadrum, Cuica, Gobletdrum, Indou45Americantomtom, Japanesetomtom, Militarydrum, Snaredrum, Snaredrumsnaresoff, Tabla, Tambourine, Tenordrum, Timbales, Tomtom)
}

case object BassdrumValue extends Membrane { override def toString = "bass drum" }
case object Bassdrumonside extends Membrane { override def toString = "bass drum on side" }
case object Bongos extends Membrane { override def toString = "bongos" }
case object Chinesetomtom extends Membrane { override def toString = "Chinese tomtom" }
case object Congadrum extends Membrane { override def toString = "conga drum" }
case object Cuica extends Membrane { override def toString = "cuica" }
case object Gobletdrum extends Membrane { override def toString = "goblet drum" }
case object Indou45Americantomtom extends Membrane { override def toString = "Indo-American tomtom" }
case object Japanesetomtom extends Membrane { override def toString = "Japanese tomtom" }
case object Militarydrum extends Membrane { override def toString = "military drum" }
case object Snaredrum extends Membrane { override def toString = "snare drum" }
case object Snaredrumsnaresoff extends Membrane { override def toString = "snare drum snares off" }
case object Tabla extends Membrane { override def toString = "tabla" }
case object Tambourine extends Membrane { override def toString = "tambourine" }
case object Tenordrum extends Membrane { override def toString = "tenor drum" }
case object Timbales extends Membrane { override def toString = "timbales" }
case object Tomtom extends Membrane { override def toString = "tomtom" }

sealed trait Metal

object Metal {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[musicxml.Metal]): Metal = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: Metal) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[Metal] = Seq(Agogo, Almglocken, Bell, Bellplate, BelltreeValue, Brakedrum, Cencerro, Chainrattle, Chinesecymbal, Cowbell, Crashcymbals, Crotale, Cymbaltongs, Domedgong, Fingercymbals, Flexatone, Gong, Hiu45hat, Highu45hatcymbals, HandbellValue, Jawharp, Jinglebells, Musicalsaw, Shellbells, Sistrum, Sizzlecymbal, Sleighbells, Suspendedcymbal, Tamtam, Tamtamwithbeater, TriangleValue, Vietnamesehat)
}

case object Agogo extends Metal { override def toString = "agogo" }
case object Almglocken extends Metal { override def toString = "almglocken" }
case object Bell extends Metal { override def toString = "bell" }
case object Bellplate extends Metal { override def toString = "bell plate" }
case object BelltreeValue extends Metal { override def toString = "bell tree" }
case object Brakedrum extends Metal { override def toString = "brake drum" }
case object Cencerro extends Metal { override def toString = "cencerro" }
case object Chainrattle extends Metal { override def toString = "chain rattle" }
case object Chinesecymbal extends Metal { override def toString = "Chinese cymbal" }
case object Cowbell extends Metal { override def toString = "cowbell" }
case object Crashcymbals extends Metal { override def toString = "crash cymbals" }
case object Crotale extends Metal { override def toString = "crotale" }
case object Cymbaltongs extends Metal { override def toString = "cymbal tongs" }
case object Domedgong extends Metal { override def toString = "domed gong" }
case object Fingercymbals extends Metal { override def toString = "finger cymbals" }
case object Flexatone extends Metal { override def toString = "flexatone" }
case object Gong extends Metal { override def toString = "gong" }
case object Hiu45hat extends Metal { override def toString = "hi-hat" }
case object Highu45hatcymbals extends Metal { override def toString = "high-hat cymbals" }
case object HandbellValue extends Metal { override def toString = "handbell" }
case object Jawharp extends Metal { override def toString = "jaw harp" }
case object Jinglebells extends Metal { override def toString = "jingle bells" }
case object Musicalsaw extends Metal { override def toString = "musical saw" }
case object Shellbells extends Metal { override def toString = "shell bells" }
case object Sistrum extends Metal { override def toString = "sistrum" }
case object Sizzlecymbal extends Metal { override def toString = "sizzle cymbal" }
case object Sleighbells extends Metal { override def toString = "sleigh bells" }
case object Suspendedcymbal extends Metal { override def toString = "suspended cymbal" }
case object Tamtam extends Metal { override def toString = "tam tam" }
case object Tamtamwithbeater extends Metal { override def toString = "tam tam with beater" }
case object TriangleValue extends Metal { override def toString = "triangle" }
case object Vietnamesehat extends Metal { override def toString = "Vietnamese hat" }

sealed trait Onu45off

object Onu45off {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[musicxml.Onu45off]): Onu45off = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: Onu45off) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[Onu45off] = Seq(OnValue, OffValue)
}

case object OnValue extends Onu45off { override def toString = "on" }
case object OffValue extends Onu45off { override def toString = "off" }

sealed trait Pedalu45type

object Pedalu45type {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[musicxml.Pedalu45type]): Pedalu45type = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: Pedalu45type) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[Pedalu45type] = Seq(StartValue, StopValue2, Sostenuto, ChangeValue, ContinueValue2)
}

case object StartValue extends Pedalu45type { override def toString = "start" }
case object StopValue2 extends Pedalu45type { override def toString = "stop" }
case object Sostenuto extends Pedalu45type { override def toString = "sostenuto" }
case object ChangeValue extends Pedalu45type { override def toString = "change" }
case object ContinueValue2 extends Pedalu45type { override def toString = "continue" }

sealed trait Pitchedu45value

object Pitchedu45value {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[musicxml.Pitchedu45value]): Pitchedu45value = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: Pitchedu45value) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[Pitchedu45value] = Seq(Celesta, Chimes, GlockenspielValue, Lithophone, Mallet, Marimba, Steeldrums, Tubaphone, Tubularchimes, Vibraphone, XylophoneValue)
}

case object Celesta extends Pitchedu45value { override def toString = "celesta" }
case object Chimes extends Pitchedu45value { override def toString = "chimes" }
case object GlockenspielValue extends Pitchedu45value { override def toString = "glockenspiel" }
case object Lithophone extends Pitchedu45value { override def toString = "lithophone" }
case object Mallet extends Pitchedu45value { override def toString = "mallet" }
case object Marimba extends Pitchedu45value { override def toString = "marimba" }
case object Steeldrums extends Pitchedu45value { override def toString = "steel drums" }
case object Tubaphone extends Pitchedu45value { override def toString = "tubaphone" }
case object Tubularchimes extends Pitchedu45value { override def toString = "tubular chimes" }
case object Vibraphone extends Pitchedu45value { override def toString = "vibraphone" }
case object XylophoneValue extends Pitchedu45value { override def toString = "xylophone" }

sealed trait Principalu45voiceu45symbol

object Principalu45voiceu45symbol {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[musicxml.Principalu45voiceu45symbol]): Principalu45voiceu45symbol = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: Principalu45voiceu45symbol) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[Principalu45voiceu45symbol] = Seq(Hauptstimme, Nebenstimme, Plain, NoneTypeValue3)
}

case object Hauptstimme extends Principalu45voiceu45symbol { override def toString = "Hauptstimme" }
case object Nebenstimme extends Principalu45voiceu45symbol { override def toString = "Nebenstimme" }
case object Plain extends Principalu45voiceu45symbol { override def toString = "plain" }
case object NoneTypeValue3 extends Principalu45voiceu45symbol { override def toString = "none" }

sealed trait Staffu45divideu45symbol

object Staffu45divideu45symbol {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[musicxml.Staffu45divideu45symbol]): Staffu45divideu45symbol = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: Staffu45divideu45symbol) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[Staffu45divideu45symbol] = Seq(DownValue3, UpValue3, Upu45downValue)
}

case object DownValue3 extends Staffu45divideu45symbol { override def toString = "down" }
case object UpValue3 extends Staffu45divideu45symbol { override def toString = "up" }
case object Upu45downValue extends Staffu45divideu45symbol { override def toString = "up-down" }

sealed trait Startu45stopu45changeu45continue

object Startu45stopu45changeu45continue {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[musicxml.Startu45stopu45changeu45continue]): Startu45stopu45changeu45continue = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: Startu45stopu45changeu45continue) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[Startu45stopu45changeu45continue] = Seq(Start, StopValue, Change, ContinueValue)
}

case object Start extends Startu45stopu45changeu45continue { override def toString = "start" }
case object StopValue extends Startu45stopu45changeu45continue { override def toString = "stop" }
case object Change extends Startu45stopu45changeu45continue { override def toString = "change" }
case object ContinueValue extends Startu45stopu45changeu45continue { override def toString = "continue" }

sealed trait Tipu45direction

object Tipu45direction {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[musicxml.Tipu45direction]): Tipu45direction = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: Tipu45direction) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[Tipu45direction] = Seq(UpValue4, DownValue4, LeftTypeValue4, RightTypeValue4, Northwest, Northeast, Southeast, Southwest)
}

case object UpValue4 extends Tipu45direction { override def toString = "up" }
case object DownValue4 extends Tipu45direction { override def toString = "down" }
case object LeftTypeValue4 extends Tipu45direction { override def toString = "left" }
case object RightTypeValue4 extends Tipu45direction { override def toString = "right" }
case object Northwest extends Tipu45direction { override def toString = "northwest" }
case object Northeast extends Tipu45direction { override def toString = "northeast" }
case object Southeast extends Tipu45direction { override def toString = "southeast" }
case object Southwest extends Tipu45direction { override def toString = "southwest" }

sealed trait Sticku45location

object Sticku45location {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[musicxml.Sticku45location]): Sticku45location = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: Sticku45location) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[Sticku45location] = Seq(Center, Rim, Cymbalbell, Cymbaledge)
}

case object Center extends Sticku45location { override def toString = "center" }
case object Rim extends Sticku45location { override def toString = "rim" }
case object Cymbalbell extends Sticku45location { override def toString = "cymbal bell" }
case object Cymbaledge extends Sticku45location { override def toString = "cymbal edge" }

sealed trait Sticku45material

object Sticku45material {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[musicxml.Sticku45material]): Sticku45material = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: Sticku45material) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[Sticku45material] = Seq(Soft, MediumValue3, Hard, Shaded, XValue)
}

case object Soft extends Sticku45material { override def toString = "soft" }
case object MediumValue3 extends Sticku45material { override def toString = "medium" }
case object Hard extends Sticku45material { override def toString = "hard" }
case object Shaded extends Sticku45material { override def toString = "shaded" }
case object XValue extends Sticku45material { override def toString = "x" }

sealed trait Sticku45type

object Sticku45type {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[musicxml.Sticku45type]): Sticku45type = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: Sticku45type) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[Sticku45type] = Seq(Bassdrum, Doublebassdrum, Glockenspiel, Gum, Hammer, Superball, Timpani, Wound, Xylophone, Yarn)
}

case object Bassdrum extends Sticku45type { override def toString = "bass drum" }
case object Doublebassdrum extends Sticku45type { override def toString = "double bass drum" }
case object Glockenspiel extends Sticku45type { override def toString = "glockenspiel" }
case object Gum extends Sticku45type { override def toString = "gum" }
case object Hammer extends Sticku45type { override def toString = "hammer" }
case object Superball extends Sticku45type { override def toString = "superball" }
case object Timpani extends Sticku45type { override def toString = "timpani" }
case object Wound extends Sticku45type { override def toString = "wound" }
case object Xylophone extends Sticku45type { override def toString = "xylophone" }
case object Yarn extends Sticku45type { override def toString = "yarn" }

sealed trait Upu45downu45stopu45continue

object Upu45downu45stopu45continue {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[musicxml.Upu45downu45stopu45continue]): Upu45downu45stopu45continue = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: Upu45downu45stopu45continue) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[Upu45downu45stopu45continue] = Seq(UpValue5, DownValue5, StopValue9, ContinueValue5)
}

case object UpValue5 extends Upu45downu45stopu45continue { override def toString = "up" }
case object DownValue5 extends Upu45downu45stopu45continue { override def toString = "down" }
case object StopValue9 extends Upu45downu45stopu45continue { override def toString = "stop" }
case object ContinueValue5 extends Upu45downu45stopu45continue { override def toString = "continue" }

sealed trait Wedgeu45type

object Wedgeu45type {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[musicxml.Wedgeu45type]): Wedgeu45type = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: Wedgeu45type) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[Wedgeu45type] = Seq(Crescendo, Diminuendo, Stop, Continue)
}

case object Crescendo extends Wedgeu45type { override def toString = "crescendo" }
case object Diminuendo extends Wedgeu45type { override def toString = "diminuendo" }
case object Stop extends Wedgeu45type { override def toString = "stop" }
case object Continue extends Wedgeu45type { override def toString = "continue" }

sealed trait Wood

object Wood {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[musicxml.Wood]): Wood = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: Wood) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[Wood] = Seq(Bambooscraper, Boardclapper, Cabasa, Castanets, Castanetswithhandle, Claves, Footballrattle, Guiro, Logdrum, Maraca, Maracas, Quijada, Rainstick, Ratchet, Recou45reco, Sandpaperblocks, Slitdrum, Templeblock, Vibraslap, Whip, Woodblock)
}

case object Bambooscraper extends Wood { override def toString = "bamboo scraper" }
case object Boardclapper extends Wood { override def toString = "board clapper" }
case object Cabasa extends Wood { override def toString = "cabasa" }
case object Castanets extends Wood { override def toString = "castanets" }
case object Castanetswithhandle extends Wood { override def toString = "castanets with handle" }
case object Claves extends Wood { override def toString = "claves" }
case object Footballrattle extends Wood { override def toString = "football rattle" }
case object Guiro extends Wood { override def toString = "guiro" }
case object Logdrum extends Wood { override def toString = "log drum" }
case object Maraca extends Wood { override def toString = "maraca" }
case object Maracas extends Wood { override def toString = "maracas" }
case object Quijada extends Wood { override def toString = "quijada" }
case object Rainstick extends Wood { override def toString = "rainstick" }
case object Ratchet extends Wood { override def toString = "ratchet" }
case object Recou45reco extends Wood { override def toString = "reco-reco" }
case object Sandpaperblocks extends Wood { override def toString = "sandpaper blocks" }
case object Slitdrum extends Wood { override def toString = "slit drum" }
case object Templeblock extends Wood { override def toString = "temple block" }
case object Vibraslap extends Wood { override def toString = "vibraslap" }
case object Whip extends Wood { override def toString = "whip" }
case object Woodblock extends Wood { override def toString = "wood block" }

sealed trait Marginu45type

object Marginu45type {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[musicxml.Marginu45type]): Marginu45type = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: Marginu45type) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[Marginu45type] = Seq(Odd, Even, BothValue)
}

case object Odd extends Marginu45type { override def toString = "odd" }
case object Even extends Marginu45type { override def toString = "even" }
case object BothValue extends Marginu45type { override def toString = "both" }

sealed trait Noteu45sizeu45type

object Noteu45sizeu45type {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[musicxml.Noteu45sizeu45type]): Noteu45sizeu45type = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: Noteu45sizeu45type) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[Noteu45sizeu45type] = Seq(CueValue2, GraceValue, Graceu45cueValue, LargeValue2)
}

case object CueValue2 extends Noteu45sizeu45type { override def toString = "cue" }
case object GraceValue extends Noteu45sizeu45type { override def toString = "grace" }
case object Graceu45cueValue extends Noteu45sizeu45type { override def toString = "grace-cue" }
case object LargeValue2 extends Noteu45sizeu45type { override def toString = "large" }

sealed trait Accidentalu45value

object Accidentalu45value {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[musicxml.Accidentalu45value]): Accidentalu45value = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: Accidentalu45value) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[Accidentalu45value] = Seq(Sharp, Natural, Flat, Doubleu45sharp, Sharpu45sharp, Flatu45flat, Naturalu45sharp, Naturalu45flat, Quarteru45flat, Quarteru45sharp, Threeu45quartersu45flat, Threeu45quartersu45sharp, Sharpu45down, Sharpu45up, Naturalu45down, Naturalu45up, Flatu45down, Flatu45up, Doubleu45sharpu45down, Doubleu45sharpu45up, Flatu45flatu45down, Flatu45flatu45up, Arrowu45down, Arrowu45up, Tripleu45sharp, Tripleu45flat, Slashu45quarteru45sharp, Slashu45sharp, Slashu45flat, Doubleu45slashu45flat, Sharpu451, Sharpu452, Sharpu453, Sharpu455, Flatu451, Flatu452, Flatu453, Flatu454, Sori, Koron, OtherValue2)
}

case object Sharp extends Accidentalu45value { override def toString = "sharp" }
case object Natural extends Accidentalu45value { override def toString = "natural" }
case object Flat extends Accidentalu45value { override def toString = "flat" }
case object Doubleu45sharp extends Accidentalu45value { override def toString = "double-sharp" }
case object Sharpu45sharp extends Accidentalu45value { override def toString = "sharp-sharp" }
case object Flatu45flat extends Accidentalu45value { override def toString = "flat-flat" }
case object Naturalu45sharp extends Accidentalu45value { override def toString = "natural-sharp" }
case object Naturalu45flat extends Accidentalu45value { override def toString = "natural-flat" }
case object Quarteru45flat extends Accidentalu45value { override def toString = "quarter-flat" }
case object Quarteru45sharp extends Accidentalu45value { override def toString = "quarter-sharp" }
case object Threeu45quartersu45flat extends Accidentalu45value { override def toString = "three-quarters-flat" }
case object Threeu45quartersu45sharp extends Accidentalu45value { override def toString = "three-quarters-sharp" }
case object Sharpu45down extends Accidentalu45value { override def toString = "sharp-down" }
case object Sharpu45up extends Accidentalu45value { override def toString = "sharp-up" }
case object Naturalu45down extends Accidentalu45value { override def toString = "natural-down" }
case object Naturalu45up extends Accidentalu45value { override def toString = "natural-up" }
case object Flatu45down extends Accidentalu45value { override def toString = "flat-down" }
case object Flatu45up extends Accidentalu45value { override def toString = "flat-up" }
case object Doubleu45sharpu45down extends Accidentalu45value { override def toString = "double-sharp-down" }
case object Doubleu45sharpu45up extends Accidentalu45value { override def toString = "double-sharp-up" }
case object Flatu45flatu45down extends Accidentalu45value { override def toString = "flat-flat-down" }
case object Flatu45flatu45up extends Accidentalu45value { override def toString = "flat-flat-up" }
case object Arrowu45down extends Accidentalu45value { override def toString = "arrow-down" }
case object Arrowu45up extends Accidentalu45value { override def toString = "arrow-up" }
case object Tripleu45sharp extends Accidentalu45value { override def toString = "triple-sharp" }
case object Tripleu45flat extends Accidentalu45value { override def toString = "triple-flat" }
case object Slashu45quarteru45sharp extends Accidentalu45value { override def toString = "slash-quarter-sharp" }
case object Slashu45sharp extends Accidentalu45value { override def toString = "slash-sharp" }
case object Slashu45flat extends Accidentalu45value { override def toString = "slash-flat" }
case object Doubleu45slashu45flat extends Accidentalu45value { override def toString = "double-slash-flat" }
case object Sharpu451 extends Accidentalu45value { override def toString = "sharp-1" }
case object Sharpu452 extends Accidentalu45value { override def toString = "sharp-2" }
case object Sharpu453 extends Accidentalu45value { override def toString = "sharp-3" }
case object Sharpu455 extends Accidentalu45value { override def toString = "sharp-5" }
case object Flatu451 extends Accidentalu45value { override def toString = "flat-1" }
case object Flatu452 extends Accidentalu45value { override def toString = "flat-2" }
case object Flatu453 extends Accidentalu45value { override def toString = "flat-3" }
case object Flatu454 extends Accidentalu45value { override def toString = "flat-4" }
case object Sori extends Accidentalu45value { override def toString = "sori" }
case object Koron extends Accidentalu45value { override def toString = "koron" }
case object OtherValue2 extends Accidentalu45value { override def toString = "other" }

sealed trait Arrowu45direction

object Arrowu45direction {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[musicxml.Arrowu45direction]): Arrowu45direction = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: Arrowu45direction) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[Arrowu45direction] = Seq(LeftTypeValue5, UpValue6, RightTypeValue5, DownValue6, NorthwestValue, NortheastValue, SoutheastValue, SouthwestValue, Leftright, Updown, Northwestsoutheast, Northeastsouthwest, OtherValue4)
}

case object LeftTypeValue5 extends Arrowu45direction { override def toString = "left" }
case object UpValue6 extends Arrowu45direction { override def toString = "up" }
case object RightTypeValue5 extends Arrowu45direction { override def toString = "right" }
case object DownValue6 extends Arrowu45direction { override def toString = "down" }
case object NorthwestValue extends Arrowu45direction { override def toString = "northwest" }
case object NortheastValue extends Arrowu45direction { override def toString = "northeast" }
case object SoutheastValue extends Arrowu45direction { override def toString = "southeast" }
case object SouthwestValue extends Arrowu45direction { override def toString = "southwest" }
case object Leftright extends Arrowu45direction { override def toString = "left right" }
case object Updown extends Arrowu45direction { override def toString = "up down" }
case object Northwestsoutheast extends Arrowu45direction { override def toString = "northwest southeast" }
case object Northeastsouthwest extends Arrowu45direction { override def toString = "northeast southwest" }
case object OtherValue4 extends Arrowu45direction { override def toString = "other" }

sealed trait Arrowu45style

object Arrowu45style {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[musicxml.Arrowu45style]): Arrowu45style = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: Arrowu45style) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[Arrowu45style] = Seq(SingleValue, DoubleTypeValue, Filled, Hollow, Paired, Combined, OtherValue)
}

case object SingleValue extends Arrowu45style { override def toString = "single" }
case object DoubleTypeValue extends Arrowu45style { override def toString = "double" }
case object Filled extends Arrowu45style { override def toString = "filled" }
case object Hollow extends Arrowu45style { override def toString = "hollow" }
case object Paired extends Arrowu45style { override def toString = "paired" }
case object Combined extends Arrowu45style { override def toString = "combined" }
case object OtherValue extends Arrowu45style { override def toString = "other" }

sealed trait Beamu45value

object Beamu45value {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[musicxml.Beamu45value]): Beamu45value = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: Beamu45value) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[Beamu45value] = Seq(BeginValue, ContinueValue6, EndValue, Forwardhook, Backwardhook)
}

case object BeginValue extends Beamu45value { override def toString = "begin" }
case object ContinueValue6 extends Beamu45value { override def toString = "continue" }
case object EndValue extends Beamu45value { override def toString = "end" }
case object Forwardhook extends Beamu45value { override def toString = "forward hook" }
case object Backwardhook extends Beamu45value { override def toString = "backward hook" }

sealed trait Breathu45marku45value

object Breathu45marku45value {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[musicxml.Breathu45marku45value]): Breathu45marku45value = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: Breathu45marku45value) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[Breathu45marku45value] = Seq(Blank, Comma, Tick, Upbow, Salzedo)
}

case object Blank extends Breathu45marku45value { override def toString = "" }
case object Comma extends Breathu45marku45value { override def toString = "comma" }
case object Tick extends Breathu45marku45value { override def toString = "tick" }
case object Upbow extends Breathu45marku45value { override def toString = "upbow" }
case object Salzedo extends Breathu45marku45value { override def toString = "salzedo" }

sealed trait Caesurau45value

object Caesurau45value {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[musicxml.Caesurau45value]): Caesurau45value = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: Caesurau45value) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[Caesurau45value] = Seq(NormalValue5, Thick, ShortTypeValue2, CurvedValue2, SingleValue4, BlankValue2)
}

case object NormalValue5 extends Caesurau45value { override def toString = "normal" }
case object Thick extends Caesurau45value { override def toString = "thick" }
case object ShortTypeValue2 extends Caesurau45value { override def toString = "short" }
case object CurvedValue2 extends Caesurau45value { override def toString = "curved" }
case object SingleValue4 extends Caesurau45value { override def toString = "single" }
case object BlankValue2 extends Caesurau45value { override def toString = "" }

sealed trait Circularu45arrow

object Circularu45arrow {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[musicxml.Circularu45arrow]): Circularu45arrow = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: Circularu45arrow) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[Circularu45arrow] = Seq(Clockwise, Anticlockwise)
}

case object Clockwise extends Circularu45arrow { override def toString = "clockwise" }
case object Anticlockwise extends Circularu45arrow { override def toString = "anticlockwise" }

sealed trait Fan

object Fan {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[musicxml.Fan]): Fan = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: Fan) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[Fan] = Seq(Accel, Rit, NoneTypeValue13)
}

case object Accel extends Fan { override def toString = "accel" }
case object Rit extends Fan { override def toString = "rit" }
case object NoneTypeValue13 extends Fan { override def toString = "none" }

sealed trait Handbellu45value

object Handbellu45value {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[musicxml.Handbellu45value]): Handbellu45value = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: Handbellu45value) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[Handbellu45value] = Seq(Belltree, Damp, Echo, Gyro, Handmartellato, Malletlift, Mallettable, Martellato, Martellatolift, Mutedmartellato, Plucklift, Swing)
}

case object Belltree extends Handbellu45value { override def toString = "belltree" }
case object Damp extends Handbellu45value { override def toString = "damp" }
case object Echo extends Handbellu45value { override def toString = "echo" }
case object Gyro extends Handbellu45value { override def toString = "gyro" }
case object Handmartellato extends Handbellu45value { override def toString = "hand martellato" }
case object Malletlift extends Handbellu45value { override def toString = "mallet lift" }
case object Mallettable extends Handbellu45value { override def toString = "mallet table" }
case object Martellato extends Handbellu45value { override def toString = "martellato" }
case object Martellatolift extends Handbellu45value { override def toString = "martellato lift" }
case object Mutedmartellato extends Handbellu45value { override def toString = "muted martellato" }
case object Plucklift extends Handbellu45value { override def toString = "pluck lift" }
case object Swing extends Handbellu45value { override def toString = "swing" }

sealed trait Harmonu45closedu45location

object Harmonu45closedu45location {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[musicxml.Harmonu45closedu45location]): Harmonu45closedu45location = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: Harmonu45closedu45location) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[Harmonu45closedu45location] = Seq(RightTypeValue6, BottomValue3, LeftTypeValue6, TopValue3)
}

case object RightTypeValue6 extends Harmonu45closedu45location { override def toString = "right" }
case object BottomValue3 extends Harmonu45closedu45location { override def toString = "bottom" }
case object LeftTypeValue6 extends Harmonu45closedu45location { override def toString = "left" }
case object TopValue3 extends Harmonu45closedu45location { override def toString = "top" }

sealed trait Harmonu45closedu45value

object Harmonu45closedu45value {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[musicxml.Harmonu45closedu45value]): Harmonu45closedu45value = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: Harmonu45closedu45value) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[Harmonu45closedu45value] = Seq(YesValue2, NoValue2, HalfValue)
}

case object YesValue2 extends Harmonu45closedu45value { override def toString = "yes" }
case object NoValue2 extends Harmonu45closedu45value { override def toString = "no" }
case object HalfValue extends Harmonu45closedu45value { override def toString = "half" }

sealed trait Holeu45closedu45location

object Holeu45closedu45location {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[musicxml.Holeu45closedu45location]): Holeu45closedu45location = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: Holeu45closedu45location) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[Holeu45closedu45location] = Seq(RightTypeValue7, BottomValue4, LeftTypeValue7, TopValue4)
}

case object RightTypeValue7 extends Holeu45closedu45location { override def toString = "right" }
case object BottomValue4 extends Holeu45closedu45location { override def toString = "bottom" }
case object LeftTypeValue7 extends Holeu45closedu45location { override def toString = "left" }
case object TopValue4 extends Holeu45closedu45location { override def toString = "top" }

sealed trait Holeu45closedu45value

object Holeu45closedu45value {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[musicxml.Holeu45closedu45value]): Holeu45closedu45value = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: Holeu45closedu45value) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[Holeu45closedu45value] = Seq(YesValue, NoValue, Half)
}

case object YesValue extends Holeu45closedu45value { override def toString = "yes" }
case object NoValue extends Holeu45closedu45value { override def toString = "no" }
case object Half extends Holeu45closedu45value { override def toString = "half" }

sealed trait Noteu45typeu45value

object Noteu45typeu45value {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[musicxml.Noteu45typeu45value]): Noteu45typeu45value = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: Noteu45typeu45value) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[Noteu45typeu45value] = Seq(Number1024th, Number512th, Number256th, Number128th, Number64th, Number32nd, Number16th, Eighth, Quarter, HalfValue4, WholeValue2, Breve, LongTypeValue, Maxima)
}

case object Number1024th extends Noteu45typeu45value { override def toString = "1024th" }
case object Number512th extends Noteu45typeu45value { override def toString = "512th" }
case object Number256th extends Noteu45typeu45value { override def toString = "256th" }
case object Number128th extends Noteu45typeu45value { override def toString = "128th" }
case object Number64th extends Noteu45typeu45value { override def toString = "64th" }
case object Number32nd extends Noteu45typeu45value { override def toString = "32nd" }
case object Number16th extends Noteu45typeu45value { override def toString = "16th" }
case object Eighth extends Noteu45typeu45value { override def toString = "eighth" }
case object Quarter extends Noteu45typeu45value { override def toString = "quarter" }
case object HalfValue4 extends Noteu45typeu45value { override def toString = "half" }
case object WholeValue2 extends Noteu45typeu45value { override def toString = "whole" }
case object Breve extends Noteu45typeu45value { override def toString = "breve" }
case object LongTypeValue extends Noteu45typeu45value { override def toString = "long" }
case object Maxima extends Noteu45typeu45value { override def toString = "maxima" }

sealed trait Noteheadu45value

object Noteheadu45value {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[musicxml.Noteheadu45value]): Noteheadu45value = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: Noteheadu45value) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[Noteheadu45value] = Seq(Slash, Triangle, Diamond, SquareValue, Cross, X, Circleu45x, Invertedtriangle, Arrowdown, Arrowup, Circled, Slashed, Backslashed, Normal, Cluster, Circledot, Lefttriangle, Rectangle, NoneTypeValue2, Do, Re, Mi, Fa, Faup, So, La, Ti, Other)
}

case object Slash extends Noteheadu45value { override def toString = "slash" }
case object Triangle extends Noteheadu45value { override def toString = "triangle" }
case object Diamond extends Noteheadu45value { override def toString = "diamond" }
case object SquareValue extends Noteheadu45value { override def toString = "square" }
case object Cross extends Noteheadu45value { override def toString = "cross" }
case object X extends Noteheadu45value { override def toString = "x" }
case object Circleu45x extends Noteheadu45value { override def toString = "circle-x" }
case object Invertedtriangle extends Noteheadu45value { override def toString = "inverted triangle" }
case object Arrowdown extends Noteheadu45value { override def toString = "arrow down" }
case object Arrowup extends Noteheadu45value { override def toString = "arrow up" }
case object Circled extends Noteheadu45value { override def toString = "circled" }
case object Slashed extends Noteheadu45value { override def toString = "slashed" }
case object Backslashed extends Noteheadu45value { override def toString = "back slashed" }
case object Normal extends Noteheadu45value { override def toString = "normal" }
case object Cluster extends Noteheadu45value { override def toString = "cluster" }
case object Circledot extends Noteheadu45value { override def toString = "circle dot" }
case object Lefttriangle extends Noteheadu45value { override def toString = "left triangle" }
case object Rectangle extends Noteheadu45value { override def toString = "rectangle" }
case object NoneTypeValue2 extends Noteheadu45value { override def toString = "none" }
case object Do extends Noteheadu45value { override def toString = "do" }
case object Re extends Noteheadu45value { override def toString = "re" }
case object Mi extends Noteheadu45value { override def toString = "mi" }
case object Fa extends Noteheadu45value { override def toString = "fa" }
case object Faup extends Noteheadu45value { override def toString = "fa up" }
case object So extends Noteheadu45value { override def toString = "so" }
case object La extends Noteheadu45value { override def toString = "la" }
case object Ti extends Noteheadu45value { override def toString = "ti" }
case object Other extends Noteheadu45value { override def toString = "other" }

sealed trait Showu45tuplet

object Showu45tuplet {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[musicxml.Showu45tuplet]): Showu45tuplet = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: Showu45tuplet) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[Showu45tuplet] = Seq(Actual, BothValue2, NoneTypeValue14)
}

case object Actual extends Showu45tuplet { override def toString = "actual" }
case object BothValue2 extends Showu45tuplet { override def toString = "both" }
case object NoneTypeValue14 extends Showu45tuplet { override def toString = "none" }

sealed trait Stemu45value

object Stemu45value {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[musicxml.Stemu45value]): Stemu45value = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: Stemu45value) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[Stemu45value] = Seq(Down, Up, DoubleType, NoneTypeValue)
}

case object Down extends Stemu45value { override def toString = "down" }
case object Up extends Stemu45value { override def toString = "up" }
case object DoubleType extends Stemu45value { override def toString = "double" }
case object NoneTypeValue extends Stemu45value { override def toString = "none" }

sealed trait Step

object Step {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[musicxml.Step]): Step = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: Step) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[Step] = Seq(A, B, CValue, D, E, FValue, GValue)
}

case object A extends Step { override def toString = "A" }
case object B extends Step { override def toString = "B" }
case object CValue extends Step { override def toString = "C" }
case object D extends Step { override def toString = "D" }
case object E extends Step { override def toString = "E" }
case object FValue extends Step { override def toString = "F" }
case object GValue extends Step { override def toString = "G" }

sealed trait Syllabic

object Syllabic {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[musicxml.Syllabic]): Syllabic = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: Syllabic) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[Syllabic] = Seq(Single, Begin, End, Middle)
}

case object Single extends Syllabic { override def toString = "single" }
case object Begin extends Syllabic { override def toString = "begin" }
case object End extends Syllabic { override def toString = "end" }
case object Middle extends Syllabic { override def toString = "middle" }

sealed trait Tapu45hand

object Tapu45hand {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[musicxml.Tapu45hand]): Tapu45hand = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: Tapu45hand) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[Tapu45hand] = Seq(LeftTypeValue8, RightTypeValue8)
}

case object LeftTypeValue8 extends Tapu45hand { override def toString = "left" }
case object RightTypeValue8 extends Tapu45hand { override def toString = "right" }

sealed trait Groupu45barlineu45value

object Groupu45barlineu45value {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[musicxml.Groupu45barlineu45value]): Groupu45barlineu45value = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: Groupu45barlineu45value) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[Groupu45barlineu45value] = Seq(YesValue3, NoValue3, Mensurstrich)
}

case object YesValue3 extends Groupu45barlineu45value { override def toString = "yes" }
case object NoValue3 extends Groupu45barlineu45value { override def toString = "no" }
case object Mensurstrich extends Groupu45barlineu45value { override def toString = "Mensurstrich" }

sealed trait Groupu45symbolu45value

object Groupu45symbolu45value {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[musicxml.Groupu45symbolu45value]): Groupu45symbolu45value = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: Groupu45symbolu45value) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[Groupu45symbolu45value] = Seq(NoneType, Brace, Line, BracketValue, Square)
}

case object NoneType extends Groupu45symbolu45value { override def toString = "none" }
case object Brace extends Groupu45symbolu45value { override def toString = "brace" }
case object Line extends Groupu45symbolu45value { override def toString = "line" }
case object BracketValue extends Groupu45symbolu45value { override def toString = "bracket" }
case object Square extends Groupu45symbolu45value { override def toString = "square" }


/** The accidental-text type represents an element with an accidental value and text-formatting attributes.
*/
case class Accidentalu45text(value: musicxml.Accidentalu45value,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Nameu45displayOption with Noteheadu45textOption {
  lazy val justify = attributes.get("@justify") map { _.as[Leftu45centeru45right]}
  lazy val defaultu45x = attributes.get("@default-x") map { _.as[BigDecimal]}
  lazy val defaultu45y = attributes.get("@default-y") map { _.as[BigDecimal]}
  lazy val relativeu45x = attributes.get("@relative-x") map { _.as[BigDecimal]}
  lazy val relativeu45y = attributes.get("@relative-y") map { _.as[BigDecimal]}
  lazy val fontu45family = attributes.get("@font-family") map { _.as[String]}
  lazy val fontu45style = attributes.get("@font-style") map { _.as[Fontu45style]}
  lazy val fontu45size = attributes.get("@font-size") map { _.as[String]}
  lazy val fontu45weight = attributes.get("@font-weight") map { _.as[Fontu45weight]}
  lazy val color = attributes.get("@color") map { _.as[String]}
  lazy val halign = attributes.get("@halign") map { _.as[Leftu45centeru45right]}
  lazy val valign = attributes.get("@valign") map { _.as[Valign]}
  lazy val underline = attributes.get("@underline") map { _.as[BigInt]}
  lazy val overline = attributes.get("@overline") map { _.as[BigInt]}
  lazy val lineu45through = attributes.get("@line-through") map { _.as[BigInt]}
  lazy val rotation = attributes.get("@rotation") map { _.as[BigDecimal]}
  lazy val letteru45spacing = attributes.get("@letter-spacing") map { _.as[String]}
  lazy val lineu45height = attributes.get("@line-height") map { _.as[String]}
  lazy val xmllang = attributes.get("@{http://www.w3.org/XML/1998/namespace}lang") map { _.as[String]}
  lazy val xmlspace = attributes.get("@{http://www.w3.org/XML/1998/namespace}space") map { _.as[String]}
  lazy val dir = attributes.get("@dir") map { _.as[Textu45direction]}
  lazy val enclosure = attributes.get("@enclosure") map { _.as[Enclosureu45shape]}
  lazy val smufl = attributes.get("@smufl") map { _.as[String]}
}

      
      


/** The coda type is the visual indicator of a coda sign. The exact glyph can be specified with the smufl attribute. A sound element is also needed to guide playback applications reliably.
*/
case class Coda(attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Directionu45typeOption {
  lazy val defaultu45x = attributes.get("@default-x") map { _.as[BigDecimal]}
  lazy val defaultu45y = attributes.get("@default-y") map { _.as[BigDecimal]}
  lazy val relativeu45x = attributes.get("@relative-x") map { _.as[BigDecimal]}
  lazy val relativeu45y = attributes.get("@relative-y") map { _.as[BigDecimal]}
  lazy val fontu45family = attributes.get("@font-family") map { _.as[String]}
  lazy val fontu45style = attributes.get("@font-style") map { _.as[Fontu45style]}
  lazy val fontu45size = attributes.get("@font-size") map { _.as[String]}
  lazy val fontu45weight = attributes.get("@font-weight") map { _.as[Fontu45weight]}
  lazy val color = attributes.get("@color") map { _.as[String]}
  lazy val halign = attributes.get("@halign") map { _.as[Leftu45centeru45right]}
  lazy val valign = attributes.get("@valign") map { _.as[Valign]}
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val smufl = attributes.get("@smufl") map { _.as[String]}
}

      
      


/** Dynamics can be associated either with a note or a general musical direction. To avoid inconsistencies between and amongst the letter abbreviations for dynamics (what is sf vs. sfz, standing alone or with a trailing dynamic that is not always piano), we use the actual letters as the names of these dynamic elements. The other-dynamics element allows other dynamic marks that are not covered here, but many of those should perhaps be included in a more general musical direction element. Dynamics elements may also be combined to create marks not covered by a single element, such as sfmp.

These letter dynamic symbols are separated from crescendo, decrescendo, and wedge indications. Dynamic representation is inconsistent in scores. Many things are assumed by the composer and left out, such as returns to original dynamics. Systematic representations are quite complex: for example, Humdrum has at least 3 representation formats related to dynamics. The MusicXML format captures what is in the score, but does not try to be optimal for analysis or synthesis of dynamics.
*/
case class Dynamics(dynamicsoption: Seq[scalaxb.DataRecord[musicxml.DynamicsOption]] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Directionu45typeOption with NotationsOption {
  lazy val defaultu45x = attributes.get("@default-x") map { _.as[BigDecimal]}
  lazy val defaultu45y = attributes.get("@default-y") map { _.as[BigDecimal]}
  lazy val relativeu45x = attributes.get("@relative-x") map { _.as[BigDecimal]}
  lazy val relativeu45y = attributes.get("@relative-y") map { _.as[BigDecimal]}
  lazy val fontu45family = attributes.get("@font-family") map { _.as[String]}
  lazy val fontu45style = attributes.get("@font-style") map { _.as[Fontu45style]}
  lazy val fontu45size = attributes.get("@font-size") map { _.as[String]}
  lazy val fontu45weight = attributes.get("@font-weight") map { _.as[Fontu45weight]}
  lazy val color = attributes.get("@color") map { _.as[String]}
  lazy val halign = attributes.get("@halign") map { _.as[Leftu45centeru45right]}
  lazy val valign = attributes.get("@valign") map { _.as[Valign]}
  lazy val placement = attributes.get("@placement") map { _.as[Aboveu45below]}
  lazy val underline = attributes.get("@underline") map { _.as[BigInt]}
  lazy val overline = attributes.get("@overline") map { _.as[BigInt]}
  lazy val lineu45through = attributes.get("@line-through") map { _.as[BigInt]}
  lazy val enclosure = attributes.get("@enclosure") map { _.as[Enclosureu45shape]}
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      
      

trait DynamicsOption

/** The empty type represents an empty element with no attributes.
*/
case class Empty() extends DynamicsOption with PercussionTypeOption with BendOption with HarmonicOption with HarmonicOption2 with LyricOption with Scoreu45instrumentOption
      
      


/** The empty-placement type represents an empty element with print-style and placement attributes.
*/
trait Emptyu45placementable extends ArticulationsOption with OrnamentsOption with TechnicalOption {
  def defaultu45x: Option[BigDecimal]
  def defaultu45y: Option[BigDecimal]
  def relativeu45x: Option[BigDecimal]
  def relativeu45y: Option[BigDecimal]
  def fontu45family: Option[String]
  def fontu45style: Option[musicxml.Fontu45style]
  def fontu45size: Option[String]
  def fontu45weight: Option[musicxml.Fontu45weight]
  def color: Option[String]
  def placement: Option[musicxml.Aboveu45below]
}


/** The empty-placement type represents an empty element with print-style and placement attributes.
*/
case class Emptyu45placement(attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Emptyu45placementable {
  lazy val defaultu45x = attributes.get("@default-x") map { _.as[BigDecimal]}
  lazy val defaultu45y = attributes.get("@default-y") map { _.as[BigDecimal]}
  lazy val relativeu45x = attributes.get("@relative-x") map { _.as[BigDecimal]}
  lazy val relativeu45y = attributes.get("@relative-y") map { _.as[BigDecimal]}
  lazy val fontu45family = attributes.get("@font-family") map { _.as[String]}
  lazy val fontu45style = attributes.get("@font-style") map { _.as[Fontu45style]}
  lazy val fontu45size = attributes.get("@font-size") map { _.as[String]}
  lazy val fontu45weight = attributes.get("@font-weight") map { _.as[Fontu45weight]}
  lazy val color = attributes.get("@color") map { _.as[String]}
  lazy val placement = attributes.get("@placement") map { _.as[Aboveu45below]}
}

      
      


/** The empty-placement-smufl type represents an empty element with print-style, placement, and smufl attributes.
*/
case class Emptyu45placementu45smufl(attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends TechnicalOption {
  lazy val defaultu45x = attributes.get("@default-x") map { _.as[BigDecimal]}
  lazy val defaultu45y = attributes.get("@default-y") map { _.as[BigDecimal]}
  lazy val relativeu45x = attributes.get("@relative-x") map { _.as[BigDecimal]}
  lazy val relativeu45y = attributes.get("@relative-y") map { _.as[BigDecimal]}
  lazy val fontu45family = attributes.get("@font-family") map { _.as[String]}
  lazy val fontu45style = attributes.get("@font-style") map { _.as[Fontu45style]}
  lazy val fontu45size = attributes.get("@font-size") map { _.as[String]}
  lazy val fontu45weight = attributes.get("@font-weight") map { _.as[Fontu45weight]}
  lazy val color = attributes.get("@color") map { _.as[String]}
  lazy val placement = attributes.get("@placement") map { _.as[Aboveu45below]}
  lazy val smufl = attributes.get("@smufl") map { _.as[String]}
}

      
      


/** The empty-print-style type represents an empty element with print-style attribute group.
*/
case class Emptyu45printu45style(attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val defaultu45x = attributes.get("@default-x") map { _.as[BigDecimal]}
  lazy val defaultu45y = attributes.get("@default-y") map { _.as[BigDecimal]}
  lazy val relativeu45x = attributes.get("@relative-x") map { _.as[BigDecimal]}
  lazy val relativeu45y = attributes.get("@relative-y") map { _.as[BigDecimal]}
  lazy val fontu45family = attributes.get("@font-family") map { _.as[String]}
  lazy val fontu45style = attributes.get("@font-style") map { _.as[Fontu45style]}
  lazy val fontu45size = attributes.get("@font-size") map { _.as[String]}
  lazy val fontu45weight = attributes.get("@font-weight") map { _.as[Fontu45weight]}
  lazy val color = attributes.get("@color") map { _.as[String]}
}

      
      


/** The empty-print-style-align type represents an empty element with print-style-align attribute group.
*/
case class Emptyu45printu45styleu45align(attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val defaultu45x = attributes.get("@default-x") map { _.as[BigDecimal]}
  lazy val defaultu45y = attributes.get("@default-y") map { _.as[BigDecimal]}
  lazy val relativeu45x = attributes.get("@relative-x") map { _.as[BigDecimal]}
  lazy val relativeu45y = attributes.get("@relative-y") map { _.as[BigDecimal]}
  lazy val fontu45family = attributes.get("@font-family") map { _.as[String]}
  lazy val fontu45style = attributes.get("@font-style") map { _.as[Fontu45style]}
  lazy val fontu45size = attributes.get("@font-size") map { _.as[String]}
  lazy val fontu45weight = attributes.get("@font-weight") map { _.as[Fontu45weight]}
  lazy val color = attributes.get("@color") map { _.as[String]}
  lazy val halign = attributes.get("@halign") map { _.as[Leftu45centeru45right]}
  lazy val valign = attributes.get("@valign") map { _.as[Valign]}
}

      
      


/** The empty-print-style-align-id type represents an empty element with print-style-align and optional-unique-id attribute groups.
*/
case class Emptyu45printu45styleu45alignu45id(attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Directionu45typeOption {
  lazy val defaultu45x = attributes.get("@default-x") map { _.as[BigDecimal]}
  lazy val defaultu45y = attributes.get("@default-y") map { _.as[BigDecimal]}
  lazy val relativeu45x = attributes.get("@relative-x") map { _.as[BigDecimal]}
  lazy val relativeu45y = attributes.get("@relative-y") map { _.as[BigDecimal]}
  lazy val fontu45family = attributes.get("@font-family") map { _.as[String]}
  lazy val fontu45style = attributes.get("@font-style") map { _.as[Fontu45style]}
  lazy val fontu45size = attributes.get("@font-size") map { _.as[String]}
  lazy val fontu45weight = attributes.get("@font-weight") map { _.as[Fontu45weight]}
  lazy val color = attributes.get("@color") map { _.as[String]}
  lazy val halign = attributes.get("@halign") map { _.as[Leftu45centeru45right]}
  lazy val valign = attributes.get("@valign") map { _.as[Valign]}
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      
      


/** The empty-print-style-align-object type represents an empty element with print-object and print-style-align attribute groups.
*/
case class Emptyu45printu45objectu45styleu45align(attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val printu45object = attributes.get("@print-object") map { _.as[Yesu45no]}
  lazy val defaultu45x = attributes.get("@default-x") map { _.as[BigDecimal]}
  lazy val defaultu45y = attributes.get("@default-y") map { _.as[BigDecimal]}
  lazy val relativeu45x = attributes.get("@relative-x") map { _.as[BigDecimal]}
  lazy val relativeu45y = attributes.get("@relative-y") map { _.as[BigDecimal]}
  lazy val fontu45family = attributes.get("@font-family") map { _.as[String]}
  lazy val fontu45style = attributes.get("@font-style") map { _.as[Fontu45style]}
  lazy val fontu45size = attributes.get("@font-size") map { _.as[String]}
  lazy val fontu45weight = attributes.get("@font-weight") map { _.as[Fontu45weight]}
  lazy val color = attributes.get("@color") map { _.as[String]}
  lazy val halign = attributes.get("@halign") map { _.as[Leftu45centeru45right]}
  lazy val valign = attributes.get("@valign") map { _.as[Valign]}
}

      
      


/** The empty-trill-sound type represents an empty element with print-style, placement, and trill-sound attributes.
*/
trait Emptyu45trillu45soundable extends OrnamentsOption {
  def defaultu45x: Option[BigDecimal]
  def defaultu45y: Option[BigDecimal]
  def relativeu45x: Option[BigDecimal]
  def relativeu45y: Option[BigDecimal]
  def fontu45family: Option[String]
  def fontu45style: Option[musicxml.Fontu45style]
  def fontu45size: Option[String]
  def fontu45weight: Option[musicxml.Fontu45weight]
  def color: Option[String]
  def placement: Option[musicxml.Aboveu45below]
  def startu45note: Option[musicxml.Startu45note]
  def trillu45step: Option[musicxml.Trillu45step]
  def twou45noteu45turn: Option[musicxml.Twou45noteu45turn]
  def accelerate: Option[musicxml.Yesu45no]
  def beats: Option[BigDecimal]
  def secondu45beat: Option[BigDecimal]
  def lastu45beat: Option[BigDecimal]
}


/** The empty-trill-sound type represents an empty element with print-style, placement, and trill-sound attributes.
*/
case class Emptyu45trillu45sound(attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Emptyu45trillu45soundable {
  lazy val defaultu45x = attributes.get("@default-x") map { _.as[BigDecimal]}
  lazy val defaultu45y = attributes.get("@default-y") map { _.as[BigDecimal]}
  lazy val relativeu45x = attributes.get("@relative-x") map { _.as[BigDecimal]}
  lazy val relativeu45y = attributes.get("@relative-y") map { _.as[BigDecimal]}
  lazy val fontu45family = attributes.get("@font-family") map { _.as[String]}
  lazy val fontu45style = attributes.get("@font-style") map { _.as[Fontu45style]}
  lazy val fontu45size = attributes.get("@font-size") map { _.as[String]}
  lazy val fontu45weight = attributes.get("@font-weight") map { _.as[Fontu45weight]}
  lazy val color = attributes.get("@color") map { _.as[String]}
  lazy val placement = attributes.get("@placement") map { _.as[Aboveu45below]}
  lazy val startu45note = attributes.get("@start-note") map { _.as[Startu45note]}
  lazy val trillu45step = attributes.get("@trill-step") map { _.as[Trillu45step]}
  lazy val twou45noteu45turn = attributes.get("@two-note-turn") map { _.as[Twou45noteu45turn]}
  lazy val accelerate = attributes.get("@accelerate") map { _.as[Yesu45no]}
  lazy val beats = attributes.get("@beats") map { _.as[BigDecimal]}
  lazy val secondu45beat = attributes.get("@second-beat") map { _.as[BigDecimal]}
  lazy val lastu45beat = attributes.get("@last-beat") map { _.as[BigDecimal]}
}

      
      


/** The horizontal-turn type represents turn elements that are horizontal rather than vertical. These are empty elements with print-style, placement, trill-sound, and slash attributes. If the slash attribute is yes, then a vertical line is used to slash the turn; it is no by default.
*/
case class Horizontalu45turn(attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends OrnamentsOption {
  lazy val defaultu45x = attributes.get("@default-x") map { _.as[BigDecimal]}
  lazy val defaultu45y = attributes.get("@default-y") map { _.as[BigDecimal]}
  lazy val relativeu45x = attributes.get("@relative-x") map { _.as[BigDecimal]}
  lazy val relativeu45y = attributes.get("@relative-y") map { _.as[BigDecimal]}
  lazy val fontu45family = attributes.get("@font-family") map { _.as[String]}
  lazy val fontu45style = attributes.get("@font-style") map { _.as[Fontu45style]}
  lazy val fontu45size = attributes.get("@font-size") map { _.as[String]}
  lazy val fontu45weight = attributes.get("@font-weight") map { _.as[Fontu45weight]}
  lazy val color = attributes.get("@color") map { _.as[String]}
  lazy val placement = attributes.get("@placement") map { _.as[Aboveu45below]}
  lazy val startu45note = attributes.get("@start-note") map { _.as[Startu45note]}
  lazy val trillu45step = attributes.get("@trill-step") map { _.as[Trillu45step]}
  lazy val twou45noteu45turn = attributes.get("@two-note-turn") map { _.as[Twou45noteu45turn]}
  lazy val accelerate = attributes.get("@accelerate") map { _.as[Yesu45no]}
  lazy val beats = attributes.get("@beats") map { _.as[BigDecimal]}
  lazy val secondu45beat = attributes.get("@second-beat") map { _.as[BigDecimal]}
  lazy val lastu45beat = attributes.get("@last-beat") map { _.as[BigDecimal]}
  lazy val slash = attributes.get("@slash") map { _.as[Yesu45no]}
}

      
      


/** The fermata text content represents the shape of the fermata sign. An empty fermata element represents a normal fermata. The fermata type is upright if not specified.
*/
case class Fermata(value: musicxml.Fermatau45shape,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends NotationsOption {
  lazy val typeValue = attributes.get("@type") map { _.as[Uprightu45inverted]}
  lazy val defaultu45x = attributes.get("@default-x") map { _.as[BigDecimal]}
  lazy val defaultu45y = attributes.get("@default-y") map { _.as[BigDecimal]}
  lazy val relativeu45x = attributes.get("@relative-x") map { _.as[BigDecimal]}
  lazy val relativeu45y = attributes.get("@relative-y") map { _.as[BigDecimal]}
  lazy val fontu45family = attributes.get("@font-family") map { _.as[String]}
  lazy val fontu45style = attributes.get("@font-style") map { _.as[Fontu45style]}
  lazy val fontu45size = attributes.get("@font-size") map { _.as[String]}
  lazy val fontu45weight = attributes.get("@font-weight") map { _.as[Fontu45weight]}
  lazy val color = attributes.get("@color") map { _.as[String]}
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      
      


/** Fingering is typically indicated 1,2,3,4,5. Multiple fingerings may be given, typically to substitute fingerings in the middle of a note. The substitution and alternate values are "no" if the attribute is not present. For guitar and other fretted instruments, the fingering element represents the fretting finger; the pluck element represents the plucking finger.
*/
case class Fingering(value: String,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends TechnicalOption {
  lazy val substitution = attributes.get("@substitution") map { _.as[Yesu45no]}
  lazy val alternate = attributes.get("@alternate") map { _.as[Yesu45no]}
  lazy val defaultu45x = attributes.get("@default-x") map { _.as[BigDecimal]}
  lazy val defaultu45y = attributes.get("@default-y") map { _.as[BigDecimal]}
  lazy val relativeu45x = attributes.get("@relative-x") map { _.as[BigDecimal]}
  lazy val relativeu45y = attributes.get("@relative-y") map { _.as[BigDecimal]}
  lazy val fontu45family = attributes.get("@font-family") map { _.as[String]}
  lazy val fontu45style = attributes.get("@font-style") map { _.as[Fontu45style]}
  lazy val fontu45size = attributes.get("@font-size") map { _.as[String]}
  lazy val fontu45weight = attributes.get("@font-weight") map { _.as[Fontu45weight]}
  lazy val color = attributes.get("@color") map { _.as[String]}
  lazy val placement = attributes.get("@placement") map { _.as[Aboveu45below]}
}

      
      


/** The formatted-symbol type represents a SMuFL musical symbol element with formatting attributes.
*/
case class Formattedu45symbol(value: String,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val justify = attributes.get("@justify") map { _.as[Leftu45centeru45right]}
  lazy val defaultu45x = attributes.get("@default-x") map { _.as[BigDecimal]}
  lazy val defaultu45y = attributes.get("@default-y") map { _.as[BigDecimal]}
  lazy val relativeu45x = attributes.get("@relative-x") map { _.as[BigDecimal]}
  lazy val relativeu45y = attributes.get("@relative-y") map { _.as[BigDecimal]}
  lazy val fontu45family = attributes.get("@font-family") map { _.as[String]}
  lazy val fontu45style = attributes.get("@font-style") map { _.as[Fontu45style]}
  lazy val fontu45size = attributes.get("@font-size") map { _.as[String]}
  lazy val fontu45weight = attributes.get("@font-weight") map { _.as[Fontu45weight]}
  lazy val color = attributes.get("@color") map { _.as[String]}
  lazy val halign = attributes.get("@halign") map { _.as[Leftu45centeru45right]}
  lazy val valign = attributes.get("@valign") map { _.as[Valign]}
  lazy val underline = attributes.get("@underline") map { _.as[BigInt]}
  lazy val overline = attributes.get("@overline") map { _.as[BigInt]}
  lazy val lineu45through = attributes.get("@line-through") map { _.as[BigInt]}
  lazy val rotation = attributes.get("@rotation") map { _.as[BigDecimal]}
  lazy val letteru45spacing = attributes.get("@letter-spacing") map { _.as[String]}
  lazy val lineu45height = attributes.get("@line-height") map { _.as[String]}
  lazy val dir = attributes.get("@dir") map { _.as[Textu45direction]}
  lazy val enclosure = attributes.get("@enclosure") map { _.as[Enclosureu45shape]}
}

      
      


/** The formatted-symbol-id type represents a SMuFL musical symbol element with formatting and id attributes.
*/
case class Formattedu45symbolu45id(value: String,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Directionu45typeOption2 with CreditOption2 with CreditOption3 {
  lazy val justify = attributes.get("@justify") map { _.as[Leftu45centeru45right]}
  lazy val defaultu45x = attributes.get("@default-x") map { _.as[BigDecimal]}
  lazy val defaultu45y = attributes.get("@default-y") map { _.as[BigDecimal]}
  lazy val relativeu45x = attributes.get("@relative-x") map { _.as[BigDecimal]}
  lazy val relativeu45y = attributes.get("@relative-y") map { _.as[BigDecimal]}
  lazy val fontu45family = attributes.get("@font-family") map { _.as[String]}
  lazy val fontu45style = attributes.get("@font-style") map { _.as[Fontu45style]}
  lazy val fontu45size = attributes.get("@font-size") map { _.as[String]}
  lazy val fontu45weight = attributes.get("@font-weight") map { _.as[Fontu45weight]}
  lazy val color = attributes.get("@color") map { _.as[String]}
  lazy val halign = attributes.get("@halign") map { _.as[Leftu45centeru45right]}
  lazy val valign = attributes.get("@valign") map { _.as[Valign]}
  lazy val underline = attributes.get("@underline") map { _.as[BigInt]}
  lazy val overline = attributes.get("@overline") map { _.as[BigInt]}
  lazy val lineu45through = attributes.get("@line-through") map { _.as[BigInt]}
  lazy val rotation = attributes.get("@rotation") map { _.as[BigDecimal]}
  lazy val letteru45spacing = attributes.get("@letter-spacing") map { _.as[String]}
  lazy val lineu45height = attributes.get("@line-height") map { _.as[String]}
  lazy val dir = attributes.get("@dir") map { _.as[Textu45direction]}
  lazy val enclosure = attributes.get("@enclosure") map { _.as[Enclosureu45shape]}
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      
      


/** The formatted-text type represents a text element with text-formatting attributes.
*/
case class Formattedu45text(value: String,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Nameu45displayOption with Noteheadu45textOption {
  lazy val justify = attributes.get("@justify") map { _.as[Leftu45centeru45right]}
  lazy val defaultu45x = attributes.get("@default-x") map { _.as[BigDecimal]}
  lazy val defaultu45y = attributes.get("@default-y") map { _.as[BigDecimal]}
  lazy val relativeu45x = attributes.get("@relative-x") map { _.as[BigDecimal]}
  lazy val relativeu45y = attributes.get("@relative-y") map { _.as[BigDecimal]}
  lazy val fontu45family = attributes.get("@font-family") map { _.as[String]}
  lazy val fontu45style = attributes.get("@font-style") map { _.as[Fontu45style]}
  lazy val fontu45size = attributes.get("@font-size") map { _.as[String]}
  lazy val fontu45weight = attributes.get("@font-weight") map { _.as[Fontu45weight]}
  lazy val color = attributes.get("@color") map { _.as[String]}
  lazy val halign = attributes.get("@halign") map { _.as[Leftu45centeru45right]}
  lazy val valign = attributes.get("@valign") map { _.as[Valign]}
  lazy val underline = attributes.get("@underline") map { _.as[BigInt]}
  lazy val overline = attributes.get("@overline") map { _.as[BigInt]}
  lazy val lineu45through = attributes.get("@line-through") map { _.as[BigInt]}
  lazy val rotation = attributes.get("@rotation") map { _.as[BigDecimal]}
  lazy val letteru45spacing = attributes.get("@letter-spacing") map { _.as[String]}
  lazy val lineu45height = attributes.get("@line-height") map { _.as[String]}
  lazy val xmllang = attributes.get("@{http://www.w3.org/XML/1998/namespace}lang") map { _.as[String]}
  lazy val xmlspace = attributes.get("@{http://www.w3.org/XML/1998/namespace}space") map { _.as[String]}
  lazy val dir = attributes.get("@dir") map { _.as[Textu45direction]}
  lazy val enclosure = attributes.get("@enclosure") map { _.as[Enclosureu45shape]}
}

      
      


/** The formatted-text-id type represents a text element with text-formatting and id attributes.
*/
case class Formattedu45textu45id(value: String,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Directionu45typeOption2 with Directionu45typeOption with CreditOption2 with CreditOption3 {
  lazy val justify = attributes.get("@justify") map { _.as[Leftu45centeru45right]}
  lazy val defaultu45x = attributes.get("@default-x") map { _.as[BigDecimal]}
  lazy val defaultu45y = attributes.get("@default-y") map { _.as[BigDecimal]}
  lazy val relativeu45x = attributes.get("@relative-x") map { _.as[BigDecimal]}
  lazy val relativeu45y = attributes.get("@relative-y") map { _.as[BigDecimal]}
  lazy val fontu45family = attributes.get("@font-family") map { _.as[String]}
  lazy val fontu45style = attributes.get("@font-style") map { _.as[Fontu45style]}
  lazy val fontu45size = attributes.get("@font-size") map { _.as[String]}
  lazy val fontu45weight = attributes.get("@font-weight") map { _.as[Fontu45weight]}
  lazy val color = attributes.get("@color") map { _.as[String]}
  lazy val halign = attributes.get("@halign") map { _.as[Leftu45centeru45right]}
  lazy val valign = attributes.get("@valign") map { _.as[Valign]}
  lazy val underline = attributes.get("@underline") map { _.as[BigInt]}
  lazy val overline = attributes.get("@overline") map { _.as[BigInt]}
  lazy val lineu45through = attributes.get("@line-through") map { _.as[BigInt]}
  lazy val rotation = attributes.get("@rotation") map { _.as[BigDecimal]}
  lazy val letteru45spacing = attributes.get("@letter-spacing") map { _.as[String]}
  lazy val lineu45height = attributes.get("@line-height") map { _.as[String]}
  lazy val xmllang = attributes.get("@{http://www.w3.org/XML/1998/namespace}lang") map { _.as[String]}
  lazy val xmlspace = attributes.get("@{http://www.w3.org/XML/1998/namespace}space") map { _.as[String]}
  lazy val dir = attributes.get("@dir") map { _.as[Textu45direction]}
  lazy val enclosure = attributes.get("@enclosure") map { _.as[Enclosureu45shape]}
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      
      


/** The fret element is used with tablature notation and chord diagrams. Fret numbers start with 0 for an open string and 1 for the first fret.
*/
case class Fret(value: BigInt,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends TechnicalOption {
  lazy val fontu45family = attributes.get("@font-family") map { _.as[String]}
  lazy val fontu45style = attributes.get("@font-style") map { _.as[Fontu45style]}
  lazy val fontu45size = attributes.get("@font-size") map { _.as[String]}
  lazy val fontu45weight = attributes.get("@font-weight") map { _.as[Fontu45weight]}
  lazy val color = attributes.get("@color") map { _.as[String]}
}

      
      


/** The level type is used to specify editorial information for different MusicXML elements. If the reference attribute for the level element is yes, this indicates editorial information that is for display only and should not affect playback. For instance, a modern edition of older music may set reference="yes" on the attributes containing the music's original clef, key, and time signature. It is no by default.
*/
case class Level(value: String,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val reference = attributes.get("@reference") map { _.as[Yesu45no]}
  lazy val parentheses = attributes.get("@parentheses") map { _.as[Yesu45no]}
  lazy val bracket = attributes.get("@bracket") map { _.as[Yesu45no]}
  lazy val size = attributes.get("@size") map { _.as[Symbolu45size]}
}

      
      


/** The midi-device type corresponds to the DeviceName meta event in Standard MIDI Files. The optional port attribute is a number from 1 to 16 that can be used with the unofficial MIDI port (or cable) meta event. Unlike the DeviceName meta event, there can be multiple midi-device elements per MusicXML part starting in MusicXML 3.0. The optional id attribute refers to the score-instrument assigned to this device. If missing, the device assignment affects all score-instrument elements in the score-part.
*/
case class Midiu45device(value: String,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val port = attributes.get("@port") map { _.as[BigInt]}
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      
      


/** The midi-instrument type defines MIDI 1.0 instrument playback. The midi-instrument element can be a part of either the score-instrument element at the start of a part, or the sound element within a part. The id attribute refers to the score-instrument affected by the change.
*/
case class Midiu45instrument(midiu45channel: Option[BigInt] = None,
  midiu45name: Option[String] = None,
  midiu45bank: Option[BigInt] = None,
  midiu45program: Option[BigInt] = None,
  midiu45unpitched: Option[BigInt] = None,
  volume: Option[BigDecimal] = None,
  pan: Option[BigDecimal] = None,
  elevation: Option[BigDecimal] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val id = attributes("@id").as[String]
}

      
      


/** The name-display type is used for exact formatting of multi-font text in part and group names to the left of the system. The print-object attribute can be used to determine what, if anything, is printed at the start of each system. Enclosure for the display-text element is none by default. Language for the display-text element is Italian ("it") by default.
*/
case class Nameu45display(nameu45displayoption: Seq[scalaxb.DataRecord[musicxml.Nameu45displayOption]] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val printu45object = attributes.get("@print-object") map { _.as[Yesu45no]}
}

      
      

trait Nameu45displayOption

/** The other-play element represents other types of playback. The required type attribute indicates the type of playback to which the element content applies.
*/
case class Otheru45play(value: String,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val typeValue = attributes("@type").as[String]
}

      
      


/** The play type, new in Version 3.0, specifies playback techniques to be used in conjunction with the instrument-sound element. When used as part of a sound element, it applies to all notes going forward in score order. In multi-instrument parts, the affected instrument should be specified using the id attribute. When used as part of a note element, it applies to the current note only.
*/
case class Play(playoption: Seq[scalaxb.DataRecord[Any]] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      
      

trait PlayOption

/** The segno type is the visual indicator of a segno sign. The exact glyph can be specified with the smufl attribute. A sound element is also needed to guide playback applications reliably.
*/
case class Segno(attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Directionu45typeOption {
  lazy val defaultu45x = attributes.get("@default-x") map { _.as[BigDecimal]}
  lazy val defaultu45y = attributes.get("@default-y") map { _.as[BigDecimal]}
  lazy val relativeu45x = attributes.get("@relative-x") map { _.as[BigDecimal]}
  lazy val relativeu45y = attributes.get("@relative-y") map { _.as[BigDecimal]}
  lazy val fontu45family = attributes.get("@font-family") map { _.as[String]}
  lazy val fontu45style = attributes.get("@font-style") map { _.as[Fontu45style]}
  lazy val fontu45size = attributes.get("@font-size") map { _.as[String]}
  lazy val fontu45weight = attributes.get("@font-weight") map { _.as[Fontu45weight]}
  lazy val color = attributes.get("@color") map { _.as[String]}
  lazy val halign = attributes.get("@halign") map { _.as[Leftu45centeru45right]}
  lazy val valign = attributes.get("@valign") map { _.as[Valign]}
  lazy val id = attributes.get("@id") map { _.as[String]}
  lazy val smufl = attributes.get("@smufl") map { _.as[String]}
}

      
      


/** The string type is used with tablature notation, regular notation (where it is often circled), and chord diagrams. String numbers start with 1 for the highest pitched full-length string.
*/
case class StringType(value: BigInt,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends TechnicalOption {
  lazy val defaultu45x = attributes.get("@default-x") map { _.as[BigDecimal]}
  lazy val defaultu45y = attributes.get("@default-y") map { _.as[BigDecimal]}
  lazy val relativeu45x = attributes.get("@relative-x") map { _.as[BigDecimal]}
  lazy val relativeu45y = attributes.get("@relative-y") map { _.as[BigDecimal]}
  lazy val fontu45family = attributes.get("@font-family") map { _.as[String]}
  lazy val fontu45style = attributes.get("@font-style") map { _.as[Fontu45style]}
  lazy val fontu45size = attributes.get("@font-size") map { _.as[String]}
  lazy val fontu45weight = attributes.get("@font-weight") map { _.as[Fontu45weight]}
  lazy val color = attributes.get("@color") map { _.as[String]}
  lazy val placement = attributes.get("@placement") map { _.as[Aboveu45below]}
}

      
      


/** The typed-text type represents a text element with a type attributes.
*/
case class Typedu45text(value: String,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val typeValue = attributes.get("@type") map { _.as[String]}
}

      
      


/** Wavy lines are one way to indicate trills. When used with a barline element, they should always have type="continue" set.
*/
case class Wavyu45line(attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends OrnamentsOption {
  lazy val typeValue = attributes("@type").as[Startu45stopu45continue]
  lazy val number = attributes.get("@number") map { _.as[BigInt]}
  lazy val defaultu45x = attributes.get("@default-x") map { _.as[BigDecimal]}
  lazy val defaultu45y = attributes.get("@default-y") map { _.as[BigDecimal]}
  lazy val relativeu45x = attributes.get("@relative-x") map { _.as[BigDecimal]}
  lazy val relativeu45y = attributes.get("@relative-y") map { _.as[BigDecimal]}
  lazy val placement = attributes.get("@placement") map { _.as[Aboveu45below]}
  lazy val color = attributes.get("@color") map { _.as[String]}
  lazy val startu45note = attributes.get("@start-note") map { _.as[Startu45note]}
  lazy val trillu45step = attributes.get("@trill-step") map { _.as[Trillu45step]}
  lazy val twou45noteu45turn = attributes.get("@two-note-turn") map { _.as[Twou45noteu45turn]}
  lazy val accelerate = attributes.get("@accelerate") map { _.as[Yesu45no]}
  lazy val beats = attributes.get("@beats") map { _.as[BigDecimal]}
  lazy val secondu45beat = attributes.get("@second-beat") map { _.as[BigDecimal]}
  lazy val lastu45beat = attributes.get("@last-beat") map { _.as[BigDecimal]}
}

      
      


case class Directive(value: String,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val defaultu45x = attributes.get("@default-x") map { _.as[BigDecimal]}
  lazy val defaultu45y = attributes.get("@default-y") map { _.as[BigDecimal]}
  lazy val relativeu45x = attributes.get("@relative-x") map { _.as[BigDecimal]}
  lazy val relativeu45y = attributes.get("@relative-y") map { _.as[BigDecimal]}
  lazy val fontu45family = attributes.get("@font-family") map { _.as[String]}
  lazy val fontu45style = attributes.get("@font-style") map { _.as[Fontu45style]}
  lazy val fontu45size = attributes.get("@font-size") map { _.as[String]}
  lazy val fontu45weight = attributes.get("@font-weight") map { _.as[Fontu45weight]}
  lazy val color = attributes.get("@color") map { _.as[String]}
  lazy val xmllang = attributes.get("@{http://www.w3.org/XML/1998/namespace}lang") map { _.as[String]}
}

      
      


/** The attributes element contains musical information that typically changes on measure boundaries. This includes key and time signatures, clefs, transpositions, and staving. When attributes are changed mid-measure, it affects the music in score order, not in MusicXML document order.
*/
case class AttributesType(editorialSequence1: musicxml.EditorialSequence,
  divisions: Option[BigDecimal] = None,
  key: Seq[musicxml.Key] = Nil,
  time: Seq[musicxml.Time] = Nil,
  staves: Option[BigInt] = None,
  partu45symbol: Option[musicxml.Partu45symbol] = None,
  instruments: Option[BigInt] = None,
  clef: Seq[musicxml.Clef] = Nil,
  staffu45details: Seq[musicxml.Staffu45details] = Nil,
  transpose: Seq[musicxml.Transpose] = Nil,
  directive: Seq[musicxml.Directive] = Nil,
  measureu45style: Seq[musicxml.Measureu45style] = Nil) extends Musicu45dataOption1
      
      


/** The beat-repeat type is used to indicate that a single beat (but possibly many notes) is repeated. Both the start and stop of the beat being repeated should be specified. The slashes attribute specifies the number of slashes to use in the symbol. The use-dots attribute indicates whether or not to use dots as well (for instance, with mixed rhythm patterns). By default, the value for slashes is 1 and the value for use-dots is no.

The beat-repeat element specifies a notation style for repetitions. The actual music being repeated needs to be repeated within the MusicXML file. This element specifies the notation that indicates the repeat.
*/
case class Beatu45repeat(slashSequence1: Option[musicxml.SlashSequence] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Measureu45styleOption {
  lazy val typeValue = attributes("@type").as[Startu45stop]
  lazy val slashes = attributes.get("@slashes") map { _.as[BigInt]}
  lazy val useu45dots = attributes.get("@use-dots") map { _.as[Yesu45no]}
}

      
      


/** A cancel element indicates that the old key signature should be cancelled before the new one appears. This will always happen when changing to C major or A minor and need not be specified then. The cancel value matches the fifths value of the cancelled key signature (e.g., a cancel of -2 will provide an explicit cancellation for changing from B flat major to F major). The optional location attribute indicates where the cancellation appears relative to the new key signature.
*/
case class Cancel(value: BigInt,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val location = attributes.get("@location") map { _.as[Cancelu45location]}
}

      
      


/** Clefs are represented by a combination of sign, line, and clef-octave-change elements. The optional number attribute refers to staff numbers within the part. A value of 1 is assumed if not present.

Sometimes clefs are added to the staff in non-standard line positions, either to indicate cue passages, or when there are multiple clefs present simultaneously on one staff. In this situation, the additional attribute is set to "yes" and the line value is ignored. The size attribute is used for clefs where the additional attribute is "yes". It is typically used to indicate cue clefs.

Sometimes clefs at the start of a measure need to appear after the barline rather than before, as for cues or for use after a repeated section. The after-barline attribute is set to "yes" in this situation. The attribute is ignored for mid-measure clefs.

Clefs appear at the start of each system unless the print-object attribute has been set to "no" or the additional attribute has been set to "yes".
*/
case class Clef(sign: musicxml.Clefu45sign,
  line: Option[BigInt] = None,
  clefu45octaveu45change: Option[BigInt] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val number = attributes.get("@number") map { _.as[BigInt]}
  lazy val additional = attributes.get("@additional") map { _.as[Yesu45no]}
  lazy val size = attributes.get("@size") map { _.as[Symbolu45size]}
  lazy val afteru45barline = attributes.get("@after-barline") map { _.as[Yesu45no]}
  lazy val defaultu45x = attributes.get("@default-x") map { _.as[BigDecimal]}
  lazy val defaultu45y = attributes.get("@default-y") map { _.as[BigDecimal]}
  lazy val relativeu45x = attributes.get("@relative-x") map { _.as[BigDecimal]}
  lazy val relativeu45y = attributes.get("@relative-y") map { _.as[BigDecimal]}
  lazy val fontu45family = attributes.get("@font-family") map { _.as[String]}
  lazy val fontu45style = attributes.get("@font-style") map { _.as[Fontu45style]}
  lazy val fontu45size = attributes.get("@font-size") map { _.as[String]}
  lazy val fontu45weight = attributes.get("@font-weight") map { _.as[Fontu45weight]}
  lazy val color = attributes.get("@color") map { _.as[String]}
  lazy val printu45object = attributes.get("@print-object") map { _.as[Yesu45no]}
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      
      


/** The interchangeable type is used to represent the second in a pair of interchangeable dual time signatures, such as the 6/8 in 3/4 (6/8). A separate symbol attribute value is available compared to the time element's symbol attribute, which applies to the first of the dual time signatures.
*/
case class Interchangeable(timeu45relation: Option[musicxml.Timeu45relation] = None,
  timeu45signatureSequence2: Seq[musicxml.Timeu45signatureSequence] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val symbol = attributes.get("@symbol") map { _.as[Timeu45symbol]}
  lazy val separator = attributes.get("@separator") map { _.as[Timeu45separator]}
}

      
      


/** The key type represents a key signature. Both traditional and non-traditional key signatures are supported. The optional number attribute refers to staff numbers. If absent, the key signature applies to all staves in the part. Key signatures appear at the start of each system unless the print-object attribute has been set to "no".
*/
case class Key(keyoption: Seq[scalaxb.DataRecord[Any]] = Nil,
  keyu45octave: Seq[musicxml.Keyu45octave] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val number = attributes.get("@number") map { _.as[BigInt]}
  lazy val defaultu45x = attributes.get("@default-x") map { _.as[BigDecimal]}
  lazy val defaultu45y = attributes.get("@default-y") map { _.as[BigDecimal]}
  lazy val relativeu45x = attributes.get("@relative-x") map { _.as[BigDecimal]}
  lazy val relativeu45y = attributes.get("@relative-y") map { _.as[BigDecimal]}
  lazy val fontu45family = attributes.get("@font-family") map { _.as[String]}
  lazy val fontu45style = attributes.get("@font-style") map { _.as[Fontu45style]}
  lazy val fontu45size = attributes.get("@font-size") map { _.as[String]}
  lazy val fontu45weight = attributes.get("@font-weight") map { _.as[Fontu45weight]}
  lazy val color = attributes.get("@color") map { _.as[String]}
  lazy val printu45object = attributes.get("@print-object") map { _.as[Yesu45no]}
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      
      

trait KeyOption

/** The key-accidental type indicates the accidental to be displayed in a non-traditional key signature, represented in the same manner as the accidental type without the formatting attributes.
*/
case class Keyu45accidental(value: musicxml.Accidentalu45value,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val smufl = attributes.get("@smufl") map { _.as[String]}
}

      
      


/** The key-octave element specifies in which octave an element of a key signature appears. The content specifies the octave value using the same values as the display-octave element. The number attribute is a positive integer that refers to the key signature element in left-to-right order. If the cancel attribute is set to yes, then this number refers to the canceling key signature specified by the cancel element in the parent key element. The cancel attribute cannot be set to yes if there is no corresponding cancel element within the parent key element. It is no by default.
*/
case class Keyu45octave(value: BigInt,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val number = attributes("@number").as[BigInt]
  lazy val cancel = attributes.get("@cancel") map { _.as[Yesu45no]}
}

      
      


/** The measure-repeat type is used for both single and multiple measure repeats. The text of the element indicates the number of measures to be repeated in a single pattern. The slashes attribute specifies the number of slashes to use in the repeat sign. It is 1 if not specified. Both the start and the stop of the measure-repeat must be specified. The text of the element is ignored when the type is stop.

The measure-repeat element specifies a notation style for repetitions. The actual music being repeated needs to be repeated within the MusicXML file. This element specifies the notation that indicates the repeat.
*/
case class Measureu45repeat(value: String,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Measureu45styleOption {
  lazy val typeValue = attributes("@type").as[Startu45stop]
  lazy val slashes = attributes.get("@slashes") map { _.as[BigInt]}
}

      
      


/** A measure-style indicates a special way to print partial to multiple measures within a part. This includes multiple rests over several measures, repeats of beats, single, or multiple measures, and use of slash notation.

The multiple-rest and measure-repeat symbols indicate the number of measures covered in the element content. The beat-repeat and slash elements can cover partial measures. All but the multiple-rest element use a type attribute to indicate starting and stopping the use of the style. The optional number attribute specifies the staff number from top to bottom on the system, as with clef.
*/
case class Measureu45style(measureu45styleoption: scalaxb.DataRecord[musicxml.Measureu45styleOption],
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val number = attributes.get("@number") map { _.as[BigInt]}
  lazy val fontu45family = attributes.get("@font-family") map { _.as[String]}
  lazy val fontu45style = attributes.get("@font-style") map { _.as[Fontu45style]}
  lazy val fontu45size = attributes.get("@font-size") map { _.as[String]}
  lazy val fontu45weight = attributes.get("@font-weight") map { _.as[Fontu45weight]}
  lazy val color = attributes.get("@color") map { _.as[String]}
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      
      

trait Measureu45styleOption

/** The text of the multiple-rest type indicates the number of measures in the multiple rest. Multiple rests may use the 1-bar / 2-bar / 4-bar rest symbols, or a single shape. The use-symbols attribute indicates which to use; it is no if not specified.
*/
case class Multipleu45rest(value: String,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Measureu45styleOption {
  lazy val useu45symbols = attributes.get("@use-symbols") map { _.as[Yesu45no]}
}

      
      


/** The part-symbol type indicates how a symbol for a multi-staff part is indicated in the score; brace is the default value. The top-staff and bottom-staff elements are used when the brace does not extend across the entire part. For example, in a 3-staff organ part, the top-staff will typically be 1 for the right hand, while the bottom-staff will typically be 2 for the left hand. Staff 3 for the pedals is usually outside the brace.
*/
case class Partu45symbol(value: musicxml.Groupu45symbolu45value,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val topu45staff = attributes.get("@top-staff") map { _.as[BigInt]}
  lazy val bottomu45staff = attributes.get("@bottom-staff") map { _.as[BigInt]}
  lazy val defaultu45x = attributes.get("@default-x") map { _.as[BigDecimal]}
  lazy val defaultu45y = attributes.get("@default-y") map { _.as[BigDecimal]}
  lazy val relativeu45x = attributes.get("@relative-x") map { _.as[BigDecimal]}
  lazy val relativeu45y = attributes.get("@relative-y") map { _.as[BigDecimal]}
  lazy val color = attributes.get("@color") map { _.as[String]}
}

      
      


/** The slash type is used to indicate that slash notation is to be used. If the slash is on every beat, use-stems is no (the default). To indicate rhythms but not pitches, use-stems is set to yes. The type attribute indicates whether this is the start or stop of a slash notation style. The use-dots attribute works as for the beat-repeat element, and only has effect if use-stems is no.
*/
case class SlashType(slashSequence1: Option[musicxml.SlashSequence] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Measureu45styleOption {
  lazy val typeValue = attributes("@type").as[Startu45stop]
  lazy val useu45dots = attributes.get("@use-dots") map { _.as[Yesu45no]}
  lazy val useu45stems = attributes.get("@use-stems") map { _.as[Yesu45no]}
}

      
      


/** The staff-details element is used to indicate different types of staves. The optional number attribute specifies the staff number from top to bottom on the system, as with clef. The print-object attribute is used to indicate when a staff is not printed in a part, usually in large scores where empty parts are omitted. It is yes by default. If print-spacing is yes while print-object is no, the score is printed in cutaway format where vertical space is left for the empty part.
*/
case class Staffu45details(staffu45type: Option[musicxml.Staffu45type] = None,
  staffu45lines: Option[BigInt] = None,
  staffu45tuning: Seq[musicxml.Staffu45tuning] = Nil,
  capo: Option[BigInt] = None,
  staffu45size: Option[BigDecimal] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val number = attributes.get("@number") map { _.as[BigInt]}
  lazy val showu45frets = attributes.get("@show-frets") map { _.as[Showu45frets]}
  lazy val printu45object = attributes.get("@print-object") map { _.as[Yesu45no]}
  lazy val printu45spacing = attributes.get("@print-spacing") map { _.as[Yesu45no]}
}

      
      


/** The staff-tuning type specifies the open, non-capo tuning of the lines on a tablature staff.
*/
case class Staffu45tuning(tuningSequence1: musicxml.TuningSequence,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val line = attributes.get("@line") map { _.as[BigInt]}
}

      
      


/** Time signatures are represented by the beats element for the numerator and the beat-type element for the denominator. The symbol attribute is used indicate common and cut time symbols as well as a single number display. Multiple pairs of beat and beat-type elements are used for composite time signatures with multiple denominators, such as 2/4 + 3/8. A composite such as 3+2/8 requires only one beat/beat-type pair.

The print-object attribute allows a time signature to be specified but not printed, as is the case for excerpts from the middle of a score. The value is "yes" if not present. The optional number attribute refers to staff numbers within the part. If absent, the time signature applies to all staves in the part.
*/
case class Time(timeoption: scalaxb.DataRecord[Any],
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val number = attributes.get("@number") map { _.as[BigInt]}
  lazy val symbol = attributes.get("@symbol") map { _.as[Timeu45symbol]}
  lazy val separator = attributes.get("@separator") map { _.as[Timeu45separator]}
  lazy val defaultu45x = attributes.get("@default-x") map { _.as[BigDecimal]}
  lazy val defaultu45y = attributes.get("@default-y") map { _.as[BigDecimal]}
  lazy val relativeu45x = attributes.get("@relative-x") map { _.as[BigDecimal]}
  lazy val relativeu45y = attributes.get("@relative-y") map { _.as[BigDecimal]}
  lazy val fontu45family = attributes.get("@font-family") map { _.as[String]}
  lazy val fontu45style = attributes.get("@font-style") map { _.as[Fontu45style]}
  lazy val fontu45size = attributes.get("@font-size") map { _.as[String]}
  lazy val fontu45weight = attributes.get("@font-weight") map { _.as[Fontu45weight]}
  lazy val color = attributes.get("@color") map { _.as[String]}
  lazy val halign = attributes.get("@halign") map { _.as[Leftu45centeru45right]}
  lazy val valign = attributes.get("@valign") map { _.as[Valign]}
  lazy val printu45object = attributes.get("@print-object") map { _.as[Yesu45no]}
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      
      

case class TimeSequence1(timeu45signatureSequence1: Seq[musicxml.Timeu45signatureSequence] = Nil,
  interchangeable: Option[musicxml.Interchangeable] = None)
      

trait TimeOption

/** The transpose type represents what must be added to a written pitch to get a correct sounding pitch. The optional number attribute refers to staff numbers, from top to bottom on the system. If absent, the transposition applies to all staves in the part. Per-staff transposition is most often used in parts that represent multiple instruments.
*/
case class Transpose(diatonic: Option[BigInt] = None,
  chromatic: BigDecimal,
  octaveu45change: Option[BigInt] = None,
  double: Option[musicxml.Empty] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val number = attributes.get("@number") map { _.as[BigInt]}
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      
      


/** The bar-style-color type contains barline style and color information.
*/
case class Baru45styleu45color(value: musicxml.Baru45style,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val color = attributes.get("@color") map { _.as[String]}
}

      
      


/** If a barline is other than a normal single barline, it should be represented by a barline type that describes it. This includes information about repeats and multiple endings, as well as line style. Barline data is on the same level as the other musical data in a score - a child of a measure in a partwise score, or a part in a timewise score. This allows for barlines within measures, as in dotted barlines that subdivide measures in complex meters. The two fermata elements allow for fermatas on both sides of the barline (the lower one inverted).

Barlines have a location attribute to make it easier to process barlines independently of the other musical data in a score. It is often easier to set up measures separately from entering notes. The location attribute must match where the barline element occurs within the rest of the musical data in the score. If location is left, it should be the first element in the measure, aside from the print, bookmark, and link elements. If location is right, it should be the last element, again with the possible exception of the print, bookmark, and link elements. If no location is specified, the right barline is the default. The segno, coda, and divisions attributes work the same way as in the sound element. They are used for playback when barline elements contain segno or coda child elements.
*/
case class Barline(baru45style: Option[musicxml.Baru45styleu45color] = None,
  editorialSequence2: musicxml.EditorialSequence,
  wavyu45line: Option[musicxml.Wavyu45line] = None,
  segno2: Option[musicxml.Segno] = None,
  coda2: Option[musicxml.Coda] = None,
  fermata: Seq[musicxml.Fermata] = Nil,
  ending: Option[musicxml.Ending] = None,
  repeat: Option[musicxml.Repeat] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Musicu45dataOption1 {
  lazy val location = attributes("@location").as[Rightu45leftu45middle]
  lazy val segno = attributes.get("@segno") map { _.as[String]}
  lazy val coda = attributes.get("@coda") map { _.as[String]}
  lazy val divisions = attributes.get("@divisions") map { _.as[BigDecimal]}
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      
      


/** The ending type represents multiple (e.g. first and second) endings. Typically, the start type is associated with the left barline of the first measure in an ending. The stop and discontinue types are associated with the right barline of the last measure in an ending. Stop is used when the ending mark concludes with a downward jog, as is typical for first endings. Discontinue is used when there is no downward jog, as is typical for second endings that do not conclude a piece. The length of the jog can be specified using the end-length attribute. The text-x and text-y attributes are offsets that specify where the baseline of the start of the ending text appears, relative to the start of the ending line.

The number attribute reflects the numeric values of what is under the ending line. Single endings such as "1" or comma-separated multiple endings such as "1,2" may be used. The ending element text is used when the text displayed in the ending is different than what appears in the number attribute. The print-object element is used to indicate when an ending is present but not printed, as is often the case for many parts in a full score.
*/
case class Ending(value: String,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val number = attributes("@number").as[String]
  lazy val typeValue = attributes("@type").as[Startu45stopu45discontinue]
  lazy val printu45object = attributes.get("@print-object") map { _.as[Yesu45no]}
  lazy val defaultu45x = attributes.get("@default-x") map { _.as[BigDecimal]}
  lazy val defaultu45y = attributes.get("@default-y") map { _.as[BigDecimal]}
  lazy val relativeu45x = attributes.get("@relative-x") map { _.as[BigDecimal]}
  lazy val relativeu45y = attributes.get("@relative-y") map { _.as[BigDecimal]}
  lazy val fontu45family = attributes.get("@font-family") map { _.as[String]}
  lazy val fontu45style = attributes.get("@font-style") map { _.as[Fontu45style]}
  lazy val fontu45size = attributes.get("@font-size") map { _.as[String]}
  lazy val fontu45weight = attributes.get("@font-weight") map { _.as[Fontu45weight]}
  lazy val color = attributes.get("@color") map { _.as[String]}
  lazy val endu45length = attributes.get("@end-length") map { _.as[BigDecimal]}
  lazy val textu45x = attributes.get("@text-x") map { _.as[BigDecimal]}
  lazy val textu45y = attributes.get("@text-y") map { _.as[BigDecimal]}
}

      
      


/** The repeat type represents repeat marks. The start of the repeat has a forward direction while the end of the repeat has a backward direction. Backward repeats that are not part of an ending can use the times attribute to indicate the number of times the repeated section is played.
*/
case class Repeat(attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val direction = attributes("@direction").as[Backwardu45forward]
  lazy val times = attributes.get("@times") map { _.as[BigInt]}
  lazy val winged = attributes.get("@winged") map { _.as[Winged]}
}

      
      


/** The accord type represents the tuning of a single string in the scordatura element. It uses the same group of elements as the staff-tuning element. Strings are numbered from high to low.
*/
case class Accord(tuningSequence1: musicxml.TuningSequence,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val string = attributes.get("@string") map { _.as[BigInt]}
}

      
      


/** The accordion-registration type is use for accordion registration symbols. These are circular symbols divided horizontally into high, middle, and low sections that correspond to 4', 8', and 16' pipes. Each accordion-high, accordion-middle, and accordion-low element represents the presence of one or more dots in the registration diagram. An accordion-registration element needs to have at least one of the child elements present.
*/
case class Accordionu45registration(accordionu45high: Option[musicxml.Empty] = None,
  accordionu45middle: Option[BigInt] = None,
  accordionu45low: Option[musicxml.Empty] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Directionu45typeOption {
  lazy val defaultu45x = attributes.get("@default-x") map { _.as[BigDecimal]}
  lazy val defaultu45y = attributes.get("@default-y") map { _.as[BigDecimal]}
  lazy val relativeu45x = attributes.get("@relative-x") map { _.as[BigDecimal]}
  lazy val relativeu45y = attributes.get("@relative-y") map { _.as[BigDecimal]}
  lazy val fontu45family = attributes.get("@font-family") map { _.as[String]}
  lazy val fontu45style = attributes.get("@font-style") map { _.as[Fontu45style]}
  lazy val fontu45size = attributes.get("@font-size") map { _.as[String]}
  lazy val fontu45weight = attributes.get("@font-weight") map { _.as[Fontu45weight]}
  lazy val color = attributes.get("@color") map { _.as[String]}
  lazy val halign = attributes.get("@halign") map { _.as[Leftu45centeru45right]}
  lazy val valign = attributes.get("@valign") map { _.as[Valign]}
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      
      


/** The barre element indicates placing a finger over multiple strings on a single fret. The type is "start" for the lowest pitched string (e.g., the string with the highest MusicXML number) and is "stop" for the highest pitched string.
*/
case class Barre(attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val typeValue = attributes("@type").as[Startu45stop]
  lazy val color = attributes.get("@color") map { _.as[String]}
}

      
      


/** The bass type is used to indicate a bass note in popular music chord symbols, e.g. G/C. It is generally not used in functional harmony, as inversion is generally not used in pop chord symbols. As with root, it is divided into step and alter elements, similar to pitches.
*/
case class Bass(bassu45step: musicxml.Bassu45step,
  bassu45alter: Option[musicxml.Bassu45alter] = None)
      
      


/** The bass-alter type represents the chromatic alteration of the bass of the current chord within the harmony element. In some chord styles, the text for the bass-step element may include bass-alter information. In that case, the print-object attribute of the bass-alter element can be set to no. The location attribute indicates whether the alteration should appear to the left or the right of the bass-step; it is right by default.
*/
case class Bassu45alter(value: BigDecimal,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val printu45object = attributes.get("@print-object") map { _.as[Yesu45no]}
  lazy val defaultu45x = attributes.get("@default-x") map { _.as[BigDecimal]}
  lazy val defaultu45y = attributes.get("@default-y") map { _.as[BigDecimal]}
  lazy val relativeu45x = attributes.get("@relative-x") map { _.as[BigDecimal]}
  lazy val relativeu45y = attributes.get("@relative-y") map { _.as[BigDecimal]}
  lazy val fontu45family = attributes.get("@font-family") map { _.as[String]}
  lazy val fontu45style = attributes.get("@font-style") map { _.as[Fontu45style]}
  lazy val fontu45size = attributes.get("@font-size") map { _.as[String]}
  lazy val fontu45weight = attributes.get("@font-weight") map { _.as[Fontu45weight]}
  lazy val color = attributes.get("@color") map { _.as[String]}
  lazy val location = attributes.get("@location") map { _.as[Leftu45right]}
}

      
      


/** The bass-step type represents the pitch step of the bass of the current chord within the harmony element. The text attribute indicates how the bass should appear in a score if not using the element contents.
*/
case class Bassu45step(value: musicxml.Step,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val text = attributes.get("@text") map { _.as[String]}
  lazy val defaultu45x = attributes.get("@default-x") map { _.as[BigDecimal]}
  lazy val defaultu45y = attributes.get("@default-y") map { _.as[BigDecimal]}
  lazy val relativeu45x = attributes.get("@relative-x") map { _.as[BigDecimal]}
  lazy val relativeu45y = attributes.get("@relative-y") map { _.as[BigDecimal]}
  lazy val fontu45family = attributes.get("@font-family") map { _.as[String]}
  lazy val fontu45style = attributes.get("@font-style") map { _.as[Fontu45style]}
  lazy val fontu45size = attributes.get("@font-size") map { _.as[String]}
  lazy val fontu45weight = attributes.get("@font-weight") map { _.as[Fontu45weight]}
  lazy val color = attributes.get("@color") map { _.as[String]}
}

      
      


/** The beater type represents pictograms for beaters, mallets, and sticks that do not have different materials represented in the pictogram.
*/
case class Beater(value: musicxml.Beateru45value,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends PercussionTypeOption {
  lazy val tip = attributes.get("@tip") map { _.as[Tipu45direction]}
}

      
      


/** The beat-unit-tied type indicates a beat-unit within a metronome mark that is tied to the preceding beat-unit. This allows or two or more tied notes to be associated with a per-minute value in a metronome mark, whereas the metronome-tied element is restricted to metric relationship marks.
*/
case class Beatu45unitu45tied(beatu45unitSequence1: musicxml.Beatu45unitSequence)
      
      


/** Brackets are combined with words in a variety of modern directions. The line-end attribute specifies if there is a jog up or down (or both), an arrow, or nothing at the start or end of the bracket. If the line-end is up or down, the length of the jog can be specified using the end-length attribute. The line-type is solid by default.
*/
case class Bracket(attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Directionu45typeOption {
  lazy val typeValue = attributes("@type").as[Startu45stopu45continue]
  lazy val number = attributes.get("@number") map { _.as[BigInt]}
  lazy val lineu45end = attributes("@line-end").as[Lineu45end]
  lazy val endu45length = attributes.get("@end-length") map { _.as[BigDecimal]}
  lazy val lineu45type = attributes.get("@line-type") map { _.as[Lineu45type]}
  lazy val dashu45length = attributes.get("@dash-length") map { _.as[BigDecimal]}
  lazy val spaceu45length = attributes.get("@space-length") map { _.as[BigDecimal]}
  lazy val defaultu45x = attributes.get("@default-x") map { _.as[BigDecimal]}
  lazy val defaultu45y = attributes.get("@default-y") map { _.as[BigDecimal]}
  lazy val relativeu45x = attributes.get("@relative-x") map { _.as[BigDecimal]}
  lazy val relativeu45y = attributes.get("@relative-y") map { _.as[BigDecimal]}
  lazy val color = attributes.get("@color") map { _.as[String]}
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      
      


/** The dashes type represents dashes, used for instance with cresc. and dim. marks.
*/
case class Dashes(attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Directionu45typeOption {
  lazy val typeValue = attributes("@type").as[Startu45stopu45continue]
  lazy val number = attributes.get("@number") map { _.as[BigInt]}
  lazy val dashu45length = attributes.get("@dash-length") map { _.as[BigDecimal]}
  lazy val spaceu45length = attributes.get("@space-length") map { _.as[BigDecimal]}
  lazy val defaultu45x = attributes.get("@default-x") map { _.as[BigDecimal]}
  lazy val defaultu45y = attributes.get("@default-y") map { _.as[BigDecimal]}
  lazy val relativeu45x = attributes.get("@relative-x") map { _.as[BigDecimal]}
  lazy val relativeu45y = attributes.get("@relative-y") map { _.as[BigDecimal]}
  lazy val color = attributes.get("@color") map { _.as[String]}
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      
      


/** The degree type is used to add, alter, or subtract individual notes in the chord. The print-object attribute can be used to keep the degree from printing separately when it has already taken into account in the text attribute of the kind element. The degree-value and degree-type text attributes specify how the value and type of the degree should be displayed.

A harmony of kind "other" can be spelled explicitly by using a series of degree elements together with a root.
*/
case class Degree(degreeu45value: musicxml.Degreeu45value,
  degreeu45alter: musicxml.Degreeu45alter,
  degreeu45type: musicxml.Degreeu45type,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val printu45object = attributes.get("@print-object") map { _.as[Yesu45no]}
}

      
      


/** The degree-alter type represents the chromatic alteration for the current degree. If the degree-type value is alter or subtract, the degree-alter value is relative to the degree already in the chord based on its kind element. If the degree-type value is add, the degree-alter is relative to a dominant chord (major and perfect intervals except for a minor seventh). The plus-minus attribute is used to indicate if plus and minus symbols should be used instead of sharp and flat symbols to display the degree alteration; it is no by default.
*/
case class Degreeu45alter(value: BigDecimal,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val defaultu45x = attributes.get("@default-x") map { _.as[BigDecimal]}
  lazy val defaultu45y = attributes.get("@default-y") map { _.as[BigDecimal]}
  lazy val relativeu45x = attributes.get("@relative-x") map { _.as[BigDecimal]}
  lazy val relativeu45y = attributes.get("@relative-y") map { _.as[BigDecimal]}
  lazy val fontu45family = attributes.get("@font-family") map { _.as[String]}
  lazy val fontu45style = attributes.get("@font-style") map { _.as[Fontu45style]}
  lazy val fontu45size = attributes.get("@font-size") map { _.as[String]}
  lazy val fontu45weight = attributes.get("@font-weight") map { _.as[Fontu45weight]}
  lazy val color = attributes.get("@color") map { _.as[String]}
  lazy val plusu45minus = attributes.get("@plus-minus") map { _.as[Yesu45no]}
}

      
      


/** The degree-type type indicates if this degree is an addition, alteration, or subtraction relative to the kind of the current chord. The value of the degree-type element affects the interpretation of the value of the degree-alter element. The text attribute specifies how the type of the degree should be displayed in a score.
*/
case class Degreeu45type(value: musicxml.Degreeu45typeu45value,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val text = attributes.get("@text") map { _.as[String]}
  lazy val defaultu45x = attributes.get("@default-x") map { _.as[BigDecimal]}
  lazy val defaultu45y = attributes.get("@default-y") map { _.as[BigDecimal]}
  lazy val relativeu45x = attributes.get("@relative-x") map { _.as[BigDecimal]}
  lazy val relativeu45y = attributes.get("@relative-y") map { _.as[BigDecimal]}
  lazy val fontu45family = attributes.get("@font-family") map { _.as[String]}
  lazy val fontu45style = attributes.get("@font-style") map { _.as[Fontu45style]}
  lazy val fontu45size = attributes.get("@font-size") map { _.as[String]}
  lazy val fontu45weight = attributes.get("@font-weight") map { _.as[Fontu45weight]}
  lazy val color = attributes.get("@color") map { _.as[String]}
}

      
      


/** The content of the degree-value type is a number indicating the degree of the chord (1 for the root, 3 for third, etc). The text attribute specifies how the type of the degree should be displayed in a score. The degree-value symbol attribute indicates that a symbol should be used in specifying the degree. If the symbol attribute is present, the value of the text attribute follows the symbol.
*/
case class Degreeu45value(value: BigInt,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val symbol = attributes.get("@symbol") map { _.as[Degreeu45symbolu45value]}
  lazy val text = attributes.get("@text") map { _.as[String]}
  lazy val defaultu45x = attributes.get("@default-x") map { _.as[BigDecimal]}
  lazy val defaultu45y = attributes.get("@default-y") map { _.as[BigDecimal]}
  lazy val relativeu45x = attributes.get("@relative-x") map { _.as[BigDecimal]}
  lazy val relativeu45y = attributes.get("@relative-y") map { _.as[BigDecimal]}
  lazy val fontu45family = attributes.get("@font-family") map { _.as[String]}
  lazy val fontu45style = attributes.get("@font-style") map { _.as[Fontu45style]}
  lazy val fontu45size = attributes.get("@font-size") map { _.as[String]}
  lazy val fontu45weight = attributes.get("@font-weight") map { _.as[Fontu45weight]}
  lazy val color = attributes.get("@color") map { _.as[String]}
}

      
      


/** A direction is a musical indication that is not necessarily attached to a specific note. Two or more may be combined to indicate starts and stops of wedges, dashes, etc. For applications where a specific direction is indeed attached to a specific note, the direction element can be associated with the note element that follows it in score order that is not in a different voice.

By default, a series of direction-type elements and a series of child elements of a direction-type within a single direction element follow one another in sequence visually. For a series of direction-type children, non-positional formatting attributes are carried over from the previous element by default.
*/
case class Direction(directionu45type: Seq[musicxml.Directionu45type] = Nil,
  offset: Option[musicxml.Offset] = None,
  editorialu45voiceu45directionSequence3: musicxml.Editorialu45voiceu45directionSequence,
  staffSequence4: Option[musicxml.StaffSequence] = None,
  sound: Option[musicxml.Sound] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Musicu45dataOption1 {
  lazy val placement = attributes.get("@placement") map { _.as[Aboveu45below]}
  lazy val directive = attributes.get("@directive") map { _.as[Yesu45no]}
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      
      


/** Textual direction types may have more than 1 component due to multiple fonts. The dynamics element may also be used in the notations element. Attribute groups related to print suggestions apply to the individual direction-type, not to the overall direction.
*/
case class Directionu45type(directionu45typeoption: Seq[scalaxb.DataRecord[musicxml.Directionu45typeOption]] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      
      

trait Directionu45typeOption
trait Directionu45typeOption2 extends Directionu45typeOption

/** The feature type is a part of the grouping element used for musical analysis. The type attribute represents the type of the feature and the element content represents its value. This type is flexible to allow for different analyses.
*/
case class Feature(value: String,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val typeValue = attributes.get("@type") map { _.as[String]}
}

      
      


/** The first-fret type indicates which fret is shown in the top space of the frame; it is fret 1 if the element is not present. The optional text attribute indicates how this is represented in the fret diagram, while the location attribute indicates whether the text appears to the left or right of the frame.
*/
case class Firstu45fret(value: BigInt,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val text = attributes.get("@text") map { _.as[String]}
  lazy val location = attributes.get("@location") map { _.as[Leftu45right]}
}

      
      


/** The frame type represents a frame or fretboard diagram used together with a chord symbol. The representation is based on the NIFF guitar grid with additional information. The frame type's unplayed attribute indicates what to display above a string that has no associated frame-note element. Typical values are x and the empty string. If the attribute is not present, the display of the unplayed string is application-defined.
*/
case class Frame(frameu45strings: BigInt,
  frameu45frets: BigInt,
  firstu45fret: Option[musicxml.Firstu45fret] = None,
  frameu45note: Seq[musicxml.Frameu45note] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val defaultu45x = attributes.get("@default-x") map { _.as[BigDecimal]}
  lazy val defaultu45y = attributes.get("@default-y") map { _.as[BigDecimal]}
  lazy val relativeu45x = attributes.get("@relative-x") map { _.as[BigDecimal]}
  lazy val relativeu45y = attributes.get("@relative-y") map { _.as[BigDecimal]}
  lazy val color = attributes.get("@color") map { _.as[String]}
  lazy val halign = attributes.get("@halign") map { _.as[Leftu45centeru45right]}
  lazy val valign = attributes.get("@valign") map { _.as[Valignu45image]}
  lazy val height = attributes.get("@height") map { _.as[BigDecimal]}
  lazy val width = attributes.get("@width") map { _.as[BigDecimal]}
  lazy val unplayed = attributes.get("@unplayed") map { _.as[String]}
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      
      


/** The frame-note type represents each note included in the frame. An open string will have a fret value of 0, while a muted string will not be associated with a frame-note element.
*/
case class Frameu45note(string: musicxml.StringType,
  fret: musicxml.Fret,
  fingering: Option[musicxml.Fingering] = None,
  barre: Option[musicxml.Barre] = None)
      
      


/** The glass type represents pictograms for glass percussion instruments. The smufl attribute is used to distinguish different SMuFL glyphs for wind chimes in the chimes pictograms range, including those made of materials other than glass.
*/
case class Glass(value: musicxml.Glassu45value,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends PercussionTypeOption {
  lazy val smufl = attributes.get("@smufl") map { _.as[String]}
}

      
      


/** The grouping type is used for musical analysis. When the type attribute is "start" or "single", it usually contains one or more feature elements. The number attribute is used for distinguishing between overlapping and hierarchical groupings. The member-of attribute allows for easy distinguishing of what grouping elements are in what hierarchy. Feature elements contained within a "stop" type of grouping may be ignored.

This element is flexible to allow for different types of analyses. Future versions of the MusicXML format may add elements that can represent more standardized categories of analysis data, allowing for easier data sharing.
*/
case class Grouping(feature: Seq[musicxml.Feature] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Musicu45dataOption1 {
  lazy val typeValue = attributes("@type").as[Startu45stopu45single]
  lazy val number = attributes("@number").as[String]
  lazy val memberu45of = attributes.get("@member-of") map { _.as[String]}
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      
      


/** The harmony type is based on Humdrum's **harm encoding, extended to support chord symbols in popular music as well as functional harmony analysis in classical music.

If there are alternate harmonies possible, this can be specified using multiple harmony elements differentiated by type. Explicit harmonies have all note present in the music; implied have some notes missing but implied; alternate represents alternate analyses.

The harmony object may be used for analysis or for chord symbols. The print-object attribute controls whether or not anything is printed due to the harmony element. The print-frame attribute controls printing of a frame or fretboard diagram. The print-style attribute group sets the default for the harmony, but individual elements can override this with their own print-style values.
*/
case class Harmony(harmonyu45chordSequence1: Seq[musicxml.Harmonyu45chordSequence] = Nil,
  frame: Option[musicxml.Frame] = None,
  offset: Option[musicxml.Offset] = None,
  editorialSequence4: musicxml.EditorialSequence,
  staffSequence5: Option[musicxml.StaffSequence] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Musicu45dataOption1 {
  lazy val typeValue = attributes.get("@type") map { _.as[Harmonyu45type]}
  lazy val printu45object = attributes.get("@print-object") map { _.as[Yesu45no]}
  lazy val printu45frame = attributes.get("@print-frame") map { _.as[Yesu45no]}
  lazy val defaultu45x = attributes.get("@default-x") map { _.as[BigDecimal]}
  lazy val defaultu45y = attributes.get("@default-y") map { _.as[BigDecimal]}
  lazy val relativeu45x = attributes.get("@relative-x") map { _.as[BigDecimal]}
  lazy val relativeu45y = attributes.get("@relative-y") map { _.as[BigDecimal]}
  lazy val fontu45family = attributes.get("@font-family") map { _.as[String]}
  lazy val fontu45style = attributes.get("@font-style") map { _.as[Fontu45style]}
  lazy val fontu45size = attributes.get("@font-size") map { _.as[String]}
  lazy val fontu45weight = attributes.get("@font-weight") map { _.as[Fontu45weight]}
  lazy val color = attributes.get("@color") map { _.as[String]}
  lazy val placement = attributes.get("@placement") map { _.as[Aboveu45below]}
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      
      


/** The harp-pedals type is used to create harp pedal diagrams. The pedal-step and pedal-alter elements use the same values as the step and alter elements. For easiest reading, the pedal-tuning elements should follow standard harp pedal order, with pedal-step values of D, C, B, E, F, G, and A.
*/
case class Harpu45pedals(pedalu45tuning: Seq[musicxml.Pedalu45tuning] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Directionu45typeOption {
  lazy val defaultu45x = attributes.get("@default-x") map { _.as[BigDecimal]}
  lazy val defaultu45y = attributes.get("@default-y") map { _.as[BigDecimal]}
  lazy val relativeu45x = attributes.get("@relative-x") map { _.as[BigDecimal]}
  lazy val relativeu45y = attributes.get("@relative-y") map { _.as[BigDecimal]}
  lazy val fontu45family = attributes.get("@font-family") map { _.as[String]}
  lazy val fontu45style = attributes.get("@font-style") map { _.as[Fontu45style]}
  lazy val fontu45size = attributes.get("@font-size") map { _.as[String]}
  lazy val fontu45weight = attributes.get("@font-weight") map { _.as[Fontu45weight]}
  lazy val color = attributes.get("@color") map { _.as[String]}
  lazy val halign = attributes.get("@halign") map { _.as[Leftu45centeru45right]}
  lazy val valign = attributes.get("@valign") map { _.as[Valign]}
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      
      


/** The image type is used to include graphical images in a score.
*/
case class Image(attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Directionu45typeOption with CreditOption {
  lazy val source = attributes("@source").as[java.net.URI]
  lazy val typeValue = attributes("@type").as[String]
  lazy val height = attributes.get("@height") map { _.as[BigDecimal]}
  lazy val width = attributes.get("@width") map { _.as[BigDecimal]}
  lazy val defaultu45x = attributes.get("@default-x") map { _.as[BigDecimal]}
  lazy val defaultu45y = attributes.get("@default-y") map { _.as[BigDecimal]}
  lazy val relativeu45x = attributes.get("@relative-x") map { _.as[BigDecimal]}
  lazy val relativeu45y = attributes.get("@relative-y") map { _.as[BigDecimal]}
  lazy val halign = attributes.get("@halign") map { _.as[Leftu45centeru45right]}
  lazy val valign = attributes.get("@valign") map { _.as[Valignu45image]}
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      
      


/** The inversion type represents harmony inversions. The value is a number indicating which inversion is used: 0 for root position, 1 for first inversion, etc.
*/
case class Inversion(value: BigInt,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val defaultu45x = attributes.get("@default-x") map { _.as[BigDecimal]}
  lazy val defaultu45y = attributes.get("@default-y") map { _.as[BigDecimal]}
  lazy val relativeu45x = attributes.get("@relative-x") map { _.as[BigDecimal]}
  lazy val relativeu45y = attributes.get("@relative-y") map { _.as[BigDecimal]}
  lazy val fontu45family = attributes.get("@font-family") map { _.as[String]}
  lazy val fontu45style = attributes.get("@font-style") map { _.as[Fontu45style]}
  lazy val fontu45size = attributes.get("@font-size") map { _.as[String]}
  lazy val fontu45weight = attributes.get("@font-weight") map { _.as[Fontu45weight]}
  lazy val color = attributes.get("@color") map { _.as[String]}
}

      
      


/** Kind indicates the type of chord. Degree elements can then add, subtract, or alter from these starting points

The attributes are used to indicate the formatting of the symbol. Since the kind element is the constant in all the harmony-chord groups that can make up a polychord, many formatting attributes are here.

The use-symbols attribute is yes if the kind should be represented when possible with harmony symbols rather than letters and numbers. These symbols include:

	major: a triangle, like Unicode 25B3
	minor: -, like Unicode 002D
	augmented: +, like Unicode 002B
	diminished: Â°, like Unicode 00B0
	half-diminished: Ã¸, like Unicode 00F8

For the major-minor kind, only the minor symbol is used when use-symbols is yes. The major symbol is set using the symbol attribute in the degree-value element. The corresponding degree-alter value will usually be 0 in this case.

The text attribute describes how the kind should be spelled in a score. If use-symbols is yes, the value of the text attribute follows the symbol. The stack-degrees attribute is yes if the degree elements should be stacked above each other. The parentheses-degrees attribute is yes if all the degrees should be in parentheses. The bracket-degrees attribute is yes if all the degrees should be in a bracket. If not specified, these values are implementation-specific. The alignment attributes are for the entire harmony-chord group of which this kind element is a part.
*/
case class Kind(value: musicxml.Kindu45value,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val useu45symbols = attributes.get("@use-symbols") map { _.as[Yesu45no]}
  lazy val text = attributes.get("@text") map { _.as[String]}
  lazy val stacku45degrees = attributes.get("@stack-degrees") map { _.as[Yesu45no]}
  lazy val parenthesesu45degrees = attributes.get("@parentheses-degrees") map { _.as[Yesu45no]}
  lazy val bracketu45degrees = attributes.get("@bracket-degrees") map { _.as[Yesu45no]}
  lazy val defaultu45x = attributes.get("@default-x") map { _.as[BigDecimal]}
  lazy val defaultu45y = attributes.get("@default-y") map { _.as[BigDecimal]}
  lazy val relativeu45x = attributes.get("@relative-x") map { _.as[BigDecimal]}
  lazy val relativeu45y = attributes.get("@relative-y") map { _.as[BigDecimal]}
  lazy val fontu45family = attributes.get("@font-family") map { _.as[String]}
  lazy val fontu45style = attributes.get("@font-style") map { _.as[Fontu45style]}
  lazy val fontu45size = attributes.get("@font-size") map { _.as[String]}
  lazy val fontu45weight = attributes.get("@font-weight") map { _.as[Fontu45weight]}
  lazy val color = attributes.get("@color") map { _.as[String]}
  lazy val halign = attributes.get("@halign") map { _.as[Leftu45centeru45right]}
  lazy val valign = attributes.get("@valign") map { _.as[Valign]}
}

      
      


/** The measure-numbering type describes how frequently measure numbers are displayed on this part. The number attribute from the measure element is used for printing. Measures with an implicit attribute set to "yes" never display a measure number, regardless of the measure-numbering setting.
*/
case class Measureu45numbering(value: musicxml.Measureu45numberingu45value,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val defaultu45x = attributes.get("@default-x") map { _.as[BigDecimal]}
  lazy val defaultu45y = attributes.get("@default-y") map { _.as[BigDecimal]}
  lazy val relativeu45x = attributes.get("@relative-x") map { _.as[BigDecimal]}
  lazy val relativeu45y = attributes.get("@relative-y") map { _.as[BigDecimal]}
  lazy val fontu45family = attributes.get("@font-family") map { _.as[String]}
  lazy val fontu45style = attributes.get("@font-style") map { _.as[Fontu45style]}
  lazy val fontu45size = attributes.get("@font-size") map { _.as[String]}
  lazy val fontu45weight = attributes.get("@font-weight") map { _.as[Fontu45weight]}
  lazy val color = attributes.get("@color") map { _.as[String]}
  lazy val halign = attributes.get("@halign") map { _.as[Leftu45centeru45right]}
  lazy val valign = attributes.get("@valign") map { _.as[Valign]}
}

      
      


/** The metronome type represents metronome marks and other metric relationships. The beat-unit group and per-minute element specify regular metronome marks. The metronome-note and metronome-relation elements allow for the specification of metric modulations and other metric relationships, such as swing tempo marks where two eighths are equated to a quarter note / eighth note triplet. Tied notes can be represented in both types of metronome marks by using the beat-unit-tied and metronome-tied elements. The parentheses attribute indicates whether or not to put the metronome mark in parentheses; its value is no if not specified.
*/
case class Metronome(metronomeoption: scalaxb.DataRecord[musicxml.MetronomeOption],
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Directionu45typeOption {
  lazy val defaultu45x = attributes.get("@default-x") map { _.as[BigDecimal]}
  lazy val defaultu45y = attributes.get("@default-y") map { _.as[BigDecimal]}
  lazy val relativeu45x = attributes.get("@relative-x") map { _.as[BigDecimal]}
  lazy val relativeu45y = attributes.get("@relative-y") map { _.as[BigDecimal]}
  lazy val fontu45family = attributes.get("@font-family") map { _.as[String]}
  lazy val fontu45style = attributes.get("@font-style") map { _.as[Fontu45style]}
  lazy val fontu45size = attributes.get("@font-size") map { _.as[String]}
  lazy val fontu45weight = attributes.get("@font-weight") map { _.as[Fontu45weight]}
  lazy val color = attributes.get("@color") map { _.as[String]}
  lazy val halign = attributes.get("@halign") map { _.as[Leftu45centeru45right]}
  lazy val valign = attributes.get("@valign") map { _.as[Valign]}
  lazy val justify = attributes.get("@justify") map { _.as[Leftu45centeru45right]}
  lazy val parentheses = attributes.get("@parentheses") map { _.as[Yesu45no]}
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      
      

case class MetronomeSequence4(metronomeu45relation: String,
  metronomeu45note: Seq[musicxml.Metronomeu45note] = Nil)
      

case class MetronomeSequence1(beatu45unitSequence1: musicxml.Beatu45unitSequence,
  beatu45unitu45tied: Seq[musicxml.Beatu45unitu45tied] = Nil,
  metronomeoption2: scalaxb.DataRecord[musicxml.MetronomeOption2]) extends MetronomeOption
      

trait MetronomeOption2
case class MetronomeSequence3(metronomeu45arrows: Option[musicxml.Empty] = None,
  metronomeu45note: Seq[musicxml.Metronomeu45note] = Nil,
  metronomesequence4: Option[musicxml.MetronomeSequence4] = None) extends MetronomeOption
      

trait MetronomeOption
case class MetronomeSequence2(beatu45unitSequence1: musicxml.Beatu45unitSequence,
  beatu45unitu45tied: Seq[musicxml.Beatu45unitu45tied] = Nil) extends MetronomeOption2
      


/** The metronome-beam type works like the beam type in defining metric relationships, but does not include all the attributes available in the beam type.
*/
case class Metronomeu45beam(value: musicxml.Beamu45value,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val number = attributes("@number").as[BigInt]
}

      
      


/** The metronome-note type defines the appearance of a note within a metric relationship mark.
*/
case class Metronomeu45note(metronomeu45type: musicxml.Noteu45typeu45value,
  metronomeu45dot: Seq[musicxml.Empty] = Nil,
  metronomeu45beam: Seq[musicxml.Metronomeu45beam] = Nil,
  metronomeu45tied: Option[musicxml.Metronomeu45tied] = None,
  metronomeu45tuplet: Option[musicxml.Metronomeu45tuplet] = None)
      
      


/** The metronome-tied indicates the presence of a tie within a metric relationship mark. As with the tied element, both the start and stop of the tie should be specified, in this case within separate metronome-note elements.
*/
case class Metronomeu45tied(attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val typeValue = attributes("@type").as[Startu45stop]
}

      
      


/** The metronome-tuplet type uses the same element structure as the time-modification element along with some attributes from the tuplet element.
*/
case class Metronomeu45tuplet(actualu45notes: BigInt,
  normalu45notes: BigInt,
  timeu45modificationablesequence1: Option[musicxml.Timeu45modificationableSequence1] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Timeu45modificationable {
  lazy val typeValue = attributes("@type").as[Startu45stop]
  lazy val bracket = attributes.get("@bracket") map { _.as[Yesu45no]}
  lazy val showu45number = attributes.get("@show-number") map { _.as[Showu45tuplet]}
}

      
      


/** The octave shift type indicates where notes are shifted up or down from their true pitched values because of printing difficulty. Thus a treble clef line noted with 8va will be indicated with an octave-shift down from the pitch data indicated in the notes. A size of 8 indicates one octave; a size of 15 indicates two octaves.
*/
case class Octaveu45shift(attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Directionu45typeOption {
  lazy val typeValue = attributes("@type").as[Upu45downu45stopu45continue]
  lazy val number = attributes.get("@number") map { _.as[BigInt]}
  lazy val size = attributes("@size").as[BigInt]
  lazy val dashu45length = attributes.get("@dash-length") map { _.as[BigDecimal]}
  lazy val spaceu45length = attributes.get("@space-length") map { _.as[BigDecimal]}
  lazy val defaultu45x = attributes.get("@default-x") map { _.as[BigDecimal]}
  lazy val defaultu45y = attributes.get("@default-y") map { _.as[BigDecimal]}
  lazy val relativeu45x = attributes.get("@relative-x") map { _.as[BigDecimal]}
  lazy val relativeu45y = attributes.get("@relative-y") map { _.as[BigDecimal]}
  lazy val fontu45family = attributes.get("@font-family") map { _.as[String]}
  lazy val fontu45style = attributes.get("@font-style") map { _.as[Fontu45style]}
  lazy val fontu45size = attributes.get("@font-size") map { _.as[String]}
  lazy val fontu45weight = attributes.get("@font-weight") map { _.as[Fontu45weight]}
  lazy val color = attributes.get("@color") map { _.as[String]}
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      
      


/** An offset is represented in terms of divisions, and indicates where the direction will appear relative to the current musical location. This affects the visual appearance of the direction. If the sound attribute is "yes", then the offset affects playback too. If the sound attribute is "no", then any sound associated with the direction takes effect at the current location. The sound attribute is "no" by default for compatibility with earlier versions of the MusicXML format. If an element within a direction includes a default-x attribute, the offset value will be ignored when determining the appearance of that element.
*/
case class Offset(value: BigDecimal,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val sound = attributes.get("@sound") map { _.as[Yesu45no]}
}

      
      


/** The other-direction type is used to define any direction symbols not yet in the MusicXML format. The smufl attribute can be used to specify a particular direction symbol, allowing application interoperability without requiring every SMuFL glyph to have a MusicXML element equivalent. Using the other-direction type without the smufl attribute allows for extended representation, though without application interoperability.
*/
case class Otheru45direction(value: String,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Directionu45typeOption {
  lazy val printu45object = attributes.get("@print-object") map { _.as[Yesu45no]}
  lazy val defaultu45x = attributes.get("@default-x") map { _.as[BigDecimal]}
  lazy val defaultu45y = attributes.get("@default-y") map { _.as[BigDecimal]}
  lazy val relativeu45x = attributes.get("@relative-x") map { _.as[BigDecimal]}
  lazy val relativeu45y = attributes.get("@relative-y") map { _.as[BigDecimal]}
  lazy val fontu45family = attributes.get("@font-family") map { _.as[String]}
  lazy val fontu45style = attributes.get("@font-style") map { _.as[Fontu45style]}
  lazy val fontu45size = attributes.get("@font-size") map { _.as[String]}
  lazy val fontu45weight = attributes.get("@font-weight") map { _.as[Fontu45weight]}
  lazy val color = attributes.get("@color") map { _.as[String]}
  lazy val halign = attributes.get("@halign") map { _.as[Leftu45centeru45right]}
  lazy val valign = attributes.get("@valign") map { _.as[Valign]}
  lazy val smufl = attributes.get("@smufl") map { _.as[String]}
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      
      


/** The pedal type represents piano pedal marks. In MusicXML 3.1 this includes sostenuto as well as damper pedal marks. The line attribute is yes if pedal lines are used. The sign attribute is yes if Ped, Sost, and * signs are used. For MusicXML 2.0 compatibility, the sign attribute is yes by default if the line attribute is no, and is no by default if the line attribute is yes. If the sign attribute is set to yes and the type is start or sostenuto, the abbreviated attribute is yes if the short P and S signs are used, and no if the full Ped and Sost signs are used. It is no by default. Otherwise the abbreviated attribute is ignored.

The change and continue types are used when the line attribute is yes. The change type indicates a pedal lift and retake indicated with an inverted V marking. The continue type allows more precise formatting across system breaks and for more complex pedaling lines. The alignment attributes are ignored if the line attribute is yes.
*/
case class Pedal(attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Directionu45typeOption {
  lazy val typeValue = attributes("@type").as[Pedalu45type]
  lazy val number = attributes.get("@number") map { _.as[BigInt]}
  lazy val line = attributes.get("@line") map { _.as[Yesu45no]}
  lazy val sign = attributes.get("@sign") map { _.as[Yesu45no]}
  lazy val abbreviated = attributes.get("@abbreviated") map { _.as[Yesu45no]}
  lazy val defaultu45x = attributes.get("@default-x") map { _.as[BigDecimal]}
  lazy val defaultu45y = attributes.get("@default-y") map { _.as[BigDecimal]}
  lazy val relativeu45x = attributes.get("@relative-x") map { _.as[BigDecimal]}
  lazy val relativeu45y = attributes.get("@relative-y") map { _.as[BigDecimal]}
  lazy val fontu45family = attributes.get("@font-family") map { _.as[String]}
  lazy val fontu45style = attributes.get("@font-style") map { _.as[Fontu45style]}
  lazy val fontu45size = attributes.get("@font-size") map { _.as[String]}
  lazy val fontu45weight = attributes.get("@font-weight") map { _.as[Fontu45weight]}
  lazy val color = attributes.get("@color") map { _.as[String]}
  lazy val halign = attributes.get("@halign") map { _.as[Leftu45centeru45right]}
  lazy val valign = attributes.get("@valign") map { _.as[Valign]}
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      
      


/** The pedal-tuning type specifies the tuning of a single harp pedal.
*/
case class Pedalu45tuning(pedalu45step: musicxml.Step,
  pedalu45alter: BigDecimal)
      
      


/** The per-minute type can be a number, or a text description including numbers. If a font is specified, it overrides the font specified for the overall metronome element. This allows separate specification of a music font for the beat-unit and a text font for the numeric value, in cases where a single metronome font is not used.
*/
case class Peru45minute(value: String,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends MetronomeOption2 {
  lazy val fontu45family = attributes.get("@font-family") map { _.as[String]}
  lazy val fontu45style = attributes.get("@font-style") map { _.as[Fontu45style]}
  lazy val fontu45size = attributes.get("@font-size") map { _.as[String]}
  lazy val fontu45weight = attributes.get("@font-weight") map { _.as[Fontu45weight]}
}

      
      


/** The percussion element is used to define percussion pictogram symbols. Definitions for these symbols can be found in Kurt Stone's "Music Notation in the Twentieth Century" on pages 206-212 and 223. Some values are added to these based on how usage has evolved in the 30 years since Stone's book was published.
*/
case class PercussionType(percussiontypeoption: scalaxb.DataRecord[Any],
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Directionu45typeOption {
  lazy val defaultu45x = attributes.get("@default-x") map { _.as[BigDecimal]}
  lazy val defaultu45y = attributes.get("@default-y") map { _.as[BigDecimal]}
  lazy val relativeu45x = attributes.get("@relative-x") map { _.as[BigDecimal]}
  lazy val relativeu45y = attributes.get("@relative-y") map { _.as[BigDecimal]}
  lazy val fontu45family = attributes.get("@font-family") map { _.as[String]}
  lazy val fontu45style = attributes.get("@font-style") map { _.as[Fontu45style]}
  lazy val fontu45size = attributes.get("@font-size") map { _.as[String]}
  lazy val fontu45weight = attributes.get("@font-weight") map { _.as[Fontu45weight]}
  lazy val color = attributes.get("@color") map { _.as[String]}
  lazy val halign = attributes.get("@halign") map { _.as[Leftu45centeru45right]}
  lazy val valign = attributes.get("@valign") map { _.as[Valign]}
  lazy val enclosure = attributes.get("@enclosure") map { _.as[Enclosureu45shape]}
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      
      

trait PercussionTypeOption

/** The pitched-value type represents pictograms for pitched percussion instruments. The smufl attribute is used to distinguish different SMuFL glyphs for a particular pictogram within the tuned mallet percussion pictograms range.
*/
case class Pitched(value: musicxml.Pitchedu45value,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends PercussionTypeOption {
  lazy val smufl = attributes.get("@smufl") map { _.as[String]}
}

      
      


/** The principal-voice element represents principal and secondary voices in a score, either for analysis or for square bracket symbols that appear in a score. The symbol attribute indicates the type of symbol used at the start of the principal-voice. The content of the principal-voice element is used for analysis and may be any text value. When used for analysis separate from any printed score markings, the symbol attribute should be set to "none".
*/
case class Principalu45voice(value: String,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Directionu45typeOption {
  lazy val typeValue = attributes("@type").as[Startu45stop]
  lazy val symbol = attributes("@symbol").as[Principalu45voiceu45symbol]
  lazy val defaultu45x = attributes.get("@default-x") map { _.as[BigDecimal]}
  lazy val defaultu45y = attributes.get("@default-y") map { _.as[BigDecimal]}
  lazy val relativeu45x = attributes.get("@relative-x") map { _.as[BigDecimal]}
  lazy val relativeu45y = attributes.get("@relative-y") map { _.as[BigDecimal]}
  lazy val fontu45family = attributes.get("@font-family") map { _.as[String]}
  lazy val fontu45style = attributes.get("@font-style") map { _.as[Fontu45style]}
  lazy val fontu45size = attributes.get("@font-size") map { _.as[String]}
  lazy val fontu45weight = attributes.get("@font-weight") map { _.as[Fontu45weight]}
  lazy val color = attributes.get("@color") map { _.as[String]}
  lazy val halign = attributes.get("@halign") map { _.as[Leftu45centeru45right]}
  lazy val valign = attributes.get("@valign") map { _.as[Valign]}
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      
      


/** The print type contains general printing parameters, including the layout elements defined in the layout.mod file. The part-name-display and part-abbreviation-display elements used in the score.mod file may also be used here to change how a part name or abbreviation is displayed over the course of a piece. They take effect when the current measure or a succeeding measure starts a new system.

Layout elements in a print statement only apply to the current page, system, staff, or measure. Music that follows continues to take the default values from the layout included in the defaults element.
*/
case class Print(layoutSequence1: musicxml.LayoutSequence,
  measureu45layout: Option[musicxml.Measureu45layout] = None,
  measureu45numbering: Option[musicxml.Measureu45numbering] = None,
  partu45nameu45display: Option[musicxml.Nameu45display] = None,
  partu45abbreviationu45display: Option[musicxml.Nameu45display] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Musicu45dataOption1 {
  lazy val staffu45spacing = attributes.get("@staff-spacing") map { _.as[BigDecimal]}
  lazy val newu45system = attributes.get("@new-system") map { _.as[Yesu45no]}
  lazy val newu45page = attributes.get("@new-page") map { _.as[Yesu45no]}
  lazy val blanku45page = attributes.get("@blank-page") map { _.as[BigInt]}
  lazy val pageu45number = attributes.get("@page-number") map { _.as[String]}
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      
      


/** The root type indicates a pitch like C, D, E vs. a function indication like I, II, III. It is used with chord symbols in popular music. The root element has a root-step and optional root-alter element similar to the step and alter elements, but renamed to distinguish the different musical meanings.
*/
case class Root(rootu45step: musicxml.Rootu45step,
  rootu45alter: Option[musicxml.Rootu45alter] = None) extends Harmonyu45chordOption1
      
      


/** The root-alter type represents the chromatic alteration of the root of the current chord within the harmony element. In some chord styles, the text for the root-step element may include root-alter information. In that case, the print-object attribute of the root-alter element can be set to no. The location attribute indicates whether the alteration should appear to the left or the right of the root-step; it is right by default.
*/
case class Rootu45alter(value: BigDecimal,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val printu45object = attributes.get("@print-object") map { _.as[Yesu45no]}
  lazy val defaultu45x = attributes.get("@default-x") map { _.as[BigDecimal]}
  lazy val defaultu45y = attributes.get("@default-y") map { _.as[BigDecimal]}
  lazy val relativeu45x = attributes.get("@relative-x") map { _.as[BigDecimal]}
  lazy val relativeu45y = attributes.get("@relative-y") map { _.as[BigDecimal]}
  lazy val fontu45family = attributes.get("@font-family") map { _.as[String]}
  lazy val fontu45style = attributes.get("@font-style") map { _.as[Fontu45style]}
  lazy val fontu45size = attributes.get("@font-size") map { _.as[String]}
  lazy val fontu45weight = attributes.get("@font-weight") map { _.as[Fontu45weight]}
  lazy val color = attributes.get("@color") map { _.as[String]}
  lazy val location = attributes.get("@location") map { _.as[Leftu45right]}
}

      
      


/** The root-step type represents the pitch step of the root of the current chord within the harmony element. The text attribute indicates how the root should appear in a score if not using the element contents.
*/
case class Rootu45step(value: musicxml.Step,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val text = attributes.get("@text") map { _.as[String]}
  lazy val defaultu45x = attributes.get("@default-x") map { _.as[BigDecimal]}
  lazy val defaultu45y = attributes.get("@default-y") map { _.as[BigDecimal]}
  lazy val relativeu45x = attributes.get("@relative-x") map { _.as[BigDecimal]}
  lazy val relativeu45y = attributes.get("@relative-y") map { _.as[BigDecimal]}
  lazy val fontu45family = attributes.get("@font-family") map { _.as[String]}
  lazy val fontu45style = attributes.get("@font-style") map { _.as[Fontu45style]}
  lazy val fontu45size = attributes.get("@font-size") map { _.as[String]}
  lazy val fontu45weight = attributes.get("@font-weight") map { _.as[Fontu45weight]}
  lazy val color = attributes.get("@color") map { _.as[String]}
}

      
      


/** Scordatura string tunings are represented by a series of accord elements, similar to the staff-tuning elements. Strings are numbered from high to low.
*/
case class Scordatura(accord: Seq[musicxml.Accord] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Directionu45typeOption {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      
      


/** The sound element contains general playback parameters. They can stand alone within a part/measure, or be a component element within a direction.

Tempo is expressed in quarter notes per minute. If 0, the sound-generating program should prompt the user at the time of compiling a sound (MIDI) file.

Dynamics (or MIDI velocity) are expressed as a percentage of the default forte value (90 for MIDI 1.0).

Dacapo indicates to go back to the beginning of the movement. When used it always has the value "yes".

Segno and dalsegno are used for backwards jumps to a segno sign; coda and tocoda are used for forward jumps to a coda sign. If there are multiple jumps, the value of these parameters can be used to name and distinguish them. If segno or coda is used, the divisions attribute can also be used to indicate the number of divisions per quarter note. Otherwise sound and MIDI generating programs may have to recompute this.

By default, a dalsegno or dacapo attribute indicates that the jump should occur the first time through, while a tocoda attribute indicates the jump should occur the second time through. The time that jumps occur can be changed by using the time-only attribute.

Forward-repeat is used when a forward repeat sign is implied, and usually follows a bar line. When used it always has the value of "yes".

The fine attribute follows the final note or rest in a movement with a da capo or dal segno direction. If numeric, the value represents the actual duration of the final note or rest, which can be ambiguous in written notation and different among parts and voices. The value may also be "yes" to indicate no change to the final duration.

If the sound element applies only particular times through a repeat, the time-only attribute indicates which times to apply the sound element.

Pizzicato in a sound element effects all following notes. Yes indicates pizzicato, no indicates arco.

The pan and elevation attributes are deprecated in Version 2.0. The pan and elevation elements in the midi-instrument element should be used instead. The meaning of the pan and elevation attributes is the same as for the pan and elevation elements. If both are present, the mid-instrument elements take priority.

The damper-pedal, soft-pedal, and sostenuto-pedal attributes effect playback of the three common piano pedals and their MIDI controller equivalents. The yes value indicates the pedal is depressed; no indicates the pedal is released. A numeric value from 0 to 100 may also be used for half pedaling. This value is the percentage that the pedal is depressed. A value of 0 is equivalent to no, and a value of 100 is equivalent to yes.

MIDI devices, MIDI instruments, and playback techniques are changed using the midi-device, midi-instrument, and play elements. When there are multiple instances of these elements, they should be grouped together by instrument using the id attribute values.

The offset element is used to indicate that the sound takes place offset from the current score position. If the sound element is a child of a direction element, the sound offset element overrides the direction offset element if both elements are present. Note that the offset reflects the intended musical position for the change in sound. It should not be used to compensate for latency issues in particular hardware configurations.
*/
case class Sound(soundsequence1: Seq[musicxml.SoundSequence1] = Nil,
  offset: Option[musicxml.Offset] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Musicu45dataOption1 {
  lazy val tempo = attributes.get("@tempo") map { _.as[BigDecimal]}
  lazy val dynamics = attributes.get("@dynamics") map { _.as[BigDecimal]}
  lazy val dacapo = attributes.get("@dacapo") map { _.as[Yesu45no]}
  lazy val segno = attributes.get("@segno") map { _.as[String]}
  lazy val dalsegno = attributes.get("@dalsegno") map { _.as[String]}
  lazy val coda = attributes.get("@coda") map { _.as[String]}
  lazy val tocoda = attributes.get("@tocoda") map { _.as[String]}
  lazy val divisions = attributes.get("@divisions") map { _.as[BigDecimal]}
  lazy val forwardu45repeat = attributes.get("@forward-repeat") map { _.as[Yesu45no]}
  lazy val fine = attributes.get("@fine") map { _.as[String]}
  lazy val timeu45only = attributes.get("@time-only") map { _.as[String]}
  lazy val pizzicato = attributes.get("@pizzicato") map { _.as[Yesu45no]}
  lazy val pan = attributes.get("@pan") map { _.as[BigDecimal]}
  lazy val elevation = attributes.get("@elevation") map { _.as[BigDecimal]}
  lazy val damperu45pedal = attributes.get("@damper-pedal") map { _.as[String]}
  lazy val softu45pedal = attributes.get("@soft-pedal") map { _.as[String]}
  lazy val sostenutou45pedal = attributes.get("@sostenuto-pedal") map { _.as[String]}
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      
      

case class SoundSequence1(midiu45device: Option[musicxml.Midiu45device] = None,
  midiu45instrument: Option[musicxml.Midiu45instrument] = None,
  play: Option[musicxml.Play] = None)
      


/** The staff-divide element represents the staff division arrow symbols found at SMuFL code points U+E00B, U+E00C, and U+E00D.
*/
case class Staffu45divide(attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Directionu45typeOption {
  lazy val typeValue = attributes("@type").as[Staffu45divideu45symbol]
  lazy val defaultu45x = attributes.get("@default-x") map { _.as[BigDecimal]}
  lazy val defaultu45y = attributes.get("@default-y") map { _.as[BigDecimal]}
  lazy val relativeu45x = attributes.get("@relative-x") map { _.as[BigDecimal]}
  lazy val relativeu45y = attributes.get("@relative-y") map { _.as[BigDecimal]}
  lazy val fontu45family = attributes.get("@font-family") map { _.as[String]}
  lazy val fontu45style = attributes.get("@font-style") map { _.as[Fontu45style]}
  lazy val fontu45size = attributes.get("@font-size") map { _.as[String]}
  lazy val fontu45weight = attributes.get("@font-weight") map { _.as[Fontu45weight]}
  lazy val color = attributes.get("@color") map { _.as[String]}
  lazy val halign = attributes.get("@halign") map { _.as[Leftu45centeru45right]}
  lazy val valign = attributes.get("@valign") map { _.as[Valign]}
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      
      


/** The stick type represents pictograms where the material of the stick, mallet, or beater is included.The parentheses and dashed-circle attributes indicate the presence of these marks around the round beater part of a pictogram. Values for these attributes are "no" if not present.
*/
case class Stick(sticku45type: musicxml.Sticku45type,
  sticku45material: musicxml.Sticku45material,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends PercussionTypeOption {
  lazy val tip = attributes.get("@tip") map { _.as[Tipu45direction]}
  lazy val parentheses = attributes.get("@parentheses") map { _.as[Yesu45no]}
  lazy val dashedu45circle = attributes.get("@dashed-circle") map { _.as[Yesu45no]}
}

      
      


/** The string-mute type represents string mute on and mute off symbols.
*/
case class Stringu45mute(attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Directionu45typeOption {
  lazy val typeValue = attributes("@type").as[Onu45off]
  lazy val defaultu45x = attributes.get("@default-x") map { _.as[BigDecimal]}
  lazy val defaultu45y = attributes.get("@default-y") map { _.as[BigDecimal]}
  lazy val relativeu45x = attributes.get("@relative-x") map { _.as[BigDecimal]}
  lazy val relativeu45y = attributes.get("@relative-y") map { _.as[BigDecimal]}
  lazy val fontu45family = attributes.get("@font-family") map { _.as[String]}
  lazy val fontu45style = attributes.get("@font-style") map { _.as[Fontu45style]}
  lazy val fontu45size = attributes.get("@font-size") map { _.as[String]}
  lazy val fontu45weight = attributes.get("@font-weight") map { _.as[Fontu45weight]}
  lazy val color = attributes.get("@color") map { _.as[String]}
  lazy val halign = attributes.get("@halign") map { _.as[Leftu45centeru45right]}
  lazy val valign = attributes.get("@valign") map { _.as[Valign]}
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      
      


/** The wedge type represents crescendo and diminuendo wedge symbols. The type attribute is crescendo for the start of a wedge that is closed at the left side, and diminuendo for the start of a wedge that is closed on the right side. Spread values are measured in tenths; those at the start of a crescendo wedge or end of a diminuendo wedge are ignored. The niente attribute is yes if a circle appears at the point of the wedge, indicating a crescendo from nothing or diminuendo to nothing. It is no by default, and used only when the type is crescendo, or the type is stop for a wedge that began with a diminuendo type. The line-type is solid by default.
*/
case class Wedge(attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Directionu45typeOption {
  lazy val typeValue = attributes("@type").as[Wedgeu45type]
  lazy val number = attributes.get("@number") map { _.as[BigInt]}
  lazy val spread = attributes.get("@spread") map { _.as[BigDecimal]}
  lazy val niente = attributes.get("@niente") map { _.as[Yesu45no]}
  lazy val lineu45type = attributes.get("@line-type") map { _.as[Lineu45type]}
  lazy val dashu45length = attributes.get("@dash-length") map { _.as[BigDecimal]}
  lazy val spaceu45length = attributes.get("@space-length") map { _.as[BigDecimal]}
  lazy val defaultu45x = attributes.get("@default-x") map { _.as[BigDecimal]}
  lazy val defaultu45y = attributes.get("@default-y") map { _.as[BigDecimal]}
  lazy val relativeu45x = attributes.get("@relative-x") map { _.as[BigDecimal]}
  lazy val relativeu45y = attributes.get("@relative-y") map { _.as[BigDecimal]}
  lazy val color = attributes.get("@color") map { _.as[String]}
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      
      


/** The encoding element contains information about who did the digital encoding, when, with what software, and in what aspects. Standard type values for the encoder element are music, words, and arrangement, but other types may be used. The type attribute is only needed when there are multiple encoder elements.
*/
case class Encoding(encodingoption: Seq[scalaxb.DataRecord[Any]] = Nil)
      
      

trait EncodingOption

/** Identification contains basic metadata about the score. It includes the information in MuseData headers that may apply at a score-wide, movement-wide, or part-wide level. The creator, rights, source, and relation elements are based on Dublin Core.
*/
case class Identification(creator: Seq[musicxml.Typedu45text] = Nil,
  rights: Seq[musicxml.Typedu45text] = Nil,
  encoding: Option[musicxml.Encoding] = None,
  source: Option[String] = None,
  relation: Seq[musicxml.Typedu45text] = Nil,
  miscellaneous: Option[musicxml.Miscellaneous] = None)
      
      


/** If a program has other metadata not yet supported in the MusicXML format, it can go in the miscellaneous element. The miscellaneous type puts each separate part of metadata into its own miscellaneous-field type.
*/
case class Miscellaneous(miscellaneousu45field: Seq[musicxml.Miscellaneousu45field] = Nil)
      
      


/** If a program has other metadata not yet supported in the MusicXML format, each type of metadata can go in a miscellaneous-field element. The required name attribute indicates the type of metadata the element content represents.
*/
case class Miscellaneousu45field(value: String,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val name = attributes("@name").as[String]
}

      
      


/** The supports type indicates if a MusicXML encoding supports a particular MusicXML element. This is recommended for elements like beam, stem, and accidental, where the absence of an element is ambiguous if you do not know if the encoding supports that element. For Version 2.0, the supports element is expanded to allow programs to indicate support for particular attributes or particular values. This lets applications communicate, for example, that all system and/or page breaks are contained in the MusicXML file.
*/
case class Supports(attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val typeValue = attributes("@type").as[Yesu45no]
  lazy val element = attributes("@element").as[String]
  lazy val attribute = attributes.get("@attribute") map { _.as[String]}
  lazy val valueAttribute = attributes.get("@value") map { _.as[String]}
}

      
      


/** The appearance type controls general graphical settings for the music's final form appearance on a printed page of display. This includes support for line widths, definitions for note sizes, and standard distances between notation elements, plus an extension element for other aspects of appearance.
*/
case class Appearance(lineu45width: Seq[musicxml.Lineu45width] = Nil,
  noteu45size: Seq[musicxml.Noteu45size] = Nil,
  distance: Seq[musicxml.Distance] = Nil,
  glyph: Seq[musicxml.Glyph] = Nil,
  otheru45appearance: Seq[musicxml.Otheru45appearance] = Nil)
      
      


/** The distance element represents standard distances between notation elements in tenths. The type attribute defines what type of distance is being defined. Valid values include hyphen (for hyphens in lyrics) and beam.
*/
case class Distance(value: BigDecimal,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val typeValue = attributes("@type").as[String]
}

      
      


/** The glyph element represents what SMuFL glyph should be used for different variations of symbols that are semantically identical. The type attribute specifies what type of glyph is being defined. The element value specifies what SMuFL glyph to use, including recommended stylistic alternates. The SMuFL glyph name should match the type. For instance, a type of quarter-rest would use values restQuarter, restQuarterOld, or restQuarterZ. A type of g-clef-ottava-bassa would use values gClef8vb, gClef8vbOld, or gClef8vbCClef. A type of octave-shift-up-8 would use values ottava, ottavaBassa, ottavaBassaBa, ottavaBassaVb, or octaveBassa.
*/
case class Glyph(value: String,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val typeValue = attributes("@type").as[String]
}

      
      


/** The line-width type indicates the width of a line type in tenths. The type attribute defines what type of line is being defined. Values include beam, bracket, dashes, enclosure, ending, extend, heavy barline, leger, light barline, octave shift, pedal, slur middle, slur tip, staff, stem, tie middle, tie tip, tuplet bracket, and wedge. The text content is expressed in tenths.
*/
case class Lineu45width(value: BigDecimal,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val typeValue = attributes("@type").as[String]
}

      
      


/** The measure-layout type includes the horizontal distance from the previous measure.
*/
case class Measureu45layout(measureu45distance: Option[BigDecimal] = None)
      
      


/** The note-size type indicates the percentage of the regular note size to use for notes with a cue and large size as defined in the type element. The grace type is used for notes of cue size that that include a grace element. The cue type is used for all other notes with cue size, whether defined explicitly or implicitly via a cue element. The large type is used for notes of large size. The text content represent the numeric percentage. A value of 100 would be identical to the size of a regular note as defined by the music font.
*/
case class Noteu45size(value: BigDecimal,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val typeValue = attributes("@type").as[Noteu45sizeu45type]
}

      
      


/** The other-appearance type is used to define any graphical settings not yet in the current version of the MusicXML format. This allows extended representation, though without application interoperability.
*/
case class Otheru45appearance(value: String,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val typeValue = attributes("@type").as[String]
}

      
      


/** Page layout can be defined both in score-wide defaults and in the print element. Page margins are specified either for both even and odd pages, or via separate odd and even page number values. The type is not needed when used as part of a print element. If omitted when used in the defaults element, "both" is the default.
*/
case class Pageu45layout(pageu45layoutsequence1: Option[musicxml.Pageu45layoutSequence1] = None,
  pageu45margins: Seq[musicxml.Pageu45margins] = Nil)
      
      

case class Pageu45layoutSequence1(pageu45height: BigDecimal,
  pageu45width: BigDecimal)
      


/** Page margins are specified either for both even and odd pages, or via separate odd and even page number values. The type attribute is not needed when used as part of a print element. If omitted when the page-margins type is used in the defaults element, "both" is the default value.
*/
case class Pageu45margins(allu45marginsSequence1: musicxml.Allu45marginsSequence,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val typeValue = attributes.get("@type") map { _.as[Marginu45type]}
}

      
      


/** Margins, page sizes, and distances are all measured in tenths to keep MusicXML data in a consistent coordinate system as much as possible. The translation to absolute units is done with the scaling type, which specifies how many millimeters are equal to how many tenths. For a staff height of 7 mm, millimeters would be set to 7 while tenths is set to 40. The ability to set a formula rather than a single scaling factor helps avoid roundoff errors.
*/
case class Scaling(millimeters: BigDecimal,
  tenths: BigDecimal)
      
      


/** Staff layout includes the vertical distance from the bottom line of the previous staff in this system to the top line of the staff specified by the number attribute. The optional number attribute refers to staff numbers within the part, from top to bottom on the system. A value of 1 is assumed if not present. When used in the defaults element, the values apply to all parts. This value is ignored for the first staff in a system.
*/
case class Staffu45layout(staffu45distance: Option[BigDecimal] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val number = attributes.get("@number") map { _.as[BigInt]}
}

      
      


/** The system-dividers element indicates the presence or absence of system dividers (also known as system separation marks) between systems displayed on the same page. Dividers on the left and right side of the page are controlled by the left-divider and right-divider elements respectively. The default vertical position is half the system-distance value from the top of the system that is below the divider. The default horizontal position is the left and right system margin, respectively.

When used in the print element, the system-dividers element affects the dividers that would appear between the current system and the previous system.
*/
case class Systemu45dividers(leftu45divider: musicxml.Emptyu45printu45objectu45styleu45align,
  rightu45divider: musicxml.Emptyu45printu45objectu45styleu45align)
      
      


/** A system is a group of staves that are read and played simultaneously. System layout includes left and right margins and the vertical distance from the previous system. The system distance is measured from the bottom line of the previous system to the top line of the current system. It is ignored for the first system on a page. The top system distance is measured from the page's top margin to the top line of the first system. It is ignored for all but the first system on a page.

Sometimes the sum of measure widths in a system may not equal the system width specified by the layout elements due to roundoff or other errors. The behavior when reading MusicXML files in these cases is application-dependent. For instance, applications may find that the system layout data is more reliable than the sum of the measure widths, and adjust the measure widths accordingly.
*/
case class Systemu45layout(systemu45margins: Option[musicxml.Systemu45margins] = None,
  systemu45distance: Option[BigDecimal] = None,
  topu45systemu45distance: Option[BigDecimal] = None,
  systemu45dividers: Option[musicxml.Systemu45dividers] = None)
      
      


/** System margins are relative to the page margins. Positive values indent and negative values reduce the margin size.
*/
case class Systemu45margins(leftu45rightu45marginsSequence1: musicxml.Leftu45rightu45marginsSequence)
      
      


/** The bookmark type serves as a well-defined target for an incoming simple XLink.
*/
case class Bookmark(attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Musicu45dataOption1 {
  lazy val id = attributes("@id").as[String]
  lazy val name = attributes.get("@name") map { _.as[String]}
  lazy val element = attributes.get("@element") map { _.as[String]}
  lazy val position = attributes.get("@position") map { _.as[BigInt]}
}

      
      


/** The link type serves as an outgoing simple XLink. It is also used to connect a MusicXML score with a MusicXML opus. If a relative link is used within a document that is part of a compressed MusicXML file, the link is relative to the  root folder of the zip file.
*/
case class Link(attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Musicu45dataOption1 {
  lazy val xlinkhref = attributes("@{http://www.w3.org/1999/xlink}href").as[java.net.URI]
  lazy val xlinktype = attributes("@{http://www.w3.org/1999/xlink}type").as[Type]
  lazy val xlinkrole = attributes.get("@{http://www.w3.org/1999/xlink}role") map { _.as[String]}
  lazy val xlinktitle = attributes.get("@{http://www.w3.org/1999/xlink}title") map { _.as[String]}
  lazy val xlinkshow = attributes("@{http://www.w3.org/1999/xlink}show").as[Show]
  lazy val xlinkactuate = attributes("@{http://www.w3.org/1999/xlink}actuate").as[Actuate]
  lazy val name = attributes.get("@name") map { _.as[String]}
  lazy val element = attributes.get("@element") map { _.as[String]}
  lazy val position = attributes.get("@position") map { _.as[BigInt]}
  lazy val defaultu45x = attributes.get("@default-x") map { _.as[BigDecimal]}
  lazy val defaultu45y = attributes.get("@default-y") map { _.as[BigDecimal]}
  lazy val relativeu45x = attributes.get("@relative-x") map { _.as[BigDecimal]}
  lazy val relativeu45y = attributes.get("@relative-y") map { _.as[BigDecimal]}
}

      
      


/** The accidental type represents actual notated accidentals. Editorial and cautionary indications are indicated by attributes. Values for these attributes are "no" if not present. Specific graphic display such as parentheses, brackets, and size are controlled by the level-display attribute group.
*/
case class Accidental(value: musicxml.Accidentalu45value,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val cautionary = attributes.get("@cautionary") map { _.as[Yesu45no]}
  lazy val editorial = attributes.get("@editorial") map { _.as[Yesu45no]}
  lazy val parentheses = attributes.get("@parentheses") map { _.as[Yesu45no]}
  lazy val bracket = attributes.get("@bracket") map { _.as[Yesu45no]}
  lazy val size = attributes.get("@size") map { _.as[Symbolu45size]}
  lazy val defaultu45x = attributes.get("@default-x") map { _.as[BigDecimal]}
  lazy val defaultu45y = attributes.get("@default-y") map { _.as[BigDecimal]}
  lazy val relativeu45x = attributes.get("@relative-x") map { _.as[BigDecimal]}
  lazy val relativeu45y = attributes.get("@relative-y") map { _.as[BigDecimal]}
  lazy val fontu45family = attributes.get("@font-family") map { _.as[String]}
  lazy val fontu45style = attributes.get("@font-style") map { _.as[Fontu45style]}
  lazy val fontu45size = attributes.get("@font-size") map { _.as[String]}
  lazy val fontu45weight = attributes.get("@font-weight") map { _.as[Fontu45weight]}
  lazy val color = attributes.get("@color") map { _.as[String]}
  lazy val smufl = attributes.get("@smufl") map { _.as[String]}
}

      
      


/** An accidental-mark can be used as a separate notation or as part of an ornament. When used in an ornament, position and placement are relative to the ornament, not relative to the note.
*/
case class Accidentalu45mark(value: musicxml.Accidentalu45value,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends NotationsOption {
  lazy val parentheses = attributes.get("@parentheses") map { _.as[Yesu45no]}
  lazy val bracket = attributes.get("@bracket") map { _.as[Yesu45no]}
  lazy val size = attributes.get("@size") map { _.as[Symbolu45size]}
  lazy val defaultu45x = attributes.get("@default-x") map { _.as[BigDecimal]}
  lazy val defaultu45y = attributes.get("@default-y") map { _.as[BigDecimal]}
  lazy val relativeu45x = attributes.get("@relative-x") map { _.as[BigDecimal]}
  lazy val relativeu45y = attributes.get("@relative-y") map { _.as[BigDecimal]}
  lazy val fontu45family = attributes.get("@font-family") map { _.as[String]}
  lazy val fontu45style = attributes.get("@font-style") map { _.as[Fontu45style]}
  lazy val fontu45size = attributes.get("@font-size") map { _.as[String]}
  lazy val fontu45weight = attributes.get("@font-weight") map { _.as[Fontu45weight]}
  lazy val color = attributes.get("@color") map { _.as[String]}
  lazy val placement = attributes.get("@placement") map { _.as[Aboveu45below]}
  lazy val smufl = attributes.get("@smufl") map { _.as[String]}
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      
      


/** The arpeggiate type indicates that this note is part of an arpeggiated chord. The number attribute can be used to distinguish between two simultaneous chords arpeggiated separately (different numbers) or together (same number). The up-down attribute is used if there is an arrow on the arpeggio sign. By default, arpeggios go from the lowest to highest note.
*/
case class Arpeggiate(attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends NotationsOption {
  lazy val number = attributes.get("@number") map { _.as[BigInt]}
  lazy val direction = attributes.get("@direction") map { _.as[Upu45down]}
  lazy val defaultu45x = attributes.get("@default-x") map { _.as[BigDecimal]}
  lazy val defaultu45y = attributes.get("@default-y") map { _.as[BigDecimal]}
  lazy val relativeu45x = attributes.get("@relative-x") map { _.as[BigDecimal]}
  lazy val relativeu45y = attributes.get("@relative-y") map { _.as[BigDecimal]}
  lazy val placement = attributes.get("@placement") map { _.as[Aboveu45below]}
  lazy val color = attributes.get("@color") map { _.as[String]}
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      
      


/** Articulations and accents are grouped together here.
*/
case class Articulations(articulationsoption: Seq[scalaxb.DataRecord[musicxml.ArticulationsOption]] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends NotationsOption {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      
      

trait ArticulationsOption

/** The arrow element represents an arrow used for a musical technical indication. It can represent both Unicode and SMuFL arrows. The presence of an arrowhead element indicates that only the arrowhead is displayed, not the arrow stem. The smufl attribute distinguishes different SMuFL glyphs that have an arrow appearance such as arrowBlackUp, guitarStrumUp, or handbellsSwingUp. The specified glyph should match the descriptive representation.
*/
case class ArrowType(arrowtypeoption: scalaxb.DataRecord[Any],
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends TechnicalOption {
  lazy val defaultu45x = attributes.get("@default-x") map { _.as[BigDecimal]}
  lazy val defaultu45y = attributes.get("@default-y") map { _.as[BigDecimal]}
  lazy val relativeu45x = attributes.get("@relative-x") map { _.as[BigDecimal]}
  lazy val relativeu45y = attributes.get("@relative-y") map { _.as[BigDecimal]}
  lazy val fontu45family = attributes.get("@font-family") map { _.as[String]}
  lazy val fontu45style = attributes.get("@font-style") map { _.as[Fontu45style]}
  lazy val fontu45size = attributes.get("@font-size") map { _.as[String]}
  lazy val fontu45weight = attributes.get("@font-weight") map { _.as[Fontu45weight]}
  lazy val color = attributes.get("@color") map { _.as[String]}
  lazy val placement = attributes.get("@placement") map { _.as[Aboveu45below]}
  lazy val smufl = attributes.get("@smufl") map { _.as[String]}
}

      
      

trait ArrowTypeOption
case class ArrowTypeSequence1(arrowu45direction: musicxml.Arrowu45direction,
  arrowu45style: Option[musicxml.Arrowu45style] = None,
  arrowhead: Option[musicxml.Empty] = None) extends ArrowTypeOption
      


/** The backup and forward elements are required to coordinate multiple voices in one part, including music on multiple staves. The backup type is generally used to move between voices and staves. Thus the backup element does not include voice or staff elements. Duration values should always be positive, and should not cross measure boundaries or mid-measure changes in the divisions value.
*/
case class Backup(durationSequence1: musicxml.DurationSequence,
  editorialSequence2: musicxml.EditorialSequence) extends Musicu45dataOption1
      
      


/** Beam values include begin, continue, end, forward hook, and backward hook. Up to eight concurrent beams are available to cover up to 1024th notes. Each beam in a note is represented with a separate beam element, starting with the eighth note beam using a number attribute of 1.

Note that the beam number does not distinguish sets of beams that overlap, as it does for slur and other elements. Beaming groups are distinguished by being in different voices and/or the presence or absence of grace and cue elements.

Beams that have a begin value can also have a fan attribute to indicate accelerandos and ritardandos using fanned beams. The fan attribute may also be used with a continue value if the fanning direction changes on that note. The value is "none" if not specified.

The repeater attribute has been deprecated in MusicXML 3.0. Formerly used for tremolos, it needs to be specified with a "yes" value for each beam using it.
*/
case class Beam(value: musicxml.Beamu45value,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val number = attributes("@number").as[BigInt]
  lazy val repeater = attributes.get("@repeater") map { _.as[Yesu45no]}
  lazy val fan = attributes.get("@fan") map { _.as[Fan]}
  lazy val color = attributes.get("@color") map { _.as[String]}
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      
      


/** The bend type is used in guitar and tablature. The bend-alter element indicates the number of steps in the bend, similar to the alter element. As with the alter element, numbers like 0.5 can be used to indicate microtones. Negative numbers indicate pre-bends or releases; the pre-bend and release elements are used to distinguish what is intended. A with-bar element indicates that the bend is to be done at the bridge with a whammy or vibrato bar. The content of the element indicates how this should be notated.
*/
case class Bend(bendu45alter: BigDecimal,
  bendoption: Option[scalaxb.DataRecord[musicxml.BendOption]] = None,
  withu45bar: Option[musicxml.Placementu45text] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends TechnicalOption {
  lazy val defaultu45x = attributes.get("@default-x") map { _.as[BigDecimal]}
  lazy val defaultu45y = attributes.get("@default-y") map { _.as[BigDecimal]}
  lazy val relativeu45x = attributes.get("@relative-x") map { _.as[BigDecimal]}
  lazy val relativeu45y = attributes.get("@relative-y") map { _.as[BigDecimal]}
  lazy val fontu45family = attributes.get("@font-family") map { _.as[String]}
  lazy val fontu45style = attributes.get("@font-style") map { _.as[Fontu45style]}
  lazy val fontu45size = attributes.get("@font-size") map { _.as[String]}
  lazy val fontu45weight = attributes.get("@font-weight") map { _.as[Fontu45weight]}
  lazy val color = attributes.get("@color") map { _.as[String]}
  lazy val accelerate = attributes.get("@accelerate") map { _.as[Yesu45no]}
  lazy val beats = attributes.get("@beats") map { _.as[BigDecimal]}
  lazy val firstu45beat = attributes.get("@first-beat") map { _.as[BigDecimal]}
  lazy val lastu45beat = attributes.get("@last-beat") map { _.as[BigDecimal]}
}

      
      

trait BendOption

/** The breath-mark element indicates a place to take a breath.
*/
case class Breathu45mark(value: musicxml.Breathu45marku45value,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends ArticulationsOption {
  lazy val defaultu45x = attributes.get("@default-x") map { _.as[BigDecimal]}
  lazy val defaultu45y = attributes.get("@default-y") map { _.as[BigDecimal]}
  lazy val relativeu45x = attributes.get("@relative-x") map { _.as[BigDecimal]}
  lazy val relativeu45y = attributes.get("@relative-y") map { _.as[BigDecimal]}
  lazy val fontu45family = attributes.get("@font-family") map { _.as[String]}
  lazy val fontu45style = attributes.get("@font-style") map { _.as[Fontu45style]}
  lazy val fontu45size = attributes.get("@font-size") map { _.as[String]}
  lazy val fontu45weight = attributes.get("@font-weight") map { _.as[Fontu45weight]}
  lazy val color = attributes.get("@color") map { _.as[String]}
  lazy val placement = attributes.get("@placement") map { _.as[Aboveu45below]}
}

      
      


/** The caesura element indicates a slight pause. It is notated using a "railroad tracks" symbol or other variations specified in the element content.
*/
case class Caesura(value: musicxml.Caesurau45value,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends ArticulationsOption {
  lazy val defaultu45x = attributes.get("@default-x") map { _.as[BigDecimal]}
  lazy val defaultu45y = attributes.get("@default-y") map { _.as[BigDecimal]}
  lazy val relativeu45x = attributes.get("@relative-x") map { _.as[BigDecimal]}
  lazy val relativeu45y = attributes.get("@relative-y") map { _.as[BigDecimal]}
  lazy val fontu45family = attributes.get("@font-family") map { _.as[String]}
  lazy val fontu45style = attributes.get("@font-style") map { _.as[Fontu45style]}
  lazy val fontu45size = attributes.get("@font-size") map { _.as[String]}
  lazy val fontu45weight = attributes.get("@font-weight") map { _.as[Fontu45weight]}
  lazy val color = attributes.get("@color") map { _.as[String]}
  lazy val placement = attributes.get("@placement") map { _.as[Aboveu45below]}
}

      
      


/** The elision type represents an elision between lyric syllables. The text content specifies the symbol used to display the elision. Common values are a no-break space (Unicode 00A0), an underscore (Unicode 005F), or an undertie (Unicode 203F). If the text content is empty, the smufl attribute is used to specify the symbol to use. Its value is a SMuFL canonical glyph name that starts with lyrics. The SMuFL attribute is ignored if the elision glyph is already specified by the text content. If neither text content nor a smufl attribute are present, the elision glyph is application-specific.
*/
case class Elision(value: String,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val fontu45family = attributes.get("@font-family") map { _.as[String]}
  lazy val fontu45style = attributes.get("@font-style") map { _.as[Fontu45style]}
  lazy val fontu45size = attributes.get("@font-size") map { _.as[String]}
  lazy val fontu45weight = attributes.get("@font-weight") map { _.as[Fontu45weight]}
  lazy val color = attributes.get("@color") map { _.as[String]}
  lazy val smufl = attributes.get("@smufl") map { _.as[String]}
}

      
      


/** The empty-line type represents an empty element with line-shape, line-type, line-length, dashed-formatting, print-style and placement attributes.
*/
case class Emptyu45line(attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends ArticulationsOption {
  lazy val lineu45shape = attributes.get("@line-shape") map { _.as[Lineu45shape]}
  lazy val lineu45type = attributes.get("@line-type") map { _.as[Lineu45type]}
  lazy val lineu45length = attributes.get("@line-length") map { _.as[Lineu45length]}
  lazy val dashu45length = attributes.get("@dash-length") map { _.as[BigDecimal]}
  lazy val spaceu45length = attributes.get("@space-length") map { _.as[BigDecimal]}
  lazy val defaultu45x = attributes.get("@default-x") map { _.as[BigDecimal]}
  lazy val defaultu45y = attributes.get("@default-y") map { _.as[BigDecimal]}
  lazy val relativeu45x = attributes.get("@relative-x") map { _.as[BigDecimal]}
  lazy val relativeu45y = attributes.get("@relative-y") map { _.as[BigDecimal]}
  lazy val fontu45family = attributes.get("@font-family") map { _.as[String]}
  lazy val fontu45style = attributes.get("@font-style") map { _.as[Fontu45style]}
  lazy val fontu45size = attributes.get("@font-size") map { _.as[String]}
  lazy val fontu45weight = attributes.get("@font-weight") map { _.as[Fontu45weight]}
  lazy val color = attributes.get("@color") map { _.as[String]}
  lazy val placement = attributes.get("@placement") map { _.as[Aboveu45below]}
}

      
      


/** The extend type represents lyric word extension / melisma lines as well as figured bass extensions. The optional type and position attributes are added in Version 3.0 to provide better formatting control.
*/
case class Extend(attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends LyricOption {
  lazy val typeValue = attributes.get("@type") map { _.as[Startu45stopu45continue]}
  lazy val defaultu45x = attributes.get("@default-x") map { _.as[BigDecimal]}
  lazy val defaultu45y = attributes.get("@default-y") map { _.as[BigDecimal]}
  lazy val relativeu45x = attributes.get("@relative-x") map { _.as[BigDecimal]}
  lazy val relativeu45y = attributes.get("@relative-y") map { _.as[BigDecimal]}
  lazy val color = attributes.get("@color") map { _.as[String]}
}

      
      


/** The figure type represents a single figure within a figured-bass element.
*/
case class Figure(prefix: Option[musicxml.Styleu45text] = None,
  figureu45number: Option[musicxml.Styleu45text] = None,
  suffix: Option[musicxml.Styleu45text] = None,
  extend: Option[musicxml.Extend] = None,
  editorialSequence5: musicxml.EditorialSequence)
      
      


/** The figured-bass element represents figured bass notation. Figured bass elements take their position from the first regular note (not a grace note or chord note) that follows in score order. The optional duration element is used to indicate changes of figures under a note.

Figures are ordered from top to bottom. The value of parentheses is "no" if not present.
*/
case class Figuredu45bass(figure: Seq[musicxml.Figure] = Nil,
  durationSequence2: Option[musicxml.DurationSequence] = None,
  editorialSequence3: musicxml.EditorialSequence,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Musicu45dataOption1 {
  lazy val defaultu45x = attributes.get("@default-x") map { _.as[BigDecimal]}
  lazy val defaultu45y = attributes.get("@default-y") map { _.as[BigDecimal]}
  lazy val relativeu45x = attributes.get("@relative-x") map { _.as[BigDecimal]}
  lazy val relativeu45y = attributes.get("@relative-y") map { _.as[BigDecimal]}
  lazy val fontu45family = attributes.get("@font-family") map { _.as[String]}
  lazy val fontu45style = attributes.get("@font-style") map { _.as[Fontu45style]}
  lazy val fontu45size = attributes.get("@font-size") map { _.as[String]}
  lazy val fontu45weight = attributes.get("@font-weight") map { _.as[Fontu45weight]}
  lazy val color = attributes.get("@color") map { _.as[String]}
  lazy val printu45object = attributes.get("@print-object") map { _.as[Yesu45no]}
  lazy val printu45dot = attributes.get("@print-dot") map { _.as[Yesu45no]}
  lazy val printu45spacing = attributes.get("@print-spacing") map { _.as[Yesu45no]}
  lazy val printu45lyric = attributes.get("@print-lyric") map { _.as[Yesu45no]}
  lazy val parentheses = attributes.get("@parentheses") map { _.as[Yesu45no]}
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      
      


/** The backup and forward elements are required to coordinate multiple voices in one part, including music on multiple staves. The forward element is generally used within voices and staves. Duration values should always be positive, and should not cross measure boundaries or mid-measure changes in the divisions value.
*/
case class Forward(durationSequence1: musicxml.DurationSequence,
  editorialu45voiceSequence2: musicxml.Editorialu45voiceSequence,
  staffSequence3: Option[musicxml.StaffSequence] = None) extends Musicu45dataOption1
      
      


/** Glissando and slide types both indicate rapidly moving from one pitch to the other so that individual notes are not discerned. The distinction is similar to that between NIFF's glissando and portamento elements. A glissando sounds the half notes in between the slide and defaults to a wavy line. The optional text is printed alongside the line.
*/
case class Glissando(value: String,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends NotationsOption {
  lazy val typeValue = attributes("@type").as[Startu45stop]
  lazy val number = attributes("@number").as[BigInt]
  lazy val lineu45type = attributes.get("@line-type") map { _.as[Lineu45type]}
  lazy val dashu45length = attributes.get("@dash-length") map { _.as[BigDecimal]}
  lazy val spaceu45length = attributes.get("@space-length") map { _.as[BigDecimal]}
  lazy val defaultu45x = attributes.get("@default-x") map { _.as[BigDecimal]}
  lazy val defaultu45y = attributes.get("@default-y") map { _.as[BigDecimal]}
  lazy val relativeu45x = attributes.get("@relative-x") map { _.as[BigDecimal]}
  lazy val relativeu45y = attributes.get("@relative-y") map { _.as[BigDecimal]}
  lazy val fontu45family = attributes.get("@font-family") map { _.as[String]}
  lazy val fontu45style = attributes.get("@font-style") map { _.as[Fontu45style]}
  lazy val fontu45size = attributes.get("@font-size") map { _.as[String]}
  lazy val fontu45weight = attributes.get("@font-weight") map { _.as[Fontu45weight]}
  lazy val color = attributes.get("@color") map { _.as[String]}
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      
      


/** The grace type indicates the presence of a grace note. The slash attribute for a grace note is yes for slashed eighth notes. The other grace note attributes come from MuseData sound suggestions. The steal-time-previous attribute indicates the percentage of time to steal from the previous note for the grace note. The steal-time-following attribute indicates the percentage of time to steal from the following note for the grace note, as for appoggiaturas. The make-time attribute indicates to make time, not steal time; the units are in real-time divisions for the grace note.
*/
case class Grace(attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val stealu45timeu45previous = attributes.get("@steal-time-previous") map { _.as[BigDecimal]}
  lazy val stealu45timeu45following = attributes.get("@steal-time-following") map { _.as[BigDecimal]}
  lazy val makeu45time = attributes.get("@make-time") map { _.as[BigDecimal]}
  lazy val slash = attributes.get("@slash") map { _.as[Yesu45no]}
}

      
      


/** The hammer-on and pull-off elements are used in guitar and fretted instrument notation. Since a single slur can be marked over many notes, the hammer-on and pull-off elements are separate so the individual pair of notes can be specified. The element content can be used to specify how the hammer-on or pull-off should be notated. An empty element leaves this choice up to the application.
*/
case class Hammeru45onu45pullu45off(value: String,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends TechnicalOption {
  lazy val typeValue = attributes("@type").as[Startu45stop]
  lazy val number = attributes("@number").as[BigInt]
  lazy val defaultu45x = attributes.get("@default-x") map { _.as[BigDecimal]}
  lazy val defaultu45y = attributes.get("@default-y") map { _.as[BigDecimal]}
  lazy val relativeu45x = attributes.get("@relative-x") map { _.as[BigDecimal]}
  lazy val relativeu45y = attributes.get("@relative-y") map { _.as[BigDecimal]}
  lazy val fontu45family = attributes.get("@font-family") map { _.as[String]}
  lazy val fontu45style = attributes.get("@font-style") map { _.as[Fontu45style]}
  lazy val fontu45size = attributes.get("@font-size") map { _.as[String]}
  lazy val fontu45weight = attributes.get("@font-weight") map { _.as[Fontu45weight]}
  lazy val color = attributes.get("@color") map { _.as[String]}
  lazy val placement = attributes.get("@placement") map { _.as[Aboveu45below]}
}

      
      


/** The handbell element represents notation for various techniques used in handbell and handchime music.
*/
case class Handbell(value: musicxml.Handbellu45value,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends TechnicalOption {
  lazy val defaultu45x = attributes.get("@default-x") map { _.as[BigDecimal]}
  lazy val defaultu45y = attributes.get("@default-y") map { _.as[BigDecimal]}
  lazy val relativeu45x = attributes.get("@relative-x") map { _.as[BigDecimal]}
  lazy val relativeu45y = attributes.get("@relative-y") map { _.as[BigDecimal]}
  lazy val fontu45family = attributes.get("@font-family") map { _.as[String]}
  lazy val fontu45style = attributes.get("@font-style") map { _.as[Fontu45style]}
  lazy val fontu45size = attributes.get("@font-size") map { _.as[String]}
  lazy val fontu45weight = attributes.get("@font-weight") map { _.as[Fontu45weight]}
  lazy val color = attributes.get("@color") map { _.as[String]}
  lazy val placement = attributes.get("@placement") map { _.as[Aboveu45below]}
}

      
      


/** The harmon-closed type represents whether the harmon mute is closed, open, or half-open. The optional location attribute indicates which portion of the symbol is filled in when the element value is half.
*/
case class Harmonu45closed(value: musicxml.Harmonu45closedu45value,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val location = attributes.get("@location") map { _.as[Harmonu45closedu45location]}
}

      
      


/** The harmon-mute type represents the symbols used for harmon mutes in brass notation.
*/
case class Harmonu45mute(harmonu45closed: musicxml.Harmonu45closed,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends TechnicalOption {
  lazy val defaultu45x = attributes.get("@default-x") map { _.as[BigDecimal]}
  lazy val defaultu45y = attributes.get("@default-y") map { _.as[BigDecimal]}
  lazy val relativeu45x = attributes.get("@relative-x") map { _.as[BigDecimal]}
  lazy val relativeu45y = attributes.get("@relative-y") map { _.as[BigDecimal]}
  lazy val fontu45family = attributes.get("@font-family") map { _.as[String]}
  lazy val fontu45style = attributes.get("@font-style") map { _.as[Fontu45style]}
  lazy val fontu45size = attributes.get("@font-size") map { _.as[String]}
  lazy val fontu45weight = attributes.get("@font-weight") map { _.as[Fontu45weight]}
  lazy val color = attributes.get("@color") map { _.as[String]}
  lazy val placement = attributes.get("@placement") map { _.as[Aboveu45below]}
}

      
      


/** The harmonic type indicates natural and artificial harmonics. Allowing the type of pitch to be specified, combined with controls for appearance/playback differences, allows both the notation and the sound to be represented. Artificial harmonics can add a notated touching-pitch; artificial pinch harmonics will usually not notate a touching pitch. The attributes for the harmonic element refer to the use of the circular harmonic symbol, typically but not always used with natural harmonics.
*/
case class Harmonic(harmonicoption: Option[scalaxb.DataRecord[musicxml.HarmonicOption]] = None,
  harmonicoption2: Option[scalaxb.DataRecord[musicxml.HarmonicOption2]] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends TechnicalOption {
  lazy val printu45object = attributes.get("@print-object") map { _.as[Yesu45no]}
  lazy val defaultu45x = attributes.get("@default-x") map { _.as[BigDecimal]}
  lazy val defaultu45y = attributes.get("@default-y") map { _.as[BigDecimal]}
  lazy val relativeu45x = attributes.get("@relative-x") map { _.as[BigDecimal]}
  lazy val relativeu45y = attributes.get("@relative-y") map { _.as[BigDecimal]}
  lazy val fontu45family = attributes.get("@font-family") map { _.as[String]}
  lazy val fontu45style = attributes.get("@font-style") map { _.as[Fontu45style]}
  lazy val fontu45size = attributes.get("@font-size") map { _.as[String]}
  lazy val fontu45weight = attributes.get("@font-weight") map { _.as[Fontu45weight]}
  lazy val color = attributes.get("@color") map { _.as[String]}
  lazy val placement = attributes.get("@placement") map { _.as[Aboveu45below]}
}

      
      

trait HarmonicOption
trait HarmonicOption2

/** The heel and toe elements are used with organ pedals. The substitution value is "no" if the attribute is not present.
*/
case class Heelu45toe(attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Emptyu45placementable with TechnicalOption {
  lazy val defaultu45x = attributes.get("@default-x") map { _.as[BigDecimal]}
  lazy val defaultu45y = attributes.get("@default-y") map { _.as[BigDecimal]}
  lazy val relativeu45x = attributes.get("@relative-x") map { _.as[BigDecimal]}
  lazy val relativeu45y = attributes.get("@relative-y") map { _.as[BigDecimal]}
  lazy val fontu45family = attributes.get("@font-family") map { _.as[String]}
  lazy val fontu45style = attributes.get("@font-style") map { _.as[Fontu45style]}
  lazy val fontu45size = attributes.get("@font-size") map { _.as[String]}
  lazy val fontu45weight = attributes.get("@font-weight") map { _.as[Fontu45weight]}
  lazy val color = attributes.get("@color") map { _.as[String]}
  lazy val placement = attributes.get("@placement") map { _.as[Aboveu45below]}
  lazy val substitution = attributes.get("@substitution") map { _.as[Yesu45no]}
}

      
      


/** The hole type represents the symbols used for woodwind and brass fingerings as well as other notations.
*/
case class Hole(holeu45type: Option[String] = None,
  holeu45closed: musicxml.Holeu45closed,
  holeu45shape: Option[String] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends TechnicalOption {
  lazy val defaultu45x = attributes.get("@default-x") map { _.as[BigDecimal]}
  lazy val defaultu45y = attributes.get("@default-y") map { _.as[BigDecimal]}
  lazy val relativeu45x = attributes.get("@relative-x") map { _.as[BigDecimal]}
  lazy val relativeu45y = attributes.get("@relative-y") map { _.as[BigDecimal]}
  lazy val fontu45family = attributes.get("@font-family") map { _.as[String]}
  lazy val fontu45style = attributes.get("@font-style") map { _.as[Fontu45style]}
  lazy val fontu45size = attributes.get("@font-size") map { _.as[String]}
  lazy val fontu45weight = attributes.get("@font-weight") map { _.as[Fontu45weight]}
  lazy val color = attributes.get("@color") map { _.as[String]}
  lazy val placement = attributes.get("@placement") map { _.as[Aboveu45below]}
}

      
      


/** The hole-closed type represents whether the hole is closed, open, or half-open. The optional location attribute indicates which portion of the hole is filled in when the element value is half.
*/
case class Holeu45closed(value: musicxml.Holeu45closedu45value,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val location = attributes.get("@location") map { _.as[Holeu45closedu45location]}
}

      
      


/** The instrument type distinguishes between score-instrument elements in a score-part. The id attribute is an IDREF back to the score-instrument ID. If multiple score-instruments are specified on a score-part, there should be an instrument element for each note in the part.
*/
case class Instrument(attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val id = attributes("@id").as[String]
}

      
      


/** The lyric type represents text underlays for lyrics, based on Humdrum with support for other formats. Two text elements that are not separated by an elision element are part of the same syllable, but may have different text formatting. The MusicXML XSD is more strict than the DTD in enforcing this by disallowing a second syllabic element unless preceded by an elision element. The lyric number indicates multiple lines, though a name can be used as well (as in Finale's verse / chorus / section specification). 

Justification is center by default; placement is below by default. The print-object attribute can override a note's print-lyric attribute in cases where only some lyrics on a note are printed, as when lyrics for later verses are printed in a block of text rather than with each note. The time-only attribute precisely specifies which lyrics are to be sung which time through a repeated section.
*/
case class Lyric(lyricoption: scalaxb.DataRecord[musicxml.LyricOption],
  endu45line: Option[musicxml.Empty] = None,
  endu45paragraph: Option[musicxml.Empty] = None,
  editorialSequence4: musicxml.EditorialSequence,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val number = attributes.get("@number") map { _.as[String]}
  lazy val name = attributes.get("@name") map { _.as[String]}
  lazy val justify = attributes.get("@justify") map { _.as[Leftu45centeru45right]}
  lazy val defaultu45x = attributes.get("@default-x") map { _.as[BigDecimal]}
  lazy val defaultu45y = attributes.get("@default-y") map { _.as[BigDecimal]}
  lazy val relativeu45x = attributes.get("@relative-x") map { _.as[BigDecimal]}
  lazy val relativeu45y = attributes.get("@relative-y") map { _.as[BigDecimal]}
  lazy val placement = attributes.get("@placement") map { _.as[Aboveu45below]}
  lazy val color = attributes.get("@color") map { _.as[String]}
  lazy val printu45object = attributes.get("@print-object") map { _.as[Yesu45no]}
  lazy val timeu45only = attributes.get("@time-only") map { _.as[String]}
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      
      

case class LyricSequence3(elision: musicxml.Elision,
  syllabic: Option[musicxml.Syllabic] = None)
      

trait LyricOption
case class LyricSequence2(lyricsequence3: Option[musicxml.LyricSequence3] = None,
  text: musicxml.Textu45elementu45data)
      

case class LyricSequence1(syllabic: Option[musicxml.Syllabic] = None,
  text: musicxml.Textu45elementu45data,
  lyricsequence2: Seq[musicxml.LyricSequence2] = Nil,
  extend: Option[musicxml.Extend] = None) extends LyricOption
      


/** The mordent type is used for both represents the mordent sign with the vertical line and the inverted-mordent sign without the line. The long attribute is "no" by default. The approach and departure attributes are used for compound ornaments, indicating how the beginning and ending of the ornament look relative to the main part of the mordent.
*/
case class Mordent(attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Emptyu45trillu45soundable with OrnamentsOption {
  lazy val defaultu45x = attributes.get("@default-x") map { _.as[BigDecimal]}
  lazy val defaultu45y = attributes.get("@default-y") map { _.as[BigDecimal]}
  lazy val relativeu45x = attributes.get("@relative-x") map { _.as[BigDecimal]}
  lazy val relativeu45y = attributes.get("@relative-y") map { _.as[BigDecimal]}
  lazy val fontu45family = attributes.get("@font-family") map { _.as[String]}
  lazy val fontu45style = attributes.get("@font-style") map { _.as[Fontu45style]}
  lazy val fontu45size = attributes.get("@font-size") map { _.as[String]}
  lazy val fontu45weight = attributes.get("@font-weight") map { _.as[Fontu45weight]}
  lazy val color = attributes.get("@color") map { _.as[String]}
  lazy val placement = attributes.get("@placement") map { _.as[Aboveu45below]}
  lazy val startu45note = attributes.get("@start-note") map { _.as[Startu45note]}
  lazy val trillu45step = attributes.get("@trill-step") map { _.as[Trillu45step]}
  lazy val twou45noteu45turn = attributes.get("@two-note-turn") map { _.as[Twou45noteu45turn]}
  lazy val accelerate = attributes.get("@accelerate") map { _.as[Yesu45no]}
  lazy val beats = attributes.get("@beats") map { _.as[BigDecimal]}
  lazy val secondu45beat = attributes.get("@second-beat") map { _.as[BigDecimal]}
  lazy val lastu45beat = attributes.get("@last-beat") map { _.as[BigDecimal]}
  lazy val long = attributes.get("@long") map { _.as[Yesu45no]}
  lazy val approach = attributes.get("@approach") map { _.as[Aboveu45below]}
  lazy val departure = attributes.get("@departure") map { _.as[Aboveu45below]}
}

      
      


/** The non-arpeggiate type indicates that this note is at the top or bottom of a bracket indicating to not arpeggiate these notes. Since this does not involve playback, it is only used on the top or bottom notes, not on each note as for the arpeggiate type.
*/
case class Nonu45arpeggiate(attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends NotationsOption {
  lazy val typeValue = attributes("@type").as[Topu45bottom]
  lazy val number = attributes.get("@number") map { _.as[BigInt]}
  lazy val defaultu45x = attributes.get("@default-x") map { _.as[BigDecimal]}
  lazy val defaultu45y = attributes.get("@default-y") map { _.as[BigDecimal]}
  lazy val relativeu45x = attributes.get("@relative-x") map { _.as[BigDecimal]}
  lazy val relativeu45y = attributes.get("@relative-y") map { _.as[BigDecimal]}
  lazy val placement = attributes.get("@placement") map { _.as[Aboveu45below]}
  lazy val color = attributes.get("@color") map { _.as[String]}
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      
      


/** Notations refer to musical notations, not XML notations. Multiple notations are allowed in order to represent multiple editorial levels. The print-object attribute, added in Version 3.0, allows notations to represent details of performance technique, such as fingerings, without having them appear in the score.
*/
case class Notations(editorialSequence1: musicxml.EditorialSequence,
  notationsoption: Seq[scalaxb.DataRecord[musicxml.NotationsOption]] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val printu45object = attributes.get("@print-object") map { _.as[Yesu45no]}
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      
      

trait NotationsOption

/** Notes are the most common type of MusicXML data. The MusicXML format keeps the MuseData distinction between elements used for sound information and elements used for notation information (e.g., tie is used for sound, tied for notation). Thus grace notes do not have a duration element. Cue notes have a duration element, as do forward elements, but no tie elements. Having these two types of information available can make interchange considerably easier, as some programs handle one type of information much more readily than the other.

The print-leger attribute is used to indicate whether leger lines are printed. Notes without leger lines are used to indicate indeterminate high and low notes. By default, it is set to yes. If print-object is set to no, print-leger is interpreted to also be set to no if not present. This attribute is ignored for rests.

The dynamics and end-dynamics attributes correspond to MIDI 1.0's Note On and Note Off velocities, respectively. They are expressed in terms of percentages of the default forte value (90 for MIDI 1.0).

The attack and release attributes are used to alter the starting and stopping time of the note from when it would otherwise occur based on the flow of durations - information that is specific to a performance. They are expressed in terms of divisions, either positive or negative. A note that starts a tie should not have a release attribute, and a note that stops a tie should not have an attack attribute. The attack and release attributes are independent of each other. The attack attribute only changes the starting time of a note, and the release attribute only changes the stopping time of a note.

If a note is played only particular times through a repeat, the time-only attribute shows which times to play the note.

The pizzicato attribute is used when just this note is sounded pizzicato, vs. the pizzicato element which changes overall playback between pizzicato and arco.
*/
case class Note(noteoption: scalaxb.DataRecord[musicxml.NoteOption],
  instrument: Option[musicxml.Instrument] = None,
  editorialu45voiceSequence3: musicxml.Editorialu45voiceSequence,
  typeValue: Option[musicxml.Noteu45type] = None,
  dot: Seq[musicxml.Emptyu45placementable] = Nil,
  accidental: Option[musicxml.Accidental] = None,
  timeu45modification: Option[musicxml.Timeu45modificationable] = None,
  stem: Option[musicxml.Stem] = None,
  notehead: Option[musicxml.Notehead] = None,
  noteheadu45text: Option[musicxml.Noteheadu45text] = None,
  staffSequence11: Option[musicxml.StaffSequence] = None,
  beam: Seq[musicxml.Beam] = Nil,
  notations: Seq[musicxml.Notations] = Nil,
  lyric: Seq[musicxml.Lyric] = Nil,
  play: Option[musicxml.Play] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Musicu45dataOption1 {
  lazy val defaultu45x = attributes.get("@default-x") map { _.as[BigDecimal]}
  lazy val defaultu45y = attributes.get("@default-y") map { _.as[BigDecimal]}
  lazy val relativeu45x = attributes.get("@relative-x") map { _.as[BigDecimal]}
  lazy val relativeu45y = attributes.get("@relative-y") map { _.as[BigDecimal]}
  lazy val fontu45family = attributes.get("@font-family") map { _.as[String]}
  lazy val fontu45style = attributes.get("@font-style") map { _.as[Fontu45style]}
  lazy val fontu45size = attributes.get("@font-size") map { _.as[String]}
  lazy val fontu45weight = attributes.get("@font-weight") map { _.as[Fontu45weight]}
  lazy val color = attributes.get("@color") map { _.as[String]}
  lazy val printu45object = attributes.get("@print-object") map { _.as[Yesu45no]}
  lazy val printu45dot = attributes.get("@print-dot") map { _.as[Yesu45no]}
  lazy val printu45spacing = attributes.get("@print-spacing") map { _.as[Yesu45no]}
  lazy val printu45lyric = attributes.get("@print-lyric") map { _.as[Yesu45no]}
  lazy val printu45leger = attributes.get("@print-leger") map { _.as[Yesu45no]}
  lazy val dynamics = attributes.get("@dynamics") map { _.as[BigDecimal]}
  lazy val endu45dynamics = attributes.get("@end-dynamics") map { _.as[BigDecimal]}
  lazy val attack = attributes.get("@attack") map { _.as[BigDecimal]}
  lazy val release = attributes.get("@release") map { _.as[BigDecimal]}
  lazy val timeu45only = attributes.get("@time-only") map { _.as[String]}
  lazy val pizzicato = attributes.get("@pizzicato") map { _.as[Yesu45no]}
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      
      

case class NoteSequence5(fullu45noteSequence1: musicxml.Fullu45noteSequence,
  durationSequence2: musicxml.DurationSequence,
  tie: Seq[musicxml.Tie] = Nil) extends NoteOption
      

trait NoteOption2
case class NoteSequence1(grace: musicxml.Grace,
  noteoption2: scalaxb.DataRecord[musicxml.NoteOption2]) extends NoteOption
      

case class NoteSequence4(cue: musicxml.Empty,
  fullu45noteSequence2: musicxml.Fullu45noteSequence,
  durationSequence3: musicxml.DurationSequence) extends NoteOption
      

case class NoteSequence2(fullu45noteSequence1: musicxml.Fullu45noteSequence,
  tie: Seq[musicxml.Tie] = Nil) extends NoteOption2
      

sealed trait NoteOption
case class NoteSequence3(cue: musicxml.Empty,
  fullu45noteSequence2: musicxml.Fullu45noteSequence) extends NoteOption2
      


/** The note-type type indicates the graphic note type. Values range from 1024th to maxima. The size attribute indicates full, cue, grace-cue, or large size. The default is full for regular notes, grace-cue for notes that contain both grace and cue elements, and cue for notes that contain either a cue or a grace element, but not both.
*/
case class Noteu45type(value: musicxml.Noteu45typeu45value,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val size = attributes.get("@size") map { _.as[Symbolu45size]}
}

      
      


/** The notehead type indicates shapes other than the open and closed ovals associated with note durations. 

The smufl attribute can be used to specify a particular notehead, allowing application interoperability without requiring every SMuFL glyph to have a MusicXML element equivalent. This attribute can be used either with the "other" value, or to refine a specific notehead value such as "cluster". Noteheads in the SMuFL "Note name noteheads" range (U+E150âU+E1AF) should not use the smufl attribute or the "other" value, but instead use the notehead-text element.

For the enclosed shapes, the default is to be hollow for half notes and longer, and filled otherwise. The filled attribute can be set to change this if needed.

If the parentheses attribute is set to yes, the notehead is parenthesized. It is no by default.
*/
case class Notehead(value: musicxml.Noteheadu45value,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val filled = attributes.get("@filled") map { _.as[Yesu45no]}
  lazy val parentheses = attributes.get("@parentheses") map { _.as[Yesu45no]}
  lazy val fontu45family = attributes.get("@font-family") map { _.as[String]}
  lazy val fontu45style = attributes.get("@font-style") map { _.as[Fontu45style]}
  lazy val fontu45size = attributes.get("@font-size") map { _.as[String]}
  lazy val fontu45weight = attributes.get("@font-weight") map { _.as[Fontu45weight]}
  lazy val color = attributes.get("@color") map { _.as[String]}
  lazy val smufl = attributes.get("@smufl") map { _.as[String]}
}

      
      


/** The notehead-text type represents text that is displayed inside a notehead, as is done in some educational music. It is not needed for the numbers used in tablature or jianpu notation. The presence of a TAB or jianpu clefs is sufficient to indicate that numbers are used. The display-text and accidental-text elements allow display of fully formatted text and accidentals.
*/
case class Noteheadu45text(noteheadu45textoption: Seq[scalaxb.DataRecord[musicxml.Noteheadu45textOption]] = Nil)
      
      

trait Noteheadu45textOption

/** Ornaments can be any of several types, followed optionally by accidentals. The accidental-mark element's content is represented the same as an accidental element, but with a different name to reflect the different musical meaning.
*/
case class Ornaments(ornamentssequence1: Seq[musicxml.OrnamentsSequence1] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends NotationsOption {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      
      

case class OrnamentsSequence1(ornamentsoption: scalaxb.DataRecord[musicxml.OrnamentsOption],
  accidentalu45mark: Seq[musicxml.Accidentalu45mark] = Nil)
      

trait OrnamentsOption

/** The other-notation type is used to define any notations not yet in the MusicXML format. It handles notations where more specific extension elements such as other-dynamics and other-technical are not appropriate. The smufl attribute can be used to specify a particular notation, allowing application interoperability without requiring every SMuFL glyph to have a MusicXML element equivalent. Using the other-notation type without the smufl attribute allows for extended representation, though without application interoperability.
*/
case class Otheru45notation(value: String,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends NotationsOption {
  lazy val typeValue = attributes("@type").as[Startu45stopu45single]
  lazy val number = attributes("@number").as[BigInt]
  lazy val printu45object = attributes.get("@print-object") map { _.as[Yesu45no]}
  lazy val defaultu45x = attributes.get("@default-x") map { _.as[BigDecimal]}
  lazy val defaultu45y = attributes.get("@default-y") map { _.as[BigDecimal]}
  lazy val relativeu45x = attributes.get("@relative-x") map { _.as[BigDecimal]}
  lazy val relativeu45y = attributes.get("@relative-y") map { _.as[BigDecimal]}
  lazy val fontu45family = attributes.get("@font-family") map { _.as[String]}
  lazy val fontu45style = attributes.get("@font-style") map { _.as[Fontu45style]}
  lazy val fontu45size = attributes.get("@font-size") map { _.as[String]}
  lazy val fontu45weight = attributes.get("@font-weight") map { _.as[Fontu45weight]}
  lazy val color = attributes.get("@color") map { _.as[String]}
  lazy val placement = attributes.get("@placement") map { _.as[Aboveu45below]}
  lazy val smufl = attributes.get("@smufl") map { _.as[String]}
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      
      


/** The other-placement-text type represents a text element with print-style, placement, and smufl attribute groups. This type is used by MusicXML notation extension elements to allow specification of specific SMuFL glyphs without needed to add every glyph as a MusicXML element.
*/
case class Otheru45placementu45text(value: String,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends ArticulationsOption with OrnamentsOption with TechnicalOption {
  lazy val defaultu45x = attributes.get("@default-x") map { _.as[BigDecimal]}
  lazy val defaultu45y = attributes.get("@default-y") map { _.as[BigDecimal]}
  lazy val relativeu45x = attributes.get("@relative-x") map { _.as[BigDecimal]}
  lazy val relativeu45y = attributes.get("@relative-y") map { _.as[BigDecimal]}
  lazy val fontu45family = attributes.get("@font-family") map { _.as[String]}
  lazy val fontu45style = attributes.get("@font-style") map { _.as[Fontu45style]}
  lazy val fontu45size = attributes.get("@font-size") map { _.as[String]}
  lazy val fontu45weight = attributes.get("@font-weight") map { _.as[Fontu45weight]}
  lazy val color = attributes.get("@color") map { _.as[String]}
  lazy val placement = attributes.get("@placement") map { _.as[Aboveu45below]}
  lazy val smufl = attributes.get("@smufl") map { _.as[String]}
}

      
      


/** The other-text type represents a text element with a smufl attribute group. This type is used by MusicXML direction extension elements to allow specification of specific SMuFL glyphs without needed to add every glyph as a MusicXML element.
*/
case class Otheru45text(value: String,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends DynamicsOption with PercussionTypeOption {
  lazy val smufl = attributes.get("@smufl") map { _.as[String]}
}

      
      


/** Pitch is represented as a combination of the step of the diatonic scale, the chromatic alteration, and the octave.
*/
case class Pitch(step: musicxml.Step,
  alter: Option[BigDecimal] = None,
  octave: BigInt) extends Fullu45noteOption1
      
      


/** The placement-text type represents a text element with print-style and placement attribute groups.
*/
case class Placementu45text(value: String,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends TechnicalOption {
  lazy val defaultu45x = attributes.get("@default-x") map { _.as[BigDecimal]}
  lazy val defaultu45y = attributes.get("@default-y") map { _.as[BigDecimal]}
  lazy val relativeu45x = attributes.get("@relative-x") map { _.as[BigDecimal]}
  lazy val relativeu45y = attributes.get("@relative-y") map { _.as[BigDecimal]}
  lazy val fontu45family = attributes.get("@font-family") map { _.as[String]}
  lazy val fontu45style = attributes.get("@font-style") map { _.as[Fontu45style]}
  lazy val fontu45size = attributes.get("@font-size") map { _.as[String]}
  lazy val fontu45weight = attributes.get("@font-weight") map { _.as[Fontu45weight]}
  lazy val color = attributes.get("@color") map { _.as[String]}
  lazy val placement = attributes.get("@placement") map { _.as[Aboveu45below]}
}

      
      


/** The rest element indicates notated rests or silences. Rest elements are usually empty, but placement on the staff can be specified using display-step and display-octave elements. If the measure attribute is set to yes, this indicates this is a complete measure rest.
*/
case class Rest(displayu45stepu45octaveSequence1: Option[musicxml.Displayu45stepu45octaveSequence] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Fullu45noteOption1 {
  lazy val measure = attributes.get("@measure") map { _.as[Yesu45no]}
}

      
      


/** Glissando and slide types both indicate rapidly moving from one pitch to the other so that individual notes are not discerned. The distinction is similar to that between NIFF's glissando and portamento elements. A slide is continuous between two notes and defaults to a solid line. The optional text for a is printed alongside the line.
*/
case class Slide(value: String,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends NotationsOption {
  lazy val typeValue = attributes("@type").as[Startu45stop]
  lazy val number = attributes("@number").as[BigInt]
  lazy val lineu45type = attributes.get("@line-type") map { _.as[Lineu45type]}
  lazy val dashu45length = attributes.get("@dash-length") map { _.as[BigDecimal]}
  lazy val spaceu45length = attributes.get("@space-length") map { _.as[BigDecimal]}
  lazy val defaultu45x = attributes.get("@default-x") map { _.as[BigDecimal]}
  lazy val defaultu45y = attributes.get("@default-y") map { _.as[BigDecimal]}
  lazy val relativeu45x = attributes.get("@relative-x") map { _.as[BigDecimal]}
  lazy val relativeu45y = attributes.get("@relative-y") map { _.as[BigDecimal]}
  lazy val fontu45family = attributes.get("@font-family") map { _.as[String]}
  lazy val fontu45style = attributes.get("@font-style") map { _.as[Fontu45style]}
  lazy val fontu45size = attributes.get("@font-size") map { _.as[String]}
  lazy val fontu45weight = attributes.get("@font-weight") map { _.as[Fontu45weight]}
  lazy val color = attributes.get("@color") map { _.as[String]}
  lazy val accelerate = attributes.get("@accelerate") map { _.as[Yesu45no]}
  lazy val beats = attributes.get("@beats") map { _.as[BigDecimal]}
  lazy val firstu45beat = attributes.get("@first-beat") map { _.as[BigDecimal]}
  lazy val lastu45beat = attributes.get("@last-beat") map { _.as[BigDecimal]}
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      
      


/** Slur types are empty. Most slurs are represented with two elements: one with a start type, and one with a stop type. Slurs can add more elements using a continue type. This is typically used to specify the formatting of cross-system slurs, or to specify the shape of very complex slurs.
*/
case class Slur(attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends NotationsOption {
  lazy val typeValue = attributes("@type").as[Startu45stopu45continue]
  lazy val number = attributes("@number").as[BigInt]
  lazy val lineu45type = attributes.get("@line-type") map { _.as[Lineu45type]}
  lazy val dashu45length = attributes.get("@dash-length") map { _.as[BigDecimal]}
  lazy val spaceu45length = attributes.get("@space-length") map { _.as[BigDecimal]}
  lazy val defaultu45x = attributes.get("@default-x") map { _.as[BigDecimal]}
  lazy val defaultu45y = attributes.get("@default-y") map { _.as[BigDecimal]}
  lazy val relativeu45x = attributes.get("@relative-x") map { _.as[BigDecimal]}
  lazy val relativeu45y = attributes.get("@relative-y") map { _.as[BigDecimal]}
  lazy val placement = attributes.get("@placement") map { _.as[Aboveu45below]}
  lazy val orientation = attributes.get("@orientation") map { _.as[Overu45under]}
  lazy val bezieru45x = attributes.get("@bezier-x") map { _.as[BigDecimal]}
  lazy val bezieru45y = attributes.get("@bezier-y") map { _.as[BigDecimal]}
  lazy val bezieru45x2 = attributes.get("@bezier-x2") map { _.as[BigDecimal]}
  lazy val bezieru45y2 = attributes.get("@bezier-y2") map { _.as[BigDecimal]}
  lazy val bezieru45offset = attributes.get("@bezier-offset") map { _.as[BigDecimal]}
  lazy val bezieru45offset2 = attributes.get("@bezier-offset2") map { _.as[BigDecimal]}
  lazy val color = attributes.get("@color") map { _.as[String]}
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      
      


/** Stems can be down, up, none, or double. For down and up stems, the position attributes can be used to specify stem length. The relative values specify the end of the stem relative to the program default. Default values specify an absolute end stem position. Negative values of relative-y that would flip a stem instead of shortening it are ignored. A stem element associated with a rest refers to a stemlet.
*/
case class Stem(value: musicxml.Stemu45value,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val defaultu45x = attributes.get("@default-x") map { _.as[BigDecimal]}
  lazy val defaultu45y = attributes.get("@default-y") map { _.as[BigDecimal]}
  lazy val relativeu45x = attributes.get("@relative-x") map { _.as[BigDecimal]}
  lazy val relativeu45y = attributes.get("@relative-y") map { _.as[BigDecimal]}
  lazy val color = attributes.get("@color") map { _.as[String]}
}

      
      


/** The strong-accent type indicates a vertical accent mark. The type attribute indicates if the point of the accent is down or up.
*/
case class Strongu45accent(attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Emptyu45placementable with ArticulationsOption {
  lazy val defaultu45x = attributes.get("@default-x") map { _.as[BigDecimal]}
  lazy val defaultu45y = attributes.get("@default-y") map { _.as[BigDecimal]}
  lazy val relativeu45x = attributes.get("@relative-x") map { _.as[BigDecimal]}
  lazy val relativeu45y = attributes.get("@relative-y") map { _.as[BigDecimal]}
  lazy val fontu45family = attributes.get("@font-family") map { _.as[String]}
  lazy val fontu45style = attributes.get("@font-style") map { _.as[Fontu45style]}
  lazy val fontu45size = attributes.get("@font-size") map { _.as[String]}
  lazy val fontu45weight = attributes.get("@font-weight") map { _.as[Fontu45weight]}
  lazy val color = attributes.get("@color") map { _.as[String]}
  lazy val placement = attributes.get("@placement") map { _.as[Aboveu45below]}
  lazy val typeValue = attributes("@type").as[Upu45down]
}

      
      


/** The style-text type represents a text element with a print-style attribute group.
*/
case class Styleu45text(value: String,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends Harmonyu45chordOption1 {
  lazy val defaultu45x = attributes.get("@default-x") map { _.as[BigDecimal]}
  lazy val defaultu45y = attributes.get("@default-y") map { _.as[BigDecimal]}
  lazy val relativeu45x = attributes.get("@relative-x") map { _.as[BigDecimal]}
  lazy val relativeu45y = attributes.get("@relative-y") map { _.as[BigDecimal]}
  lazy val fontu45family = attributes.get("@font-family") map { _.as[String]}
  lazy val fontu45style = attributes.get("@font-style") map { _.as[Fontu45style]}
  lazy val fontu45size = attributes.get("@font-size") map { _.as[String]}
  lazy val fontu45weight = attributes.get("@font-weight") map { _.as[Fontu45weight]}
  lazy val color = attributes.get("@color") map { _.as[String]}
}

      
      


/** The tap type indicates a tap on the fretboard. The text content allows specification of the notation; + and T are common choices. If the element is empty, the hand attribute is used to specify the symbol to use. The hand attribute is ignored if the tap glyph is already specified by the text content. If neither text content nor the hand attribute are present, the display is application-specific.
*/
case class Tap(value: String,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends TechnicalOption {
  lazy val hand = attributes.get("@hand") map { _.as[Tapu45hand]}
  lazy val defaultu45x = attributes.get("@default-x") map { _.as[BigDecimal]}
  lazy val defaultu45y = attributes.get("@default-y") map { _.as[BigDecimal]}
  lazy val relativeu45x = attributes.get("@relative-x") map { _.as[BigDecimal]}
  lazy val relativeu45y = attributes.get("@relative-y") map { _.as[BigDecimal]}
  lazy val fontu45family = attributes.get("@font-family") map { _.as[String]}
  lazy val fontu45style = attributes.get("@font-style") map { _.as[Fontu45style]}
  lazy val fontu45size = attributes.get("@font-size") map { _.as[String]}
  lazy val fontu45weight = attributes.get("@font-weight") map { _.as[Fontu45weight]}
  lazy val color = attributes.get("@color") map { _.as[String]}
  lazy val placement = attributes.get("@placement") map { _.as[Aboveu45below]}
}

      
      


/** Technical indications give performance information for individual instruments.
*/
case class Technical(technicaloption: Seq[scalaxb.DataRecord[musicxml.TechnicalOption]] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends NotationsOption {
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      
      

trait TechnicalOption

/** The text-element-data type represents a syllable or portion of a syllable for lyric text underlay. A hyphen in the string content should only be used for an actual hyphenated word. Language names for text elements come from ISO 639, with optional country subcodes from ISO 3166.
*/
case class Textu45elementu45data(value: String,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val fontu45family = attributes.get("@font-family") map { _.as[String]}
  lazy val fontu45style = attributes.get("@font-style") map { _.as[Fontu45style]}
  lazy val fontu45size = attributes.get("@font-size") map { _.as[String]}
  lazy val fontu45weight = attributes.get("@font-weight") map { _.as[Fontu45weight]}
  lazy val color = attributes.get("@color") map { _.as[String]}
  lazy val underline = attributes.get("@underline") map { _.as[BigInt]}
  lazy val overline = attributes.get("@overline") map { _.as[BigInt]}
  lazy val lineu45through = attributes.get("@line-through") map { _.as[BigInt]}
  lazy val rotation = attributes.get("@rotation") map { _.as[BigDecimal]}
  lazy val letteru45spacing = attributes.get("@letter-spacing") map { _.as[String]}
  lazy val xmllang = attributes.get("@{http://www.w3.org/XML/1998/namespace}lang") map { _.as[String]}
  lazy val dir = attributes.get("@dir") map { _.as[Textu45direction]}
}

      
      


/** The tie element indicates that a tie begins or ends with this note. If the tie element applies only particular times through a repeat, the time-only attribute indicates which times to apply it. The tie element indicates sound; the tied element indicates notation.
*/
case class Tie(attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val typeValue = attributes("@type").as[Startu45stop]
  lazy val timeu45only = attributes.get("@time-only") map { _.as[String]}
}

      
      


/** The tied element represents the notated tie. The tie element represents the tie sound.

The number attribute is rarely needed to disambiguate ties, since note pitches will usually suffice. The attribute is implied rather than defaulting to 1 as with most elements. It is available for use in more complex tied notation situations.

Ties that join two notes of the same pitch together should be represented with a tied element on the first note with type="start" and a tied element on the second note with type="stop".  This can also be done if the two notes being tied are enharmonically equivalent, but have different step values. It is not recommended to use tied elements to join two notes with enharmonically inequivalent pitches.

Ties that indicate that an instrument should be undamped are specified with a single tied element with type="let-ring".

Ties that are visually attached to only one note, other than undamped ties, should be specified with two tied elements on the same note, first type="start" then type="stop". This can be used to represent ties into or out of repeated sections or codas.
*/
case class Tied(attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends NotationsOption {
  lazy val typeValue = attributes("@type").as[Tiedu45type]
  lazy val number = attributes.get("@number") map { _.as[BigInt]}
  lazy val lineu45type = attributes.get("@line-type") map { _.as[Lineu45type]}
  lazy val dashu45length = attributes.get("@dash-length") map { _.as[BigDecimal]}
  lazy val spaceu45length = attributes.get("@space-length") map { _.as[BigDecimal]}
  lazy val defaultu45x = attributes.get("@default-x") map { _.as[BigDecimal]}
  lazy val defaultu45y = attributes.get("@default-y") map { _.as[BigDecimal]}
  lazy val relativeu45x = attributes.get("@relative-x") map { _.as[BigDecimal]}
  lazy val relativeu45y = attributes.get("@relative-y") map { _.as[BigDecimal]}
  lazy val placement = attributes.get("@placement") map { _.as[Aboveu45below]}
  lazy val orientation = attributes.get("@orientation") map { _.as[Overu45under]}
  lazy val bezieru45x = attributes.get("@bezier-x") map { _.as[BigDecimal]}
  lazy val bezieru45y = attributes.get("@bezier-y") map { _.as[BigDecimal]}
  lazy val bezieru45x2 = attributes.get("@bezier-x2") map { _.as[BigDecimal]}
  lazy val bezieru45y2 = attributes.get("@bezier-y2") map { _.as[BigDecimal]}
  lazy val bezieru45offset = attributes.get("@bezier-offset") map { _.as[BigDecimal]}
  lazy val bezieru45offset2 = attributes.get("@bezier-offset2") map { _.as[BigDecimal]}
  lazy val color = attributes.get("@color") map { _.as[String]}
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      
      


/** Time modification indicates tuplets, double-note tremolos, and other durational changes. A time-modification element shows how the cumulative, sounding effect of tuplets and double-note tremolos compare to the written note type represented by the type and dot elements. Nested tuplets and other notations that use more detailed information need both the time-modification and tuplet elements to be represented accurately.
*/
trait Timeu45modificationable {
  def actualu45notes: BigInt
  def normalu45notes: BigInt
  def timeu45modificationablesequence1: Option[musicxml.Timeu45modificationableSequence1]
}


/** Time modification indicates tuplets, double-note tremolos, and other durational changes. A time-modification element shows how the cumulative, sounding effect of tuplets and double-note tremolos compare to the written note type represented by the type and dot elements. Nested tuplets and other notations that use more detailed information need both the time-modification and tuplet elements to be represented accurately.
*/
case class Timeu45modification(actualu45notes: BigInt,
  normalu45notes: BigInt,
  timeu45modificationablesequence1: Option[musicxml.Timeu45modificationableSequence1] = None) extends Timeu45modificationable
      
      

case class Timeu45modificationableSequence1(normalu45type: musicxml.Noteu45typeu45value,
  normalu45dot: Seq[musicxml.Empty] = Nil)
      


/** The tremolo ornament can be used to indicate single-note, double-note, or unmeasured tremolos. Single-note tremolos use the single type, double-note tremolos use the start and stop types, and unmeasured tremolos use the unmeasured type. The default is "single" for compatibility with Version 1.1. The text of the element indicates the number of tremolo marks and is an integer from 0 to 8. Note that the number of attached beams is not included in this value, but is represented separately using the beam element. The value should be 0 for unmeasured tremolos.
	
	When using double-note tremolos, the duration of each note in the tremolo should correspond to half of the notated type value. A time-modification element should also be added with an actual-notes value of 2 and a normal-notes value of 1. If used within a tuplet, this 2/1 ratio should be multiplied by the existing tuplet ratio.
	
	The smufl attribute specifies the glyph to use from the SMuFL tremolos range for an unmeasured tremolo. It is ignored for other tremolo types. The SMuFL buzzRoll glyph is used by default if the attribute is missing.
	
	Using repeater beams for indicating tremolos is deprecated as of MusicXML 3.0.
*/
case class Tremolo(value: BigInt,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends OrnamentsOption {
  lazy val typeValue = attributes("@type").as[Tremolou45type]
  lazy val defaultu45x = attributes.get("@default-x") map { _.as[BigDecimal]}
  lazy val defaultu45y = attributes.get("@default-y") map { _.as[BigDecimal]}
  lazy val relativeu45x = attributes.get("@relative-x") map { _.as[BigDecimal]}
  lazy val relativeu45y = attributes.get("@relative-y") map { _.as[BigDecimal]}
  lazy val fontu45family = attributes.get("@font-family") map { _.as[String]}
  lazy val fontu45style = attributes.get("@font-style") map { _.as[Fontu45style]}
  lazy val fontu45size = attributes.get("@font-size") map { _.as[String]}
  lazy val fontu45weight = attributes.get("@font-weight") map { _.as[Fontu45weight]}
  lazy val color = attributes.get("@color") map { _.as[String]}
  lazy val placement = attributes.get("@placement") map { _.as[Aboveu45below]}
  lazy val smufl = attributes.get("@smufl") map { _.as[String]}
}

      
      


/** A tuplet element is present when a tuplet is to be displayed graphically, in addition to the sound data provided by the time-modification elements. The number attribute is used to distinguish nested tuplets. The bracket attribute is used to indicate the presence of a bracket. If unspecified, the results are implementation-dependent. The line-shape attribute is used to specify whether the bracket is straight or in the older curved or slurred style. It is straight by default.

Whereas a time-modification element shows how the cumulative, sounding effect of tuplets and double-note tremolos compare to the written note type, the tuplet element describes how this is displayed. The tuplet element also provides more detailed representation information than the time-modification element, and is needed to represent nested tuplets and other complex tuplets accurately.

The show-number attribute is used to display either the number of actual notes, the number of both actual and normal notes, or neither. It is actual by default. The show-type attribute is used to display either the actual type, both the actual and normal types, or neither. It is none by default.
*/
case class Tuplet(tupletu45actual: Option[musicxml.Tupletu45portion] = None,
  tupletu45normal: Option[musicxml.Tupletu45portion] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends NotationsOption {
  lazy val typeValue = attributes("@type").as[Startu45stop]
  lazy val number = attributes.get("@number") map { _.as[BigInt]}
  lazy val bracket = attributes.get("@bracket") map { _.as[Yesu45no]}
  lazy val showu45number = attributes.get("@show-number") map { _.as[Showu45tuplet]}
  lazy val showu45type = attributes.get("@show-type") map { _.as[Showu45tuplet]}
  lazy val lineu45shape = attributes.get("@line-shape") map { _.as[Lineu45shape]}
  lazy val defaultu45x = attributes.get("@default-x") map { _.as[BigDecimal]}
  lazy val defaultu45y = attributes.get("@default-y") map { _.as[BigDecimal]}
  lazy val relativeu45x = attributes.get("@relative-x") map { _.as[BigDecimal]}
  lazy val relativeu45y = attributes.get("@relative-y") map { _.as[BigDecimal]}
  lazy val placement = attributes.get("@placement") map { _.as[Aboveu45below]}
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      
      


/** The tuplet-dot type is used to specify dotted normal tuplet types.
*/
case class Tupletu45dot(attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val fontu45family = attributes.get("@font-family") map { _.as[String]}
  lazy val fontu45style = attributes.get("@font-style") map { _.as[Fontu45style]}
  lazy val fontu45size = attributes.get("@font-size") map { _.as[String]}
  lazy val fontu45weight = attributes.get("@font-weight") map { _.as[Fontu45weight]}
  lazy val color = attributes.get("@color") map { _.as[String]}
}

      
      


/** The tuplet-number type indicates the number of notes for this portion of the tuplet.
*/
case class Tupletu45number(value: BigInt,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val fontu45family = attributes.get("@font-family") map { _.as[String]}
  lazy val fontu45style = attributes.get("@font-style") map { _.as[Fontu45style]}
  lazy val fontu45size = attributes.get("@font-size") map { _.as[String]}
  lazy val fontu45weight = attributes.get("@font-weight") map { _.as[Fontu45weight]}
  lazy val color = attributes.get("@color") map { _.as[String]}
}

      
      


/** The tuplet-portion type provides optional full control over tuplet specifications. It allows the number and note type (including dots) to be set for the actual and normal portions of a single tuplet. If any of these elements are absent, their values are based on the time-modification element.
*/
case class Tupletu45portion(tupletu45number: Option[musicxml.Tupletu45number] = None,
  tupletu45type: Option[musicxml.Tupletu45type] = None,
  tupletu45dot: Seq[musicxml.Tupletu45dot] = Nil)
      
      


/** The tuplet-type type indicates the graphical note type of the notes for this portion of the tuplet.
*/
case class Tupletu45type(value: musicxml.Noteu45typeu45value,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val fontu45family = attributes.get("@font-family") map { _.as[String]}
  lazy val fontu45style = attributes.get("@font-style") map { _.as[Fontu45style]}
  lazy val fontu45size = attributes.get("@font-size") map { _.as[String]}
  lazy val fontu45weight = attributes.get("@font-weight") map { _.as[Fontu45weight]}
  lazy val color = attributes.get("@color") map { _.as[String]}
}

      
      


/** The unpitched type represents musical elements that are notated on the staff but lack definite pitch, such as unpitched percussion and speaking voice.
*/
case class Unpitched(displayu45stepu45octaveSequence1: Option[musicxml.Displayu45stepu45octaveSequence] = None) extends Fullu45noteOption1
      
      


/** The credit type represents the appearance of the title, composer, arranger, lyricist, copyright, dedication, and other text, symbols, and graphics that commonly appear on the first page of a score. The credit-words, credit-symbol, and credit-image elements are similar to the words, symbol, and image elements for directions. However, since the credit is not part of a measure, the default-x and default-y attributes adjust the origin relative to the bottom left-hand corner of the page. The enclosure for credit-words and credit-symbol is none by default.

By default, a series of credit-words and credit-symbol elements within a single credit element follow one another in sequence visually. Non-positional formatting attributes are carried over from the previous element by default.

The page attribute for the credit element specifies the page number where the credit should appear. This is an integer value that starts with 1 for the first page. Its value is 1 by default. Since credits occur before the music, these page numbers do not refer to the page numbering specified by the print element's page-number attribute.

The credit-type element indicates the purpose behind a credit. Multiple types of data may be combined in a single credit, so multiple elements may be used. Standard values include page number, title, subtitle, composer, arranger, lyricist, and rights.

*/
case class Credit(creditu45type: Seq[String] = Nil,
  link: Seq[musicxml.Link] = Nil,
  bookmark: Seq[musicxml.Bookmark] = Nil,
  creditoption: scalaxb.DataRecord[musicxml.CreditOption],
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val page = attributes.get("@page") map { _.as[BigInt]}
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      
      

trait CreditOption3
trait CreditOption
case class CreditSequence2(link: Seq[musicxml.Link] = Nil,
  bookmark: Seq[musicxml.Bookmark] = Nil,
  creditoption3: scalaxb.DataRecord[musicxml.CreditOption3])
      

case class CreditSequence1(creditoption2: scalaxb.DataRecord[musicxml.CreditOption2],
  creditsequence2: Seq[musicxml.CreditSequence2] = Nil) extends CreditOption
      

trait CreditOption2

/** The defaults type specifies score-wide defaults for scaling, layout, and appearance.
*/
case class Defaults(scaling: Option[musicxml.Scaling] = None,
  layoutSequence2: musicxml.LayoutSequence,
  appearance: Option[musicxml.Appearance] = None,
  musicu45font: Option[musicxml.Emptyu45font] = None,
  wordu45font: Option[musicxml.Emptyu45font] = None,
  lyricu45font: Seq[musicxml.Lyricu45font] = Nil,
  lyricu45language: Seq[musicxml.Lyricu45language] = Nil)
      
      


/** The empty-font type represents an empty element with font attributes.
*/
case class Emptyu45font(attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val fontu45family = attributes.get("@font-family") map { _.as[String]}
  lazy val fontu45style = attributes.get("@font-style") map { _.as[Fontu45style]}
  lazy val fontu45size = attributes.get("@font-size") map { _.as[String]}
  lazy val fontu45weight = attributes.get("@font-weight") map { _.as[Fontu45weight]}
}

      
      


/** The group-barline type indicates if the group should have common barlines.
*/
case class Groupu45barline(value: musicxml.Groupu45barlineu45value,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val color = attributes.get("@color") map { _.as[String]}
}

      
      


/** The group-name type describes the name or abbreviation of a part-group element. Formatting attributes in the group-name type are deprecated in Version 2.0 in favor of the new group-name-display and group-abbreviation-display elements.
*/
case class Groupu45name(value: String,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val defaultu45x = attributes.get("@default-x") map { _.as[BigDecimal]}
  lazy val defaultu45y = attributes.get("@default-y") map { _.as[BigDecimal]}
  lazy val relativeu45x = attributes.get("@relative-x") map { _.as[BigDecimal]}
  lazy val relativeu45y = attributes.get("@relative-y") map { _.as[BigDecimal]}
  lazy val fontu45family = attributes.get("@font-family") map { _.as[String]}
  lazy val fontu45style = attributes.get("@font-style") map { _.as[Fontu45style]}
  lazy val fontu45size = attributes.get("@font-size") map { _.as[String]}
  lazy val fontu45weight = attributes.get("@font-weight") map { _.as[Fontu45weight]}
  lazy val color = attributes.get("@color") map { _.as[String]}
  lazy val justify = attributes.get("@justify") map { _.as[Leftu45centeru45right]}
}

      
      


/** The group-symbol type indicates how the symbol for a group is indicated in the score.
*/
case class Groupu45symbol(value: musicxml.Groupu45symbolu45value,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val defaultu45x = attributes.get("@default-x") map { _.as[BigDecimal]}
  lazy val defaultu45y = attributes.get("@default-y") map { _.as[BigDecimal]}
  lazy val relativeu45x = attributes.get("@relative-x") map { _.as[BigDecimal]}
  lazy val relativeu45y = attributes.get("@relative-y") map { _.as[BigDecimal]}
  lazy val color = attributes.get("@color") map { _.as[String]}
}

      
      


/** The lyric-font type specifies the default font for a particular name and number of lyric.
*/
case class Lyricu45font(attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val number = attributes.get("@number") map { _.as[String]}
  lazy val name = attributes.get("@name") map { _.as[String]}
  lazy val fontu45family = attributes.get("@font-family") map { _.as[String]}
  lazy val fontu45style = attributes.get("@font-style") map { _.as[Fontu45style]}
  lazy val fontu45size = attributes.get("@font-size") map { _.as[String]}
  lazy val fontu45weight = attributes.get("@font-weight") map { _.as[Fontu45weight]}
}

      
      


/** The lyric-language type specifies the default language for a particular name and number of lyric.
*/
case class Lyricu45language(attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val number = attributes.get("@number") map { _.as[String]}
  lazy val name = attributes.get("@name") map { _.as[String]}
  lazy val xmllang = attributes("@{http://www.w3.org/XML/1998/namespace}lang").as[String]
}

      
      


/** The part-group element indicates groupings of parts in the score, usually indicated by braces and brackets. Braces that are used for multi-staff parts should be defined in the attributes element for that part. The part-group start element appears before the first score-part in the group. The part-group stop element appears after the last score-part in the group.

The number attribute is used to distinguish overlapping and nested part-groups, not the sequence of groups. As with parts, groups can have a name and abbreviation. Values for the child elements are ignored at the stop of a group.

A part-group element is not needed for a single multi-staff part. By default, multi-staff parts include a brace symbol and (if appropriate given the bar-style) common barlines. The symbol formatting for a multi-staff part can be more fully specified using the part-symbol element.
*/
case class Partu45group(groupu45name: Option[musicxml.Groupu45name] = None,
  groupu45nameu45display: Option[musicxml.Nameu45display] = None,
  groupu45abbreviation: Option[musicxml.Groupu45name] = None,
  groupu45abbreviationu45display: Option[musicxml.Nameu45display] = None,
  groupu45symbol: Option[musicxml.Groupu45symbol] = None,
  groupu45barline: Option[musicxml.Groupu45barline] = None,
  groupu45time: Option[musicxml.Empty] = None,
  editorialSequence8: musicxml.EditorialSequence,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val typeValue = attributes("@type").as[Startu45stop]
  lazy val number = attributes("@number").as[String]
}

      
      


/** The part-list identifies the different musical parts in this movement. Each part has an ID that is used later within the musical data. Since parts may be encoded separately and combined later, identification elements are present at both the score and score-part levels. There must be at least one score-part, combined as desired with part-group elements that indicate braces and brackets. Parts are ordered from top to bottom in a score based on the order in which they appear in the part-list.
*/
case class Partu45list(partu45groupSequence1: Seq[musicxml.Partu45groupSequence] = Nil,
  scoreu45partSequence2: musicxml.Scoreu45partSequence,
  partu45listoption: Seq[scalaxb.DataRecord[Any]] = Nil)
      
      

trait Partu45listOption

/** The part-name type describes the name or abbreviation of a score-part element. Formatting attributes for the part-name element are deprecated in Version 2.0 in favor of the new part-name-display and part-abbreviation-display elements.
*/
case class Partu45name(value: String,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val defaultu45x = attributes.get("@default-x") map { _.as[BigDecimal]}
  lazy val defaultu45y = attributes.get("@default-y") map { _.as[BigDecimal]}
  lazy val relativeu45x = attributes.get("@relative-x") map { _.as[BigDecimal]}
  lazy val relativeu45y = attributes.get("@relative-y") map { _.as[BigDecimal]}
  lazy val fontu45family = attributes.get("@font-family") map { _.as[String]}
  lazy val fontu45style = attributes.get("@font-style") map { _.as[Fontu45style]}
  lazy val fontu45size = attributes.get("@font-size") map { _.as[String]}
  lazy val fontu45weight = attributes.get("@font-weight") map { _.as[Fontu45weight]}
  lazy val color = attributes.get("@color") map { _.as[String]}
  lazy val printu45object = attributes.get("@print-object") map { _.as[Yesu45no]}
  lazy val justify = attributes.get("@justify") map { _.as[Leftu45centeru45right]}
}

      
      


/** The score-instrument type represents a single instrument within a score-part. As with the score-part type, each score-instrument has a required ID attribute, a name, and an optional abbreviation.

A score-instrument type is also required if the score specifies MIDI 1.0 channels, banks, or programs. An initial midi-instrument assignment can also be made here. MusicXML software should be able to automatically assign reasonable channels and instruments without these elements in simple cases, such as where part names match General MIDI instrument names.
*/
case class Scoreu45instrument(instrumentu45name: String,
  instrumentu45abbreviation: Option[String] = None,
  instrumentu45sound: Option[String] = None,
  scoreu45instrumentoption: Option[scalaxb.DataRecord[Any]] = None,
  virtualu45instrument: Option[musicxml.Virtualu45instrument] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val id = attributes("@id").as[String]
}

      
      

trait Scoreu45instrumentOption

/** Each MusicXML part corresponds to a track in a Standard MIDI Format 1 file. The score-instrument elements are used when there are multiple instruments per track. The midi-device element is used to make a MIDI device or port assignment for the given track or specific MIDI instruments. Initial midi-instrument assignments may be made here as well.
*/
case class Scoreu45part(identification: Option[musicxml.Identification] = None,
  partu45name: musicxml.Partu45name,
  partu45nameu45display: Option[musicxml.Nameu45display] = None,
  partu45abbreviation: Option[musicxml.Partu45name] = None,
  partu45abbreviationu45display: Option[musicxml.Nameu45display] = None,
  group: Seq[String] = Nil,
  scoreu45instrument: Seq[musicxml.Scoreu45instrument] = Nil,
  scoreu45partsequence1: Seq[musicxml.Scoreu45partSequence1] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val id = attributes("@id").as[String]
}

      
      

case class Scoreu45partSequence1(midiu45device: Option[musicxml.Midiu45device] = None,
  midiu45instrument: Option[musicxml.Midiu45instrument] = None)
      


/** The virtual-instrument element defines a specific virtual instrument used for an instrument sound.
*/
case class Virtualu45instrument(virtualu45library: Option[String] = None,
  virtualu45name: Option[String] = None)
      
      


/** Works are optionally identified by number and title. The work type also may indicate a link to the opus document that composes multiple scores into a collection.
*/
case class Work(worku45number: Option[String] = None,
  worku45title: Option[String] = None,
  opus: Option[musicxml.Opus] = None)
      
      


case class Measure(musicu45dataOption11: Seq[scalaxb.DataRecord[musicxml.Musicu45dataOption1]] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val number = attributes("@number").as[String]
  lazy val text = attributes.get("@text") map { _.as[String]}
  lazy val implicitValue = attributes.get("@implicit") map { _.as[Yesu45no]}
  lazy val nonu45controlling = attributes.get("@non-controlling") map { _.as[Yesu45no]}
  lazy val width = attributes.get("@width") map { _.as[BigDecimal]}
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      
      


case class Part(measure: Seq[musicxml.Measure] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val id = attributes("@id").as[String]
}

      
      


case class Scoreu45partwise(scoreu45headerSequence1: musicxml.Scoreu45headerSequence,
  part: Seq[musicxml.Part] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val version = attributes("@version").as[String]
}

      
      


case class Part2(musicu45dataOption11: Seq[scalaxb.DataRecord[musicxml.Musicu45dataOption1]] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val id = attributes("@id").as[String]
}

      
      


case class Measure2(part: Seq[musicxml.Part2] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val number = attributes("@number").as[String]
  lazy val text = attributes.get("@text") map { _.as[String]}
  lazy val implicitValue = attributes.get("@implicit") map { _.as[Yesu45no]}
  lazy val nonu45controlling = attributes.get("@non-controlling") map { _.as[Yesu45no]}
  lazy val width = attributes.get("@width") map { _.as[BigDecimal]}
  lazy val id = attributes.get("@id") map { _.as[String]}
}

      
      


case class Scoreu45timewise(scoreu45headerSequence1: musicxml.Scoreu45headerSequence,
  measure: Seq[musicxml.Measure2] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val version = attributes("@version").as[String]
}

      
      

case class Scoreu45partSequence(scoreu45part: musicxml.Scoreu45part)
      
case class Partu45groupSequence(partu45group: musicxml.Partu45group)
      
sealed trait Fullu45noteOption1
case class Fullu45noteSequence(chord: Option[musicxml.Empty] = None,
  fullu45noteoption1: scalaxb.DataRecord[musicxml.Fullu45noteOption1])
      

case class DurationSequence(duration: BigDecimal)
      
case class LayoutSequence(pageu45layout: Option[musicxml.Pageu45layout] = None,
  systemu45layout: Option[musicxml.Systemu45layout] = None,
  staffu45layout: Seq[musicxml.Staffu45layout] = Nil)
      

trait Harmonyu45chordOption1
case class Harmonyu45chordSequence(harmonyu45chordoption1: scalaxb.DataRecord[musicxml.Harmonyu45chordOption1],
  kind: musicxml.Kind,
  inversion: Option[musicxml.Inversion] = None,
  bass: Option[musicxml.Bass] = None,
  degree: Seq[musicxml.Degree] = Nil)
      

case class Traditionalu45keySequence(cancel: Option[musicxml.Cancel] = None,
  fifths: BigInt,
  mode: Option[String] = None)
      

case class SlashSequence(slashsequence2: Option[musicxml.SlashSequence2] = None,
  exceptu45voice: Seq[String] = Nil)
      

case class SlashSequence2(slashu45type: musicxml.Noteu45typeu45value,
  slashu45dot: Seq[musicxml.Empty] = Nil)
      

case class VoiceSequence(voice: String)
      
case class StaffSequence(staff: BigInt)
      
case class FootnoteSequence(footnote: musicxml.Formattedu45text)
      
case class Editorialu45voiceSequence(footnoteSequence1: Option[musicxml.FootnoteSequence] = None,
  levelSequence2: Option[musicxml.LevelSequence] = None,
  voiceSequence3: Option[musicxml.VoiceSequence] = None)
      

case class EditorialSequence(footnoteSequence1: Option[musicxml.FootnoteSequence] = None,
  levelSequence2: Option[musicxml.LevelSequence] = None)
      

case class Editorialu45voiceu45directionSequence(footnoteSequence1: Option[musicxml.FootnoteSequence] = None,
  levelSequence2: Option[musicxml.LevelSequence] = None,
  voiceSequence3: Option[musicxml.VoiceSequence] = None)
      

case class LevelSequence(level: musicxml.Level)
      
case class TuningSequence(tuningu45step: musicxml.Step,
  tuningu45alter: Option[BigDecimal] = None,
  tuningu45octave: BigInt)
      

case class Nonu45traditionalu45keySequence(keyu45step: musicxml.Step,
  keyu45alter: BigDecimal,
  keyu45accidental: Option[musicxml.Keyu45accidental] = None)
      

case class Timeu45signatureSequence(beats: String,
  beatu45type: String)
      

case class Beatu45unitSequence(beatu45unit: musicxml.Noteu45typeu45value,
  beatu45unitu45dot: Seq[musicxml.Empty] = Nil)
      

case class Allu45marginsSequence(leftu45rightu45marginsSequence1: musicxml.Leftu45rightu45marginsSequence,
  topu45margin: BigDecimal,
  bottomu45margin: BigDecimal)
      

case class Leftu45rightu45marginsSequence(leftu45margin: BigDecimal,
  rightu45margin: BigDecimal)
      

case class Displayu45stepu45octaveSequence(displayu45step: musicxml.Step,
  displayu45octave: BigInt)
      

trait Musicu45dataOption1
case class Scoreu45headerSequence(work: Option[musicxml.Work] = None,
  movementu45number: Option[String] = None,
  movementu45title: Option[String] = None,
  identification: Option[musicxml.Identification] = None,
  defaults: Option[musicxml.Defaults] = None,
  credit: Seq[musicxml.Credit] = Nil,
  partu45list: musicxml.Partu45list)
      


/** The part-name-text attribute group is used by the part-name and part-abbreviation elements. The print-style and justify attribute groups are deprecated in MusicXML 2.0 in favor of the new part-name-display and part-abbreviation-display elements.
*/
case class Partu45nameu45text(defaultu45x: Option[BigDecimal] = None,
  defaultu45y: Option[BigDecimal] = None,
  relativeu45x: Option[BigDecimal] = None,
  relativeu45y: Option[BigDecimal] = None,
  fontu45family: Option[String] = None,
  fontu45style: Option[musicxml.Fontu45style] = None,
  fontu45size: Option[String] = None,
  fontu45weight: Option[musicxml.Fontu45weight] = None,
  color: Option[String] = None,
  printu45object: Option[musicxml.Yesu45no] = None,
  justify: Option[musicxml.Leftu45centeru45right] = None)


/** The measure-attributes group is used by the measure element. Measures have a required number attribute (going from partwise to timewise, measures are grouped via the number).

The implicit attribute is set to "yes" for measures where the measure number should never appear, such as pickup measures and the last half of mid-measure repeats. The value is "no" if not specified.

The non-controlling attribute is intended for use in multimetric music like the Don Giovanni minuet. If set to "yes", the left barline in this measure does not coincide with the left barline of measures in other parts. The value is "no" if not specified.

In partwise files, the number attribute should be the same for measures in different parts that share the same left barline. While the number attribute is often numeric, it does not have to be. Non-numeric values are typically used together with the implicit or non-controlling attributes being set to "yes". For a pickup measure, the number attribute is typically set to "0" and the implicit attribute is typically set to "yes". 

If measure numbers are not unique within a part, this can cause problems for conversions between partwise and timewise formats. The text attribute allows specification of displayed measure numbers that are different than what is used in the number attribute. This attribute is ignored for measures where the implicit attribute is set to "yes". Further details about measure numbering can be specified using the measure-numbering element.

Measure width is specified in tenths. These are the global tenths specified in the scaling element, not local tenths as modified by the staff-size element.	The width covers the entire measure from barline or system start to barline or system end.
*/
case class Measureu45attributes(number: String,
  text: Option[String] = None,
  implicitValue: Option[musicxml.Yesu45no] = None,
  nonu45controlling: Option[musicxml.Yesu45no] = None,
  width: Option[BigDecimal] = None,
  id: Option[String] = None)


/** The link-attributes group includes all the simple XLink attributes supported in the MusicXML format.
*/
case class Linku45attributes(xlinkhref: java.net.URI,
  xlinktype: musicxml.Type,
  xlinkrole: Option[String] = None,
  xlinktitle: Option[String] = None,
  xlinkshow: musicxml.Show,
  xlinkactuate: musicxml.Actuate)


/** The print-attributes group is used by the print element. The new-system and new-page attributes indicate whether to force a system or page break, or to force the current music onto the same system or page as the preceding music. Normally this is the first music data within a measure. If used in multi-part music, they should be placed in the same positions within each part, or the results are undefined. The page-number attribute sets the number of a new page; it is ignored if new-page is not "yes". Version 2.0 adds a blank-page attribute. This is a positive integer value that specifies the number of blank pages to insert before the current measure. It is ignored if new-page is not "yes". These blank pages have no music, but may have text or images specified by the credit element. This is used to allow a combination of pages that are all text, or all text and images, together with pages of music.

The staff-spacing attribute specifies spacing between multiple staves in tenths of staff space. This is deprecated as of Version 1.1; the staff-layout element should be used instead. If both are present, the staff-layout values take priority.
*/
case class Printu45attributes(staffu45spacing: Option[BigDecimal] = None,
  newu45system: Option[musicxml.Yesu45no] = None,
  newu45page: Option[musicxml.Yesu45no] = None,
  blanku45page: Option[BigInt] = None,
  pageu45number: Option[String] = None)


/** The y-position attribute group is used for elements like stems where specifying y position is common, but specifying x position is rare.
*/
case class Yu45position(defaultu45x: Option[BigDecimal] = None,
  defaultu45y: Option[BigDecimal] = None,
  relativeu45x: Option[BigDecimal] = None,
  relativeu45y: Option[BigDecimal] = None)


/** The valign-image attribute is used to indicate vertical alignment for images and graphics, so it removes the baseline value. Defaults are implementation-dependent.
*/
case class Valignu45imageType(valign: Option[musicxml.Valignu45image] = None)


/** The trill-sound attribute group includes attributes used to guide the sound of trills, mordents, turns, shakes, and wavy lines, based on MuseData sound suggestions. The default choices are:

	start-note = "upper"
	trill-step = "whole"
	two-note-turn = "none"
	accelerate = "no"
	beats = "4".

Second-beat and last-beat are percentages for landing on the indicated beat, with defaults of 25 and 75 respectively.

For mordent and inverted-mordent elements, the defaults are different:

	The default start-note is "main", not "upper".
	The default for beats is "3", not "4".
	The default for second-beat is "12", not "25".
	The default for last-beat is "24", not "75".
*/
case class Trillu45sound(startu45note: Option[musicxml.Startu45note] = None,
  trillu45step: Option[musicxml.Trillu45step] = None,
  twou45noteu45turn: Option[musicxml.Twou45noteu45turn] = None,
  accelerate: Option[musicxml.Yesu45no] = None,
  beats: Option[BigDecimal] = None,
  secondu45beat: Option[BigDecimal] = None,
  lastu45beat: Option[BigDecimal] = None)


/** The text-formatting attribute group collects the common formatting attributes for text elements. Default values may differ across the elements that use this group.
*/
case class Textu45formatting(justify: Option[musicxml.Leftu45centeru45right] = None,
  defaultu45x: Option[BigDecimal] = None,
  defaultu45y: Option[BigDecimal] = None,
  relativeu45x: Option[BigDecimal] = None,
  relativeu45y: Option[BigDecimal] = None,
  fontu45family: Option[String] = None,
  fontu45style: Option[musicxml.Fontu45style] = None,
  fontu45size: Option[String] = None,
  fontu45weight: Option[musicxml.Fontu45weight] = None,
  color: Option[String] = None,
  halign: Option[musicxml.Leftu45centeru45right] = None,
  valign: Option[musicxml.Valign] = None,
  underline: Option[BigInt] = None,
  overline: Option[BigInt] = None,
  lineu45through: Option[BigInt] = None,
  rotation: Option[BigDecimal] = None,
  letteru45spacing: Option[String] = None,
  lineu45height: Option[String] = None,
  xmllang: Option[String] = None,
  xmlspace: Option[String] = None,
  dir: Option[musicxml.Textu45direction] = None,
  enclosure: Option[musicxml.Enclosureu45shape] = None)


/** The text-decoration attribute group is based on the similar feature in XHTML and CSS. It allows for text to be underlined, overlined, or struck-through. It extends the CSS version by allow double or triple lines instead of just being on or off.
*/
case class Textu45decoration(underline: Option[BigInt] = None,
  overline: Option[BigInt] = None,
  lineu45through: Option[BigInt] = None)


/** The smufl attribute group is used to indicate a particular Standard Music Font Layout (SMuFL) character. Sometimes this is a formatting choice, and sometimes this is a refinement of the semantic meaning of an element.
*/
case class Smufl(smufl: Option[String] = None)


/** The print-style-align attribute group adds the halign and valign attributes to the position, font, and color attributes.
*/
case class Printu45styleu45align(defaultu45x: Option[BigDecimal] = None,
  defaultu45y: Option[BigDecimal] = None,
  relativeu45x: Option[BigDecimal] = None,
  relativeu45y: Option[BigDecimal] = None,
  fontu45family: Option[String] = None,
  fontu45style: Option[musicxml.Fontu45style] = None,
  fontu45size: Option[String] = None,
  fontu45weight: Option[musicxml.Fontu45weight] = None,
  color: Option[String] = None,
  halign: Option[musicxml.Leftu45centeru45right] = None,
  valign: Option[musicxml.Valign] = None)


/** The print-spacing attribute controls whether or not spacing is left for an invisible note or object. It is used only if no note, dot, or lyric is being printed. The value is yes (leave spacing) by default.
*/
case class Printu45spacing(printu45spacing: Option[musicxml.Yesu45no] = None)


/** The position attributes are based on MuseData print suggestions. For most elements, any program will compute a default x and y position. The position attributes let this be changed two ways.

The default-x and default-y attributes change the computation of the default position. For most elements, the origin is changed relative to the left-hand side of the note or the musical position within the bar (x) and the top line of the staff (y).

For the following elements, the default-x value changes the origin relative to the start of the current measure:

	- note
	- figured-bass
	- harmony
	- link
	- directive
	- measure-numbering
	- all descendants of the part-list element
	- all children of the direction-type element

This origin is from the start of the entire measure, at either the left barline or the start of the system.

When the default-x attribute is used within a child element of the part-name-display, part-abbreviation-display, group-name-display, or group-abbreviation-display elements, it changes the origin relative to the start of the first measure on the system. These values are used when the current measure or a succeeding measure starts a new system. The same change of origin is used for the group-symbol element.

For the note, figured-bass, and harmony elements, the default-x value is considered to have adjusted the musical position within the bar for its descendant elements.

Since the credit-words and credit-image elements are not related to a measure, in these cases the default-x and default-y attributes adjust the origin relative to the bottom left-hand corner of the specified page.

The relative-x and relative-y attributes change the position relative to the default position, either as computed by the individual program, or as overridden by the default-x and default-y attributes.

Positive x is right, negative x is left; positive y is up, negative y is down. All units are in tenths of interline space. For stems, positive relative-y lengthens a stem while negative relative-y shortens it.

The default-x and default-y position attributes provide higher-resolution positioning data than related features such as the placement attribute and the offset element. Applications reading a MusicXML file that can understand both features should generally rely on the default-x and default-y attributes for their greater accuracy. For the relative-x and relative-y attributes, the offset element, placement attribute, and directive attribute provide context for the relative position information, so the two features should be interpreted together.

As elsewhere in the MusicXML format, tenths are the global tenths defined by the scaling element, not the local tenths of a staff resized by the staff-size element.
*/
case class Position(defaultu45x: Option[BigDecimal] = None,
  defaultu45y: Option[BigDecimal] = None,
  relativeu45x: Option[BigDecimal] = None,
  relativeu45y: Option[BigDecimal] = None)


/** The orientation attribute indicates whether slurs and ties are overhand (tips down) or underhand (tips up). This is distinct from the placement attribute used by any notation type.
*/
case class Orientation(orientation: Option[musicxml.Overu45under] = None)


/** The line-type attribute distinguishes between solid, dashed, dotted, and wavy lines.
*/
case class Lineu45typeType(lineu45type: Option[musicxml.Lineu45type] = None)


/** The line-length attribute distinguishes between different line lengths for doit, falloff, plop, and scoop articulations.
*/
case class Lineu45lengthType(lineu45length: Option[musicxml.Lineu45length] = None)


/** The level-display attribute group specifies three common ways to indicate editorial indications: putting parentheses or square brackets around a symbol, or making the symbol a different size. If not specified, they are left to application defaults. It is used by the level and accidental elements.
*/
case class Levelu45display(parentheses: Option[musicxml.Yesu45no] = None,
  bracket: Option[musicxml.Yesu45no] = None,
  size: Option[musicxml.Symbolu45size] = None)


/** The justify attribute is used to indicate left, center, or right justification. The default value varies for different elements. For elements where the justify attribute is present but the halign attribute is not, the justify attribute indicates horizontal alignment as well as justification.
*/
case class Justify(justify: Option[musicxml.Leftu45centeru45right] = None)


/** The font attribute group gathers together attributes for determining the font within a credit or direction. They are based on the text styles for Cascading Style Sheets. The font-family is a comma-separated list of font names. These can be specific font styles such as Maestro or Opus, or one of several generic font styles: music, engraved, handwritten, text, serif, sans-serif, handwritten, cursive, fantasy, and monospace. The music, engraved, and handwritten values refer to music fonts; the rest refer to text fonts. The fantasy style refers to decorative text such as found in older German-style printing. The font-style can be normal or italic. The font-size can be one of the CSS sizes (xx-small, x-small, small, medium, large, x-large, xx-large) or a numeric point size. The font-weight can be normal or bold. The default is application-dependent, but is a text font vs. a music font.
*/
case class Font(fontu45family: Option[String] = None,
  fontu45style: Option[musicxml.Fontu45style] = None,
  fontu45size: Option[String] = None,
  fontu45weight: Option[musicxml.Fontu45weight] = None)


/** The document-attributes attribute group is used to specify the attributes for an entire MusicXML document. Currently this is used for the version attribute.

The version attribute was added in Version 1.1 for the score-partwise and score-timewise documents. It provides an easier way to get version information than through the MusicXML public ID. The default value is 1.0 to make it possible for programs that handle later versions to distinguish earlier version files reliably. Programs that write MusicXML 1.1 or later files should set this attribute.
*/
case class Documentu45attributes(version: String)


/** The dashed-formatting entity represents the length of dashes and spaces in a dashed line. Both the dash-length and space-length attributes are represented in tenths. These attributes are ignored if the corresponding line-type attribute is not dashed.
*/
case class Dashedu45formatting(dashu45length: Option[BigDecimal] = None,
  spaceu45length: Option[BigDecimal] = None)


/** The bezier attribute group is used to indicate the curvature of slurs and ties, representing the control points for a cubic bezier curve. For ties, the bezier attribute group is used with the tied element.

Normal slurs, S-shaped slurs, and ties need only two bezier points: one associated with the start of the slur or tie, the other with the stop. Complex slurs and slurs divided over system breaks can specify additional bezier data at slur elements with a continue type.

The bezier-x, bezier-y, and bezier-offset attributes describe the outgoing bezier point for slurs and ties with a start type, and the incoming bezier point for slurs and ties with types of stop or continue. The bezier-x2, bezier-y2, and bezier-offset2 attributes are only valid with slurs of type continue, and describe the outgoing bezier point.

The bezier-x, bezier-y, bezier-x2, and bezier-y2 attributes are specified in tenths, relative to any position settings associated with the slur or tied element. The bezier-offset and bezier-offset2 attributes are measured in terms of musical divisions, like the offset element. 

The bezier-offset and bezier-offset2 attributes are deprecated as of MusicXML 3.1. If both the bezier-x and bezier-offset attributes are present, the bezier-x attribute takes priority. Similarly, the bezier-x2 attribute takes priority over the bezier-offset2 attribute. The two types of bezier attributes are not additive.
*/
case class Bezier(bezieru45x: Option[BigDecimal] = None,
  bezieru45y: Option[BigDecimal] = None,
  bezieru45x2: Option[BigDecimal] = None,
  bezieru45y2: Option[BigDecimal] = None,
  bezieru45offset: Option[BigDecimal] = None,
  bezieru45offset2: Option[BigDecimal] = None)


/** The bend-sound type is used for bend and slide elements, and is similar to the trill-sound attribute group. Here the beats element refers to the number of discrete elements (like MIDI pitch bends) used to represent a continuous bend or slide. The first-beat indicates the percentage of the direction for starting a bend; the last-beat the percentage for ending it. The default choices are:

	accelerate = "no"
	beats = "4"
	first-beat = "25"
	last-beat = "75"
*/
case class Bendu45sound(accelerate: Option[musicxml.Yesu45no] = None,
  beats: Option[BigDecimal] = None,
  firstu45beat: Option[BigDecimal] = None,
  lastu45beat: Option[BigDecimal] = None)


/** The color attribute group indicates the color of an element.
*/
case class Color(color: Option[String] = None)


/** The directive attribute changes the default-x position of a direction. It indicates that the left-hand side of the direction is aligned with the left-hand side of the time signature. If no time signature is present, it is aligned with the left-hand side of the first music notational element in the measure. If a default-x, justify, or halign attribute is present, it overrides the directive attribute.
*/
case class DirectiveType(directive: Option[musicxml.Yesu45no] = None)


/** The enclosure attribute group is used to specify the formatting of an enclosure around text or symbols.
*/
case class Enclosure(enclosure: Option[musicxml.Enclosureu45shape] = None)


/** In cases where text extends over more than one line, horizontal alignment and justify values can be different. The most typical case is for credits, such as:

	Words and music by
	  Pat Songwriter

Typically this type of credit is aligned to the right, so that the position information refers to the right-most part of the text. But in this example, the text is center-justified, not right-justified.

The halign attribute is used in these situations. If it is not present, its value is the same as for the justify attribute.
*/
case class Halign(halign: Option[musicxml.Leftu45centeru45right] = None)


/** The letter-spacing attribute specifies text tracking. Values are either "normal" or a number representing the number of ems to add between each letter. The number may be negative in order to subtract space. The default is normal, which allows flexibility of letter-spacing for purposes of text justification.
*/
case class Letteru45spacing(letteru45spacing: Option[String] = None)


/** The line-height attribute specifies text leading. Values are either "normal" or a number representing the percentage of the current font height to use for leading. The default is "normal". The exact normal value is implementation-dependent, but values between 100 and 120 are recommended.
*/
case class Lineu45height(lineu45height: Option[String] = None)


/** The line-shape attribute distinguishes between straight and curved lines.
*/
case class Lineu45shapeType(lineu45shape: Option[musicxml.Lineu45shape] = None)


/** The optional-unique-id attribute group allows an element to optionally specify an ID that is unique to the entire document. This attribute group is not used for a required id attribute, or for an id attribute that specifies an id reference.
*/
case class Optionalu45uniqueu45id(id: Option[String] = None)


/** The placement attribute indicates whether something is above or below another element, such as a note or a notation.
*/
case class Placement(placement: Option[musicxml.Aboveu45below] = None)


/** The print-object attribute specifies whether or not to print an object (e.g. a note or a rest). It is yes by default.
*/
case class Printu45object(printu45object: Option[musicxml.Yesu45no] = None)


/** The print-style attribute group collects the most popular combination of printing attributes: position, font, and color.
*/
case class Printu45style(defaultu45x: Option[BigDecimal] = None,
  defaultu45y: Option[BigDecimal] = None,
  relativeu45x: Option[BigDecimal] = None,
  relativeu45y: Option[BigDecimal] = None,
  fontu45family: Option[String] = None,
  fontu45style: Option[musicxml.Fontu45style] = None,
  fontu45size: Option[String] = None,
  fontu45weight: Option[musicxml.Fontu45weight] = None,
  color: Option[String] = None)


/** The printout attribute group collects the different controls over printing an object (e.g. a note or rest) and its parts, including augmentation dots and lyrics. This is especially useful for notes that overlap in different voices, or for chord sheets that contain lyrics and chords but no melody.

By default, all these attributes are set to yes. If print-object is set to no, the print-dot and print-lyric attributes are interpreted to also be set to no if they are not present.
*/
case class Printout(printu45object: Option[musicxml.Yesu45no] = None,
  printu45dot: Option[musicxml.Yesu45no] = None,
  printu45spacing: Option[musicxml.Yesu45no] = None,
  printu45lyric: Option[musicxml.Yesu45no] = None)


/** The symbol-formatting attribute group collects the common formatting attributes for musical symbols. Default values may differ across the elements that use this group.
*/
case class Symbolu45formatting(justify: Option[musicxml.Leftu45centeru45right] = None,
  defaultu45x: Option[BigDecimal] = None,
  defaultu45y: Option[BigDecimal] = None,
  relativeu45x: Option[BigDecimal] = None,
  relativeu45y: Option[BigDecimal] = None,
  fontu45family: Option[String] = None,
  fontu45style: Option[musicxml.Fontu45style] = None,
  fontu45size: Option[String] = None,
  fontu45weight: Option[musicxml.Fontu45weight] = None,
  color: Option[String] = None,
  halign: Option[musicxml.Leftu45centeru45right] = None,
  valign: Option[musicxml.Valign] = None,
  underline: Option[BigInt] = None,
  overline: Option[BigInt] = None,
  lineu45through: Option[BigInt] = None,
  rotation: Option[BigDecimal] = None,
  letteru45spacing: Option[String] = None,
  lineu45height: Option[String] = None,
  dir: Option[musicxml.Textu45direction] = None,
  enclosure: Option[musicxml.Enclosureu45shape] = None)


/** The text-direction attribute is used to adjust and override the Unicode bidirectional text algorithm, similar to the W3C Internationalization Tag Set recommendation.
*/
case class Textu45directionType(dir: Option[musicxml.Textu45direction] = None)


/** The rotation attribute is used to rotate text around the alignment point specified by the halign and valign attributes. Positive values are clockwise rotations, while negative values are counter-clockwise rotations.
*/
case class Textu45rotation(rotation: Option[BigDecimal] = None)


/** The valign attribute is used to indicate vertical alignment to the top, middle, bottom, or baseline of the text. Defaults are implementation-dependent.
*/
case class ValignType(valign: Option[musicxml.Valign] = None)


/** The x-position attribute group is used for elements like notes where specifying x position is common, but specifying y position is rare.
*/
case class Xu45position(defaultu45x: Option[BigDecimal] = None,
  defaultu45y: Option[BigDecimal] = None,
  relativeu45x: Option[BigDecimal] = None,
  relativeu45y: Option[BigDecimal] = None)


/** The image-attributes group is used to include graphical images in a score. The required source attribute is the URL for the image file. The required type attribute is the MIME type for the image file format. Typical choices include application/postscript, image/gif, image/jpeg, image/png, and image/tiff. The optional height and width attributes are used to size and scale an image. The image should be scaled independently in X and Y if both height and width are specified. If only one attribute is specified, the image should be scaled proportionally to fit in the specified dimension.
*/
case class Imageu45attributes(source: java.net.URI,
  typeValue: String,
  height: Option[BigDecimal] = None,
  width: Option[BigDecimal] = None,
  defaultu45x: Option[BigDecimal] = None,
  defaultu45y: Option[BigDecimal] = None,
  relativeu45x: Option[BigDecimal] = None,
  relativeu45y: Option[BigDecimal] = None,
  halign: Option[musicxml.Leftu45centeru45right] = None,
  valign: Option[musicxml.Valignu45image] = None)


/** The element and position attributes are new as of Version 2.0. They allow for bookmarks and links to be positioned at higher resolution than the level of music-data elements. When no element and position attributes are present, the bookmark or link element refers to the next sibling element in the MusicXML file. The element attribute specifies an element type for a descendant of the next sibling element that is not a link or bookmark. The position attribute specifies the position of this descendant element, where the first position is 1. The position attribute is ignored if the element attribute is not present. For instance, an element value of "beam" and a position value of "2" defines the link or bookmark to refer to the second beam descendant of the next sibling element that is not a link or bookmark. This is equivalent to an XPath test of [.//beam[2]] done in the context of the sibling element.
*/
case class Elementu45position(element: Option[String] = None,
  position: Option[BigInt] = None)


/** The group-name-text attribute group is used by the group-name and group-abbreviation elements. The print-style and justify attribute groups are deprecated in MusicXML 2.0 in favor of the new group-name-display and group-abbreviation-display elements.
*/
case class Groupu45nameu45text(defaultu45x: Option[BigDecimal] = None,
  defaultu45y: Option[BigDecimal] = None,
  relativeu45x: Option[BigDecimal] = None,
  relativeu45y: Option[BigDecimal] = None,
  fontu45family: Option[String] = None,
  fontu45style: Option[musicxml.Fontu45style] = None,
  fontu45size: Option[String] = None,
  fontu45weight: Option[musicxml.Fontu45weight] = None,
  color: Option[String] = None,
  justify: Option[musicxml.Leftu45centeru45right] = None)


/** In either partwise or timewise format, the part element has an id attribute that is an IDREF back to a score-part in the part-list.
*/
case class Partu45attributes(id: String)

