// Generated by <a href="http://scalaxb.org/">scalaxb</a>.
package musicxml

import scala.concurrent.{ Future, ExecutionContext }


/**
usage:
val obj = scalaxb.fromXML[musicxml.Foo](node)
val document = scalaxb.toXML[musicxml.Foo](obj, "foo", musicxml.defaultScope)
**/
object `package` extends XMLProtocol { }

trait XMLProtocol extends scalaxb.XMLStandardTypes {
  val defaultScope = scalaxb.toScope(Some("tns") -> "http://www.webserviceX.NET/",
    Some("xlink") -> "http://www.w3.org/1999/xlink",
    Some("xml") -> "http://www.w3.org/XML/1998/namespace",
    Some("xs") -> "http://www.w3.org/2001/XMLSchema",
    Some("xsi") -> "http://www.w3.org/2001/XMLSchema-instance")
  implicit lazy val Musicxml_Aboveu45belowFormat: scalaxb.XMLFormat[musicxml.Aboveu45below] = new DefaultMusicxml_Aboveu45belowFormat {}
  implicit lazy val Musicxml_Cssu45fontu45sizeFormat: scalaxb.XMLFormat[musicxml.Cssu45fontu45size] = new DefaultMusicxml_Cssu45fontu45sizeFormat {}
  implicit lazy val Musicxml_Enclosureu45shapeFormat: scalaxb.XMLFormat[musicxml.Enclosureu45shape] = new DefaultMusicxml_Enclosureu45shapeFormat {}
  implicit lazy val Musicxml_Fermatau45shapeFormat: scalaxb.XMLFormat[musicxml.Fermatau45shape] = new DefaultMusicxml_Fermatau45shapeFormat {}
  implicit lazy val Musicxml_Fontu45styleFormat: scalaxb.XMLFormat[musicxml.Fontu45style] = new DefaultMusicxml_Fontu45styleFormat {}
  implicit lazy val Musicxml_Fontu45weightFormat: scalaxb.XMLFormat[musicxml.Fontu45weight] = new DefaultMusicxml_Fontu45weightFormat {}
  implicit lazy val Musicxml_Leftu45centeru45rightFormat: scalaxb.XMLFormat[musicxml.Leftu45centeru45right] = new DefaultMusicxml_Leftu45centeru45rightFormat {}
  implicit lazy val Musicxml_Leftu45rightFormat: scalaxb.XMLFormat[musicxml.Leftu45right] = new DefaultMusicxml_Leftu45rightFormat {}
  implicit lazy val Musicxml_Lineu45lengthFormat: scalaxb.XMLFormat[musicxml.Lineu45length] = new DefaultMusicxml_Lineu45lengthFormat {}
  implicit lazy val Musicxml_Lineu45shapeFormat: scalaxb.XMLFormat[musicxml.Lineu45shape] = new DefaultMusicxml_Lineu45shapeFormat {}
  implicit lazy val Musicxml_Lineu45typeFormat: scalaxb.XMLFormat[musicxml.Lineu45type] = new DefaultMusicxml_Lineu45typeFormat {}
  implicit lazy val Musicxml_MuteFormat: scalaxb.XMLFormat[musicxml.Mute] = new DefaultMusicxml_MuteFormat {}
  implicit lazy val Musicxml_Overu45underFormat: scalaxb.XMLFormat[musicxml.Overu45under] = new DefaultMusicxml_Overu45underFormat {}
  implicit lazy val Musicxml_Semiu45pitchedFormat: scalaxb.XMLFormat[musicxml.Semiu45pitched] = new DefaultMusicxml_Semiu45pitchedFormat {}
  implicit lazy val Musicxml_Startu45noteFormat: scalaxb.XMLFormat[musicxml.Startu45note] = new DefaultMusicxml_Startu45noteFormat {}
  implicit lazy val Musicxml_Startu45stopFormat: scalaxb.XMLFormat[musicxml.Startu45stop] = new DefaultMusicxml_Startu45stopFormat {}
  implicit lazy val Musicxml_Startu45stopu45continueFormat: scalaxb.XMLFormat[musicxml.Startu45stopu45continue] = new DefaultMusicxml_Startu45stopu45continueFormat {}
  implicit lazy val Musicxml_Startu45stopu45singleFormat: scalaxb.XMLFormat[musicxml.Startu45stopu45single] = new DefaultMusicxml_Startu45stopu45singleFormat {}
  implicit lazy val Musicxml_Symbolu45sizeFormat: scalaxb.XMLFormat[musicxml.Symbolu45size] = new DefaultMusicxml_Symbolu45sizeFormat {}
  implicit lazy val Musicxml_Textu45directionFormat: scalaxb.XMLFormat[musicxml.Textu45direction] = new DefaultMusicxml_Textu45directionFormat {}
  implicit lazy val Musicxml_Tiedu45typeFormat: scalaxb.XMLFormat[musicxml.Tiedu45type] = new DefaultMusicxml_Tiedu45typeFormat {}
  implicit lazy val Musicxml_Topu45bottomFormat: scalaxb.XMLFormat[musicxml.Topu45bottom] = new DefaultMusicxml_Topu45bottomFormat {}
  implicit lazy val Musicxml_Tremolou45typeFormat: scalaxb.XMLFormat[musicxml.Tremolou45type] = new DefaultMusicxml_Tremolou45typeFormat {}
  implicit lazy val Musicxml_Trillu45stepFormat: scalaxb.XMLFormat[musicxml.Trillu45step] = new DefaultMusicxml_Trillu45stepFormat {}
  implicit lazy val Musicxml_Twou45noteu45turnFormat: scalaxb.XMLFormat[musicxml.Twou45noteu45turn] = new DefaultMusicxml_Twou45noteu45turnFormat {}
  implicit lazy val Musicxml_Upu45downFormat: scalaxb.XMLFormat[musicxml.Upu45down] = new DefaultMusicxml_Upu45downFormat {}
  implicit lazy val Musicxml_Uprightu45invertedFormat: scalaxb.XMLFormat[musicxml.Uprightu45inverted] = new DefaultMusicxml_Uprightu45invertedFormat {}
  implicit lazy val Musicxml_ValignFormat: scalaxb.XMLFormat[musicxml.Valign] = new DefaultMusicxml_ValignFormat {}
  implicit lazy val Musicxml_Valignu45imageFormat: scalaxb.XMLFormat[musicxml.Valignu45image] = new DefaultMusicxml_Valignu45imageFormat {}
  implicit lazy val Musicxml_Cancelu45locationFormat: scalaxb.XMLFormat[musicxml.Cancelu45location] = new DefaultMusicxml_Cancelu45locationFormat {}
  implicit lazy val Musicxml_Clefu45signFormat: scalaxb.XMLFormat[musicxml.Clefu45sign] = new DefaultMusicxml_Clefu45signFormat {}
  implicit lazy val Musicxml_Showu45fretsFormat: scalaxb.XMLFormat[musicxml.Showu45frets] = new DefaultMusicxml_Showu45fretsFormat {}
  implicit lazy val Musicxml_Staffu45typeFormat: scalaxb.XMLFormat[musicxml.Staffu45type] = new DefaultMusicxml_Staffu45typeFormat {}
  implicit lazy val Musicxml_Timeu45relationFormat: scalaxb.XMLFormat[musicxml.Timeu45relation] = new DefaultMusicxml_Timeu45relationFormat {}
  implicit lazy val Musicxml_Timeu45separatorFormat: scalaxb.XMLFormat[musicxml.Timeu45separator] = new DefaultMusicxml_Timeu45separatorFormat {}
  implicit lazy val Musicxml_Timeu45symbolFormat: scalaxb.XMLFormat[musicxml.Timeu45symbol] = new DefaultMusicxml_Timeu45symbolFormat {}
  implicit lazy val Musicxml_Backwardu45forwardFormat: scalaxb.XMLFormat[musicxml.Backwardu45forward] = new DefaultMusicxml_Backwardu45forwardFormat {}
  implicit lazy val Musicxml_Baru45styleFormat: scalaxb.XMLFormat[musicxml.Baru45style] = new DefaultMusicxml_Baru45styleFormat {}
  implicit lazy val Musicxml_Rightu45leftu45middleFormat: scalaxb.XMLFormat[musicxml.Rightu45leftu45middle] = new DefaultMusicxml_Rightu45leftu45middleFormat {}
  implicit lazy val Musicxml_Startu45stopu45discontinueFormat: scalaxb.XMLFormat[musicxml.Startu45stopu45discontinue] = new DefaultMusicxml_Startu45stopu45discontinueFormat {}
  implicit lazy val Musicxml_WingedFormat: scalaxb.XMLFormat[musicxml.Winged] = new DefaultMusicxml_WingedFormat {}
  implicit lazy val Musicxml_Beateru45valueFormat: scalaxb.XMLFormat[musicxml.Beateru45value] = new DefaultMusicxml_Beateru45valueFormat {}
  implicit lazy val Musicxml_Degreeu45symbolu45valueFormat: scalaxb.XMLFormat[musicxml.Degreeu45symbolu45value] = new DefaultMusicxml_Degreeu45symbolu45valueFormat {}
  implicit lazy val Musicxml_Degreeu45typeu45valueFormat: scalaxb.XMLFormat[musicxml.Degreeu45typeu45value] = new DefaultMusicxml_Degreeu45typeu45valueFormat {}
  implicit lazy val Musicxml_EffectFormat: scalaxb.XMLFormat[musicxml.Effect] = new DefaultMusicxml_EffectFormat {}
  implicit lazy val Musicxml_Glassu45valueFormat: scalaxb.XMLFormat[musicxml.Glassu45value] = new DefaultMusicxml_Glassu45valueFormat {}
  implicit lazy val Musicxml_Harmonyu45typeFormat: scalaxb.XMLFormat[musicxml.Harmonyu45type] = new DefaultMusicxml_Harmonyu45typeFormat {}
  implicit lazy val Musicxml_Kindu45valueFormat: scalaxb.XMLFormat[musicxml.Kindu45value] = new DefaultMusicxml_Kindu45valueFormat {}
  implicit lazy val Musicxml_Lineu45endFormat: scalaxb.XMLFormat[musicxml.Lineu45end] = new DefaultMusicxml_Lineu45endFormat {}
  implicit lazy val Musicxml_Measureu45numberingu45valueFormat: scalaxb.XMLFormat[musicxml.Measureu45numberingu45value] = new DefaultMusicxml_Measureu45numberingu45valueFormat {}
  implicit lazy val Musicxml_MembraneFormat: scalaxb.XMLFormat[musicxml.Membrane] = new DefaultMusicxml_MembraneFormat {}
  implicit lazy val Musicxml_MetalFormat: scalaxb.XMLFormat[musicxml.Metal] = new DefaultMusicxml_MetalFormat {}
  implicit lazy val Musicxml_Onu45offFormat: scalaxb.XMLFormat[musicxml.Onu45off] = new DefaultMusicxml_Onu45offFormat {}
  implicit lazy val Musicxml_Pedalu45typeFormat: scalaxb.XMLFormat[musicxml.Pedalu45type] = new DefaultMusicxml_Pedalu45typeFormat {}
  implicit lazy val Musicxml_Pitchedu45valueFormat: scalaxb.XMLFormat[musicxml.Pitchedu45value] = new DefaultMusicxml_Pitchedu45valueFormat {}
  implicit lazy val Musicxml_Principalu45voiceu45symbolFormat: scalaxb.XMLFormat[musicxml.Principalu45voiceu45symbol] = new DefaultMusicxml_Principalu45voiceu45symbolFormat {}
  implicit lazy val Musicxml_Staffu45divideu45symbolFormat: scalaxb.XMLFormat[musicxml.Staffu45divideu45symbol] = new DefaultMusicxml_Staffu45divideu45symbolFormat {}
  implicit lazy val Musicxml_Startu45stopu45changeu45continueFormat: scalaxb.XMLFormat[musicxml.Startu45stopu45changeu45continue] = new DefaultMusicxml_Startu45stopu45changeu45continueFormat {}
  implicit lazy val Musicxml_Tipu45directionFormat: scalaxb.XMLFormat[musicxml.Tipu45direction] = new DefaultMusicxml_Tipu45directionFormat {}
  implicit lazy val Musicxml_Sticku45locationFormat: scalaxb.XMLFormat[musicxml.Sticku45location] = new DefaultMusicxml_Sticku45locationFormat {}
  implicit lazy val Musicxml_Sticku45materialFormat: scalaxb.XMLFormat[musicxml.Sticku45material] = new DefaultMusicxml_Sticku45materialFormat {}
  implicit lazy val Musicxml_Sticku45typeFormat: scalaxb.XMLFormat[musicxml.Sticku45type] = new DefaultMusicxml_Sticku45typeFormat {}
  implicit lazy val Musicxml_Upu45downu45stopu45continueFormat: scalaxb.XMLFormat[musicxml.Upu45downu45stopu45continue] = new DefaultMusicxml_Upu45downu45stopu45continueFormat {}
  implicit lazy val Musicxml_Wedgeu45typeFormat: scalaxb.XMLFormat[musicxml.Wedgeu45type] = new DefaultMusicxml_Wedgeu45typeFormat {}
  implicit lazy val Musicxml_WoodFormat: scalaxb.XMLFormat[musicxml.Wood] = new DefaultMusicxml_WoodFormat {}
  implicit lazy val Musicxml_Marginu45typeFormat: scalaxb.XMLFormat[musicxml.Marginu45type] = new DefaultMusicxml_Marginu45typeFormat {}
  implicit lazy val Musicxml_Noteu45sizeu45typeFormat: scalaxb.XMLFormat[musicxml.Noteu45sizeu45type] = new DefaultMusicxml_Noteu45sizeu45typeFormat {}
  implicit lazy val Musicxml_Accidentalu45valueFormat: scalaxb.XMLFormat[musicxml.Accidentalu45value] = new DefaultMusicxml_Accidentalu45valueFormat {}
  implicit lazy val Musicxml_Arrowu45directionFormat: scalaxb.XMLFormat[musicxml.Arrowu45direction] = new DefaultMusicxml_Arrowu45directionFormat {}
  implicit lazy val Musicxml_Arrowu45styleFormat: scalaxb.XMLFormat[musicxml.Arrowu45style] = new DefaultMusicxml_Arrowu45styleFormat {}
  implicit lazy val Musicxml_Beamu45valueFormat: scalaxb.XMLFormat[musicxml.Beamu45value] = new DefaultMusicxml_Beamu45valueFormat {}
  implicit lazy val Musicxml_Breathu45marku45valueFormat: scalaxb.XMLFormat[musicxml.Breathu45marku45value] = new DefaultMusicxml_Breathu45marku45valueFormat {}
  implicit lazy val Musicxml_Caesurau45valueFormat: scalaxb.XMLFormat[musicxml.Caesurau45value] = new DefaultMusicxml_Caesurau45valueFormat {}
  implicit lazy val Musicxml_Circularu45arrowFormat: scalaxb.XMLFormat[musicxml.Circularu45arrow] = new DefaultMusicxml_Circularu45arrowFormat {}
  implicit lazy val Musicxml_FanFormat: scalaxb.XMLFormat[musicxml.Fan] = new DefaultMusicxml_FanFormat {}
  implicit lazy val Musicxml_Handbellu45valueFormat: scalaxb.XMLFormat[musicxml.Handbellu45value] = new DefaultMusicxml_Handbellu45valueFormat {}
  implicit lazy val Musicxml_Harmonu45closedu45locationFormat: scalaxb.XMLFormat[musicxml.Harmonu45closedu45location] = new DefaultMusicxml_Harmonu45closedu45locationFormat {}
  implicit lazy val Musicxml_Harmonu45closedu45valueFormat: scalaxb.XMLFormat[musicxml.Harmonu45closedu45value] = new DefaultMusicxml_Harmonu45closedu45valueFormat {}
  implicit lazy val Musicxml_Holeu45closedu45locationFormat: scalaxb.XMLFormat[musicxml.Holeu45closedu45location] = new DefaultMusicxml_Holeu45closedu45locationFormat {}
  implicit lazy val Musicxml_Holeu45closedu45valueFormat: scalaxb.XMLFormat[musicxml.Holeu45closedu45value] = new DefaultMusicxml_Holeu45closedu45valueFormat {}
  implicit lazy val Musicxml_Noteu45typeu45valueFormat: scalaxb.XMLFormat[musicxml.Noteu45typeu45value] = new DefaultMusicxml_Noteu45typeu45valueFormat {}
  implicit lazy val Musicxml_Noteheadu45valueFormat: scalaxb.XMLFormat[musicxml.Noteheadu45value] = new DefaultMusicxml_Noteheadu45valueFormat {}
  implicit lazy val Musicxml_Showu45tupletFormat: scalaxb.XMLFormat[musicxml.Showu45tuplet] = new DefaultMusicxml_Showu45tupletFormat {}
  implicit lazy val Musicxml_Stemu45valueFormat: scalaxb.XMLFormat[musicxml.Stemu45value] = new DefaultMusicxml_Stemu45valueFormat {}
  implicit lazy val Musicxml_StepFormat: scalaxb.XMLFormat[musicxml.Step] = new DefaultMusicxml_StepFormat {}
  implicit lazy val Musicxml_SyllabicFormat: scalaxb.XMLFormat[musicxml.Syllabic] = new DefaultMusicxml_SyllabicFormat {}
  implicit lazy val Musicxml_Tapu45handFormat: scalaxb.XMLFormat[musicxml.Tapu45hand] = new DefaultMusicxml_Tapu45handFormat {}
  implicit lazy val Musicxml_Groupu45barlineu45valueFormat: scalaxb.XMLFormat[musicxml.Groupu45barlineu45value] = new DefaultMusicxml_Groupu45barlineu45valueFormat {}
  implicit lazy val Musicxml_Groupu45symbolu45valueFormat: scalaxb.XMLFormat[musicxml.Groupu45symbolu45value] = new DefaultMusicxml_Groupu45symbolu45valueFormat {}
  implicit lazy val Musicxml_Accidentalu45textFormat: scalaxb.XMLFormat[musicxml.Accidentalu45text] = new DefaultMusicxml_Accidentalu45textFormat {}
  implicit lazy val Musicxml_CodaFormat: scalaxb.XMLFormat[musicxml.Coda] = new DefaultMusicxml_CodaFormat {}
  implicit lazy val Musicxml_DynamicsFormat: scalaxb.XMLFormat[musicxml.Dynamics] = new DefaultMusicxml_DynamicsFormat {}
  implicit lazy val Musicxml_EmptyFormat: scalaxb.XMLFormat[musicxml.Empty] = new DefaultMusicxml_EmptyFormat {}
  implicit lazy val Musicxml_Emptyu45placementableFormat: scalaxb.XMLFormat[musicxml.Emptyu45placementable] = new DefaultMusicxml_Emptyu45placementableFormat {}
  implicit lazy val Musicxml_Emptyu45placementFormat: scalaxb.XMLFormat[musicxml.Emptyu45placement] = new DefaultMusicxml_Emptyu45placementFormat {}
  implicit lazy val Musicxml_Emptyu45placementu45smuflFormat: scalaxb.XMLFormat[musicxml.Emptyu45placementu45smufl] = new DefaultMusicxml_Emptyu45placementu45smuflFormat {}
  implicit lazy val Musicxml_Emptyu45printu45styleFormat: scalaxb.XMLFormat[musicxml.Emptyu45printu45style] = new DefaultMusicxml_Emptyu45printu45styleFormat {}
  implicit lazy val Musicxml_Emptyu45printu45styleu45alignFormat: scalaxb.XMLFormat[musicxml.Emptyu45printu45styleu45align] = new DefaultMusicxml_Emptyu45printu45styleu45alignFormat {}
  implicit lazy val Musicxml_Emptyu45printu45styleu45alignu45idFormat: scalaxb.XMLFormat[musicxml.Emptyu45printu45styleu45alignu45id] = new DefaultMusicxml_Emptyu45printu45styleu45alignu45idFormat {}
  implicit lazy val Musicxml_Emptyu45printu45objectu45styleu45alignFormat: scalaxb.XMLFormat[musicxml.Emptyu45printu45objectu45styleu45align] = new DefaultMusicxml_Emptyu45printu45objectu45styleu45alignFormat {}
  implicit lazy val Musicxml_Emptyu45trillu45soundableFormat: scalaxb.XMLFormat[musicxml.Emptyu45trillu45soundable] = new DefaultMusicxml_Emptyu45trillu45soundableFormat {}
  implicit lazy val Musicxml_Emptyu45trillu45soundFormat: scalaxb.XMLFormat[musicxml.Emptyu45trillu45sound] = new DefaultMusicxml_Emptyu45trillu45soundFormat {}
  implicit lazy val Musicxml_Horizontalu45turnFormat: scalaxb.XMLFormat[musicxml.Horizontalu45turn] = new DefaultMusicxml_Horizontalu45turnFormat {}
  implicit lazy val Musicxml_FermataFormat: scalaxb.XMLFormat[musicxml.Fermata] = new DefaultMusicxml_FermataFormat {}
  implicit lazy val Musicxml_FingeringFormat: scalaxb.XMLFormat[musicxml.Fingering] = new DefaultMusicxml_FingeringFormat {}
  implicit lazy val Musicxml_Formattedu45symbolFormat: scalaxb.XMLFormat[musicxml.Formattedu45symbol] = new DefaultMusicxml_Formattedu45symbolFormat {}
  implicit lazy val Musicxml_Formattedu45symbolu45idFormat: scalaxb.XMLFormat[musicxml.Formattedu45symbolu45id] = new DefaultMusicxml_Formattedu45symbolu45idFormat {}
  implicit lazy val Musicxml_Formattedu45textFormat: scalaxb.XMLFormat[musicxml.Formattedu45text] = new DefaultMusicxml_Formattedu45textFormat {}
  implicit lazy val Musicxml_Formattedu45textu45idFormat: scalaxb.XMLFormat[musicxml.Formattedu45textu45id] = new DefaultMusicxml_Formattedu45textu45idFormat {}
  implicit lazy val Musicxml_FretFormat: scalaxb.XMLFormat[musicxml.Fret] = new DefaultMusicxml_FretFormat {}
  implicit lazy val Musicxml_LevelFormat: scalaxb.XMLFormat[musicxml.Level] = new DefaultMusicxml_LevelFormat {}
  implicit lazy val Musicxml_Midiu45deviceFormat: scalaxb.XMLFormat[musicxml.Midiu45device] = new DefaultMusicxml_Midiu45deviceFormat {}
  implicit lazy val Musicxml_Midiu45instrumentFormat: scalaxb.XMLFormat[musicxml.Midiu45instrument] = new DefaultMusicxml_Midiu45instrumentFormat {}
  implicit lazy val Musicxml_Nameu45displayFormat: scalaxb.XMLFormat[musicxml.Nameu45display] = new DefaultMusicxml_Nameu45displayFormat {}
  implicit lazy val Musicxml_Otheru45playFormat: scalaxb.XMLFormat[musicxml.Otheru45play] = new DefaultMusicxml_Otheru45playFormat {}
  implicit lazy val Musicxml_PlayFormat: scalaxb.XMLFormat[musicxml.Play] = new DefaultMusicxml_PlayFormat {}
  implicit lazy val Musicxml_SegnoFormat: scalaxb.XMLFormat[musicxml.Segno] = new DefaultMusicxml_SegnoFormat {}
  implicit lazy val Musicxml_StringTypeFormat: scalaxb.XMLFormat[musicxml.StringType] = new DefaultMusicxml_StringTypeFormat {}
  implicit lazy val Musicxml_Typedu45textFormat: scalaxb.XMLFormat[musicxml.Typedu45text] = new DefaultMusicxml_Typedu45textFormat {}
  implicit lazy val Musicxml_Wavyu45lineFormat: scalaxb.XMLFormat[musicxml.Wavyu45line] = new DefaultMusicxml_Wavyu45lineFormat {}
  implicit lazy val Musicxml_DirectiveFormat: scalaxb.XMLFormat[musicxml.Directive] = new DefaultMusicxml_DirectiveFormat {}
  implicit lazy val Musicxml_AttributesTypeFormat: scalaxb.XMLFormat[musicxml.AttributesType] = new DefaultMusicxml_AttributesTypeFormat {}
  implicit lazy val Musicxml_Beatu45repeatFormat: scalaxb.XMLFormat[musicxml.Beatu45repeat] = new DefaultMusicxml_Beatu45repeatFormat {}
  implicit lazy val Musicxml_CancelFormat: scalaxb.XMLFormat[musicxml.Cancel] = new DefaultMusicxml_CancelFormat {}
  implicit lazy val Musicxml_ClefFormat: scalaxb.XMLFormat[musicxml.Clef] = new DefaultMusicxml_ClefFormat {}
  implicit lazy val Musicxml_InterchangeableFormat: scalaxb.XMLFormat[musicxml.Interchangeable] = new DefaultMusicxml_InterchangeableFormat {}
  implicit lazy val Musicxml_KeyFormat: scalaxb.XMLFormat[musicxml.Key] = new DefaultMusicxml_KeyFormat {}
  implicit lazy val Musicxml_Keyu45accidentalFormat: scalaxb.XMLFormat[musicxml.Keyu45accidental] = new DefaultMusicxml_Keyu45accidentalFormat {}
  implicit lazy val Musicxml_Keyu45octaveFormat: scalaxb.XMLFormat[musicxml.Keyu45octave] = new DefaultMusicxml_Keyu45octaveFormat {}
  implicit lazy val Musicxml_Measureu45repeatFormat: scalaxb.XMLFormat[musicxml.Measureu45repeat] = new DefaultMusicxml_Measureu45repeatFormat {}
  implicit lazy val Musicxml_Measureu45styleFormat: scalaxb.XMLFormat[musicxml.Measureu45style] = new DefaultMusicxml_Measureu45styleFormat {}
  implicit lazy val Musicxml_Multipleu45restFormat: scalaxb.XMLFormat[musicxml.Multipleu45rest] = new DefaultMusicxml_Multipleu45restFormat {}
  implicit lazy val Musicxml_Partu45symbolFormat: scalaxb.XMLFormat[musicxml.Partu45symbol] = new DefaultMusicxml_Partu45symbolFormat {}
  implicit lazy val Musicxml_SlashTypeFormat: scalaxb.XMLFormat[musicxml.SlashType] = new DefaultMusicxml_SlashTypeFormat {}
  implicit lazy val Musicxml_Staffu45detailsFormat: scalaxb.XMLFormat[musicxml.Staffu45details] = new DefaultMusicxml_Staffu45detailsFormat {}
  implicit lazy val Musicxml_Staffu45tuningFormat: scalaxb.XMLFormat[musicxml.Staffu45tuning] = new DefaultMusicxml_Staffu45tuningFormat {}
  implicit lazy val Musicxml_TimeFormat: scalaxb.XMLFormat[musicxml.Time] = new DefaultMusicxml_TimeFormat {}
  implicit lazy val Musicxml_TimeSequence1Format: scalaxb.XMLFormat[musicxml.TimeSequence1] = new DefaultMusicxml_TimeSequence1Format {}
  implicit lazy val Musicxml_TransposeFormat: scalaxb.XMLFormat[musicxml.Transpose] = new DefaultMusicxml_TransposeFormat {}
  implicit lazy val Musicxml_Baru45styleu45colorFormat: scalaxb.XMLFormat[musicxml.Baru45styleu45color] = new DefaultMusicxml_Baru45styleu45colorFormat {}
  implicit lazy val Musicxml_BarlineFormat: scalaxb.XMLFormat[musicxml.Barline] = new DefaultMusicxml_BarlineFormat {}
  implicit lazy val Musicxml_EndingFormat: scalaxb.XMLFormat[musicxml.Ending] = new DefaultMusicxml_EndingFormat {}
  implicit lazy val Musicxml_RepeatFormat: scalaxb.XMLFormat[musicxml.Repeat] = new DefaultMusicxml_RepeatFormat {}
  implicit lazy val Musicxml_AccordFormat: scalaxb.XMLFormat[musicxml.Accord] = new DefaultMusicxml_AccordFormat {}
  implicit lazy val Musicxml_Accordionu45registrationFormat: scalaxb.XMLFormat[musicxml.Accordionu45registration] = new DefaultMusicxml_Accordionu45registrationFormat {}
  implicit lazy val Musicxml_BarreFormat: scalaxb.XMLFormat[musicxml.Barre] = new DefaultMusicxml_BarreFormat {}
  implicit lazy val Musicxml_BassFormat: scalaxb.XMLFormat[musicxml.Bass] = new DefaultMusicxml_BassFormat {}
  implicit lazy val Musicxml_Bassu45alterFormat: scalaxb.XMLFormat[musicxml.Bassu45alter] = new DefaultMusicxml_Bassu45alterFormat {}
  implicit lazy val Musicxml_Bassu45stepFormat: scalaxb.XMLFormat[musicxml.Bassu45step] = new DefaultMusicxml_Bassu45stepFormat {}
  implicit lazy val Musicxml_BeaterFormat: scalaxb.XMLFormat[musicxml.Beater] = new DefaultMusicxml_BeaterFormat {}
  implicit lazy val Musicxml_Beatu45unitu45tiedFormat: scalaxb.XMLFormat[musicxml.Beatu45unitu45tied] = new DefaultMusicxml_Beatu45unitu45tiedFormat {}
  implicit lazy val Musicxml_BracketFormat: scalaxb.XMLFormat[musicxml.Bracket] = new DefaultMusicxml_BracketFormat {}
  implicit lazy val Musicxml_DashesFormat: scalaxb.XMLFormat[musicxml.Dashes] = new DefaultMusicxml_DashesFormat {}
  implicit lazy val Musicxml_DegreeFormat: scalaxb.XMLFormat[musicxml.Degree] = new DefaultMusicxml_DegreeFormat {}
  implicit lazy val Musicxml_Degreeu45alterFormat: scalaxb.XMLFormat[musicxml.Degreeu45alter] = new DefaultMusicxml_Degreeu45alterFormat {}
  implicit lazy val Musicxml_Degreeu45typeFormat: scalaxb.XMLFormat[musicxml.Degreeu45type] = new DefaultMusicxml_Degreeu45typeFormat {}
  implicit lazy val Musicxml_Degreeu45valueFormat: scalaxb.XMLFormat[musicxml.Degreeu45value] = new DefaultMusicxml_Degreeu45valueFormat {}
  implicit lazy val Musicxml_DirectionFormat: scalaxb.XMLFormat[musicxml.Direction] = new DefaultMusicxml_DirectionFormat {}
  implicit lazy val Musicxml_Directionu45typeFormat: scalaxb.XMLFormat[musicxml.Directionu45type] = new DefaultMusicxml_Directionu45typeFormat {}
  implicit lazy val Musicxml_FeatureFormat: scalaxb.XMLFormat[musicxml.Feature] = new DefaultMusicxml_FeatureFormat {}
  implicit lazy val Musicxml_Firstu45fretFormat: scalaxb.XMLFormat[musicxml.Firstu45fret] = new DefaultMusicxml_Firstu45fretFormat {}
  implicit lazy val Musicxml_FrameFormat: scalaxb.XMLFormat[musicxml.Frame] = new DefaultMusicxml_FrameFormat {}
  implicit lazy val Musicxml_Frameu45noteFormat: scalaxb.XMLFormat[musicxml.Frameu45note] = new DefaultMusicxml_Frameu45noteFormat {}
  implicit lazy val Musicxml_GlassFormat: scalaxb.XMLFormat[musicxml.Glass] = new DefaultMusicxml_GlassFormat {}
  implicit lazy val Musicxml_GroupingFormat: scalaxb.XMLFormat[musicxml.Grouping] = new DefaultMusicxml_GroupingFormat {}
  implicit lazy val Musicxml_HarmonyFormat: scalaxb.XMLFormat[musicxml.Harmony] = new DefaultMusicxml_HarmonyFormat {}
  implicit lazy val Musicxml_Harpu45pedalsFormat: scalaxb.XMLFormat[musicxml.Harpu45pedals] = new DefaultMusicxml_Harpu45pedalsFormat {}
  implicit lazy val Musicxml_ImageFormat: scalaxb.XMLFormat[musicxml.Image] = new DefaultMusicxml_ImageFormat {}
  implicit lazy val Musicxml_InversionFormat: scalaxb.XMLFormat[musicxml.Inversion] = new DefaultMusicxml_InversionFormat {}
  implicit lazy val Musicxml_KindFormat: scalaxb.XMLFormat[musicxml.Kind] = new DefaultMusicxml_KindFormat {}
  implicit lazy val Musicxml_Measureu45numberingFormat: scalaxb.XMLFormat[musicxml.Measureu45numbering] = new DefaultMusicxml_Measureu45numberingFormat {}
  implicit lazy val Musicxml_MetronomeFormat: scalaxb.XMLFormat[musicxml.Metronome] = new DefaultMusicxml_MetronomeFormat {}
  implicit lazy val Musicxml_MetronomeSequence4Format: scalaxb.XMLFormat[musicxml.MetronomeSequence4] = new DefaultMusicxml_MetronomeSequence4Format {}
  implicit lazy val Musicxml_MetronomeSequence1Format: scalaxb.XMLFormat[musicxml.MetronomeSequence1] = new DefaultMusicxml_MetronomeSequence1Format {}
  implicit lazy val Musicxml_MetronomeSequence3Format: scalaxb.XMLFormat[musicxml.MetronomeSequence3] = new DefaultMusicxml_MetronomeSequence3Format {}
  implicit lazy val Musicxml_MetronomeSequence2Format: scalaxb.XMLFormat[musicxml.MetronomeSequence2] = new DefaultMusicxml_MetronomeSequence2Format {}
  implicit lazy val Musicxml_Metronomeu45beamFormat: scalaxb.XMLFormat[musicxml.Metronomeu45beam] = new DefaultMusicxml_Metronomeu45beamFormat {}
  implicit lazy val Musicxml_Metronomeu45noteFormat: scalaxb.XMLFormat[musicxml.Metronomeu45note] = new DefaultMusicxml_Metronomeu45noteFormat {}
  implicit lazy val Musicxml_Metronomeu45tiedFormat: scalaxb.XMLFormat[musicxml.Metronomeu45tied] = new DefaultMusicxml_Metronomeu45tiedFormat {}
  implicit lazy val Musicxml_Metronomeu45tupletFormat: scalaxb.XMLFormat[musicxml.Metronomeu45tuplet] = new DefaultMusicxml_Metronomeu45tupletFormat {}
  implicit lazy val Musicxml_Octaveu45shiftFormat: scalaxb.XMLFormat[musicxml.Octaveu45shift] = new DefaultMusicxml_Octaveu45shiftFormat {}
  implicit lazy val Musicxml_OffsetFormat: scalaxb.XMLFormat[musicxml.Offset] = new DefaultMusicxml_OffsetFormat {}
  implicit lazy val Musicxml_Otheru45directionFormat: scalaxb.XMLFormat[musicxml.Otheru45direction] = new DefaultMusicxml_Otheru45directionFormat {}
  implicit lazy val Musicxml_PedalFormat: scalaxb.XMLFormat[musicxml.Pedal] = new DefaultMusicxml_PedalFormat {}
  implicit lazy val Musicxml_Pedalu45tuningFormat: scalaxb.XMLFormat[musicxml.Pedalu45tuning] = new DefaultMusicxml_Pedalu45tuningFormat {}
  implicit lazy val Musicxml_Peru45minuteFormat: scalaxb.XMLFormat[musicxml.Peru45minute] = new DefaultMusicxml_Peru45minuteFormat {}
  implicit lazy val Musicxml_PercussionTypeFormat: scalaxb.XMLFormat[musicxml.PercussionType] = new DefaultMusicxml_PercussionTypeFormat {}
  implicit lazy val Musicxml_PitchedFormat: scalaxb.XMLFormat[musicxml.Pitched] = new DefaultMusicxml_PitchedFormat {}
  implicit lazy val Musicxml_Principalu45voiceFormat: scalaxb.XMLFormat[musicxml.Principalu45voice] = new DefaultMusicxml_Principalu45voiceFormat {}
  implicit lazy val Musicxml_PrintFormat: scalaxb.XMLFormat[musicxml.Print] = new DefaultMusicxml_PrintFormat {}
  implicit lazy val Musicxml_RootFormat: scalaxb.XMLFormat[musicxml.Root] = new DefaultMusicxml_RootFormat {}
  implicit lazy val Musicxml_Rootu45alterFormat: scalaxb.XMLFormat[musicxml.Rootu45alter] = new DefaultMusicxml_Rootu45alterFormat {}
  implicit lazy val Musicxml_Rootu45stepFormat: scalaxb.XMLFormat[musicxml.Rootu45step] = new DefaultMusicxml_Rootu45stepFormat {}
  implicit lazy val Musicxml_ScordaturaFormat: scalaxb.XMLFormat[musicxml.Scordatura] = new DefaultMusicxml_ScordaturaFormat {}
  implicit lazy val Musicxml_SoundFormat: scalaxb.XMLFormat[musicxml.Sound] = new DefaultMusicxml_SoundFormat {}
  implicit lazy val Musicxml_SoundSequence1Format: scalaxb.XMLFormat[musicxml.SoundSequence1] = new DefaultMusicxml_SoundSequence1Format {}
  implicit lazy val Musicxml_Staffu45divideFormat: scalaxb.XMLFormat[musicxml.Staffu45divide] = new DefaultMusicxml_Staffu45divideFormat {}
  implicit lazy val Musicxml_StickFormat: scalaxb.XMLFormat[musicxml.Stick] = new DefaultMusicxml_StickFormat {}
  implicit lazy val Musicxml_Stringu45muteFormat: scalaxb.XMLFormat[musicxml.Stringu45mute] = new DefaultMusicxml_Stringu45muteFormat {}
  implicit lazy val Musicxml_WedgeFormat: scalaxb.XMLFormat[musicxml.Wedge] = new DefaultMusicxml_WedgeFormat {}
  implicit lazy val Musicxml_EncodingFormat: scalaxb.XMLFormat[musicxml.Encoding] = new DefaultMusicxml_EncodingFormat {}
  implicit lazy val Musicxml_IdentificationFormat: scalaxb.XMLFormat[musicxml.Identification] = new DefaultMusicxml_IdentificationFormat {}
  implicit lazy val Musicxml_MiscellaneousFormat: scalaxb.XMLFormat[musicxml.Miscellaneous] = new DefaultMusicxml_MiscellaneousFormat {}
  implicit lazy val Musicxml_Miscellaneousu45fieldFormat: scalaxb.XMLFormat[musicxml.Miscellaneousu45field] = new DefaultMusicxml_Miscellaneousu45fieldFormat {}
  implicit lazy val Musicxml_SupportsFormat: scalaxb.XMLFormat[musicxml.Supports] = new DefaultMusicxml_SupportsFormat {}
  implicit lazy val Musicxml_AppearanceFormat: scalaxb.XMLFormat[musicxml.Appearance] = new DefaultMusicxml_AppearanceFormat {}
  implicit lazy val Musicxml_DistanceFormat: scalaxb.XMLFormat[musicxml.Distance] = new DefaultMusicxml_DistanceFormat {}
  implicit lazy val Musicxml_GlyphFormat: scalaxb.XMLFormat[musicxml.Glyph] = new DefaultMusicxml_GlyphFormat {}
  implicit lazy val Musicxml_Lineu45widthFormat: scalaxb.XMLFormat[musicxml.Lineu45width] = new DefaultMusicxml_Lineu45widthFormat {}
  implicit lazy val Musicxml_Measureu45layoutFormat: scalaxb.XMLFormat[musicxml.Measureu45layout] = new DefaultMusicxml_Measureu45layoutFormat {}
  implicit lazy val Musicxml_Noteu45sizeFormat: scalaxb.XMLFormat[musicxml.Noteu45size] = new DefaultMusicxml_Noteu45sizeFormat {}
  implicit lazy val Musicxml_Otheru45appearanceFormat: scalaxb.XMLFormat[musicxml.Otheru45appearance] = new DefaultMusicxml_Otheru45appearanceFormat {}
  implicit lazy val Musicxml_Pageu45layoutFormat: scalaxb.XMLFormat[musicxml.Pageu45layout] = new DefaultMusicxml_Pageu45layoutFormat {}
  implicit lazy val Musicxml_Pageu45layoutSequence1Format: scalaxb.XMLFormat[musicxml.Pageu45layoutSequence1] = new DefaultMusicxml_Pageu45layoutSequence1Format {}
  implicit lazy val Musicxml_Pageu45marginsFormat: scalaxb.XMLFormat[musicxml.Pageu45margins] = new DefaultMusicxml_Pageu45marginsFormat {}
  implicit lazy val Musicxml_ScalingFormat: scalaxb.XMLFormat[musicxml.Scaling] = new DefaultMusicxml_ScalingFormat {}
  implicit lazy val Musicxml_Staffu45layoutFormat: scalaxb.XMLFormat[musicxml.Staffu45layout] = new DefaultMusicxml_Staffu45layoutFormat {}
  implicit lazy val Musicxml_Systemu45dividersFormat: scalaxb.XMLFormat[musicxml.Systemu45dividers] = new DefaultMusicxml_Systemu45dividersFormat {}
  implicit lazy val Musicxml_Systemu45layoutFormat: scalaxb.XMLFormat[musicxml.Systemu45layout] = new DefaultMusicxml_Systemu45layoutFormat {}
  implicit lazy val Musicxml_Systemu45marginsFormat: scalaxb.XMLFormat[musicxml.Systemu45margins] = new DefaultMusicxml_Systemu45marginsFormat {}
  implicit lazy val Musicxml_BookmarkFormat: scalaxb.XMLFormat[musicxml.Bookmark] = new DefaultMusicxml_BookmarkFormat {}
  implicit lazy val Musicxml_LinkFormat: scalaxb.XMLFormat[musicxml.Link] = new DefaultMusicxml_LinkFormat {}
  implicit lazy val Musicxml_AccidentalFormat: scalaxb.XMLFormat[musicxml.Accidental] = new DefaultMusicxml_AccidentalFormat {}
  implicit lazy val Musicxml_Accidentalu45markFormat: scalaxb.XMLFormat[musicxml.Accidentalu45mark] = new DefaultMusicxml_Accidentalu45markFormat {}
  implicit lazy val Musicxml_ArpeggiateFormat: scalaxb.XMLFormat[musicxml.Arpeggiate] = new DefaultMusicxml_ArpeggiateFormat {}
  implicit lazy val Musicxml_ArticulationsFormat: scalaxb.XMLFormat[musicxml.Articulations] = new DefaultMusicxml_ArticulationsFormat {}
  implicit lazy val Musicxml_ArrowTypeFormat: scalaxb.XMLFormat[musicxml.ArrowType] = new DefaultMusicxml_ArrowTypeFormat {}
  implicit lazy val Musicxml_ArrowTypeSequence1Format: scalaxb.XMLFormat[musicxml.ArrowTypeSequence1] = new DefaultMusicxml_ArrowTypeSequence1Format {}
  implicit lazy val Musicxml_BackupFormat: scalaxb.XMLFormat[musicxml.Backup] = new DefaultMusicxml_BackupFormat {}
  implicit lazy val Musicxml_BeamFormat: scalaxb.XMLFormat[musicxml.Beam] = new DefaultMusicxml_BeamFormat {}
  implicit lazy val Musicxml_BendFormat: scalaxb.XMLFormat[musicxml.Bend] = new DefaultMusicxml_BendFormat {}
  implicit lazy val Musicxml_Breathu45markFormat: scalaxb.XMLFormat[musicxml.Breathu45mark] = new DefaultMusicxml_Breathu45markFormat {}
  implicit lazy val Musicxml_CaesuraFormat: scalaxb.XMLFormat[musicxml.Caesura] = new DefaultMusicxml_CaesuraFormat {}
  implicit lazy val Musicxml_ElisionFormat: scalaxb.XMLFormat[musicxml.Elision] = new DefaultMusicxml_ElisionFormat {}
  implicit lazy val Musicxml_Emptyu45lineFormat: scalaxb.XMLFormat[musicxml.Emptyu45line] = new DefaultMusicxml_Emptyu45lineFormat {}
  implicit lazy val Musicxml_ExtendFormat: scalaxb.XMLFormat[musicxml.Extend] = new DefaultMusicxml_ExtendFormat {}
  implicit lazy val Musicxml_FigureFormat: scalaxb.XMLFormat[musicxml.Figure] = new DefaultMusicxml_FigureFormat {}
  implicit lazy val Musicxml_Figuredu45bassFormat: scalaxb.XMLFormat[musicxml.Figuredu45bass] = new DefaultMusicxml_Figuredu45bassFormat {}
  implicit lazy val Musicxml_ForwardFormat: scalaxb.XMLFormat[musicxml.Forward] = new DefaultMusicxml_ForwardFormat {}
  implicit lazy val Musicxml_GlissandoFormat: scalaxb.XMLFormat[musicxml.Glissando] = new DefaultMusicxml_GlissandoFormat {}
  implicit lazy val Musicxml_GraceFormat: scalaxb.XMLFormat[musicxml.Grace] = new DefaultMusicxml_GraceFormat {}
  implicit lazy val Musicxml_Hammeru45onu45pullu45offFormat: scalaxb.XMLFormat[musicxml.Hammeru45onu45pullu45off] = new DefaultMusicxml_Hammeru45onu45pullu45offFormat {}
  implicit lazy val Musicxml_HandbellFormat: scalaxb.XMLFormat[musicxml.Handbell] = new DefaultMusicxml_HandbellFormat {}
  implicit lazy val Musicxml_Harmonu45closedFormat: scalaxb.XMLFormat[musicxml.Harmonu45closed] = new DefaultMusicxml_Harmonu45closedFormat {}
  implicit lazy val Musicxml_Harmonu45muteFormat: scalaxb.XMLFormat[musicxml.Harmonu45mute] = new DefaultMusicxml_Harmonu45muteFormat {}
  implicit lazy val Musicxml_HarmonicFormat: scalaxb.XMLFormat[musicxml.Harmonic] = new DefaultMusicxml_HarmonicFormat {}
  implicit lazy val Musicxml_Heelu45toeFormat: scalaxb.XMLFormat[musicxml.Heelu45toe] = new DefaultMusicxml_Heelu45toeFormat {}
  implicit lazy val Musicxml_HoleFormat: scalaxb.XMLFormat[musicxml.Hole] = new DefaultMusicxml_HoleFormat {}
  implicit lazy val Musicxml_Holeu45closedFormat: scalaxb.XMLFormat[musicxml.Holeu45closed] = new DefaultMusicxml_Holeu45closedFormat {}
  implicit lazy val Musicxml_InstrumentFormat: scalaxb.XMLFormat[musicxml.Instrument] = new DefaultMusicxml_InstrumentFormat {}
  implicit lazy val Musicxml_LyricFormat: scalaxb.XMLFormat[musicxml.Lyric] = new DefaultMusicxml_LyricFormat {}
  implicit lazy val Musicxml_LyricSequence3Format: scalaxb.XMLFormat[musicxml.LyricSequence3] = new DefaultMusicxml_LyricSequence3Format {}
  implicit lazy val Musicxml_LyricSequence2Format: scalaxb.XMLFormat[musicxml.LyricSequence2] = new DefaultMusicxml_LyricSequence2Format {}
  implicit lazy val Musicxml_LyricSequence1Format: scalaxb.XMLFormat[musicxml.LyricSequence1] = new DefaultMusicxml_LyricSequence1Format {}
  implicit lazy val Musicxml_MordentFormat: scalaxb.XMLFormat[musicxml.Mordent] = new DefaultMusicxml_MordentFormat {}
  implicit lazy val Musicxml_Nonu45arpeggiateFormat: scalaxb.XMLFormat[musicxml.Nonu45arpeggiate] = new DefaultMusicxml_Nonu45arpeggiateFormat {}
  implicit lazy val Musicxml_NotationsFormat: scalaxb.XMLFormat[musicxml.Notations] = new DefaultMusicxml_NotationsFormat {}
  implicit lazy val Musicxml_NoteFormat: scalaxb.XMLFormat[musicxml.Note] = new DefaultMusicxml_NoteFormat {}
  implicit lazy val Musicxml_NoteSequence5Format: scalaxb.XMLFormat[musicxml.NoteSequence5] = new DefaultMusicxml_NoteSequence5Format {}
  implicit lazy val Musicxml_NoteSequence1Format: scalaxb.XMLFormat[musicxml.NoteSequence1] = new DefaultMusicxml_NoteSequence1Format {}
  implicit lazy val Musicxml_NoteSequence4Format: scalaxb.XMLFormat[musicxml.NoteSequence4] = new DefaultMusicxml_NoteSequence4Format {}
  implicit lazy val Musicxml_NoteSequence2Format: scalaxb.XMLFormat[musicxml.NoteSequence2] = new DefaultMusicxml_NoteSequence2Format {}
  implicit lazy val Musicxml_NoteSequence3Format: scalaxb.XMLFormat[musicxml.NoteSequence3] = new DefaultMusicxml_NoteSequence3Format {}
  implicit lazy val Musicxml_Noteu45typeFormat: scalaxb.XMLFormat[musicxml.Noteu45type] = new DefaultMusicxml_Noteu45typeFormat {}
  implicit lazy val Musicxml_NoteheadFormat: scalaxb.XMLFormat[musicxml.Notehead] = new DefaultMusicxml_NoteheadFormat {}
  implicit lazy val Musicxml_Noteheadu45textFormat: scalaxb.XMLFormat[musicxml.Noteheadu45text] = new DefaultMusicxml_Noteheadu45textFormat {}
  implicit lazy val Musicxml_OrnamentsFormat: scalaxb.XMLFormat[musicxml.Ornaments] = new DefaultMusicxml_OrnamentsFormat {}
  implicit lazy val Musicxml_OrnamentsSequence1Format: scalaxb.XMLFormat[musicxml.OrnamentsSequence1] = new DefaultMusicxml_OrnamentsSequence1Format {}
  implicit lazy val Musicxml_Otheru45notationFormat: scalaxb.XMLFormat[musicxml.Otheru45notation] = new DefaultMusicxml_Otheru45notationFormat {}
  implicit lazy val Musicxml_Otheru45placementu45textFormat: scalaxb.XMLFormat[musicxml.Otheru45placementu45text] = new DefaultMusicxml_Otheru45placementu45textFormat {}
  implicit lazy val Musicxml_Otheru45textFormat: scalaxb.XMLFormat[musicxml.Otheru45text] = new DefaultMusicxml_Otheru45textFormat {}
  implicit lazy val Musicxml_PitchFormat: scalaxb.XMLFormat[musicxml.Pitch] = new DefaultMusicxml_PitchFormat {}
  implicit lazy val Musicxml_Placementu45textFormat: scalaxb.XMLFormat[musicxml.Placementu45text] = new DefaultMusicxml_Placementu45textFormat {}
  implicit lazy val Musicxml_RestFormat: scalaxb.XMLFormat[musicxml.Rest] = new DefaultMusicxml_RestFormat {}
  implicit lazy val Musicxml_SlideFormat: scalaxb.XMLFormat[musicxml.Slide] = new DefaultMusicxml_SlideFormat {}
  implicit lazy val Musicxml_SlurFormat: scalaxb.XMLFormat[musicxml.Slur] = new DefaultMusicxml_SlurFormat {}
  implicit lazy val Musicxml_StemFormat: scalaxb.XMLFormat[musicxml.Stem] = new DefaultMusicxml_StemFormat {}
  implicit lazy val Musicxml_Strongu45accentFormat: scalaxb.XMLFormat[musicxml.Strongu45accent] = new DefaultMusicxml_Strongu45accentFormat {}
  implicit lazy val Musicxml_Styleu45textFormat: scalaxb.XMLFormat[musicxml.Styleu45text] = new DefaultMusicxml_Styleu45textFormat {}
  implicit lazy val Musicxml_TapFormat: scalaxb.XMLFormat[musicxml.Tap] = new DefaultMusicxml_TapFormat {}
  implicit lazy val Musicxml_TechnicalFormat: scalaxb.XMLFormat[musicxml.Technical] = new DefaultMusicxml_TechnicalFormat {}
  implicit lazy val Musicxml_Textu45elementu45dataFormat: scalaxb.XMLFormat[musicxml.Textu45elementu45data] = new DefaultMusicxml_Textu45elementu45dataFormat {}
  implicit lazy val Musicxml_TieFormat: scalaxb.XMLFormat[musicxml.Tie] = new DefaultMusicxml_TieFormat {}
  implicit lazy val Musicxml_TiedFormat: scalaxb.XMLFormat[musicxml.Tied] = new DefaultMusicxml_TiedFormat {}
  implicit lazy val Musicxml_Timeu45modificationableFormat: scalaxb.XMLFormat[musicxml.Timeu45modificationable] = new DefaultMusicxml_Timeu45modificationableFormat {}
  implicit lazy val Musicxml_Timeu45modificationFormat: scalaxb.XMLFormat[musicxml.Timeu45modification] = new DefaultMusicxml_Timeu45modificationFormat {}
  implicit lazy val Musicxml_Timeu45modificationableSequence1Format: scalaxb.XMLFormat[musicxml.Timeu45modificationableSequence1] = new DefaultMusicxml_Timeu45modificationableSequence1Format {}
  implicit lazy val Musicxml_TremoloFormat: scalaxb.XMLFormat[musicxml.Tremolo] = new DefaultMusicxml_TremoloFormat {}
  implicit lazy val Musicxml_TupletFormat: scalaxb.XMLFormat[musicxml.Tuplet] = new DefaultMusicxml_TupletFormat {}
  implicit lazy val Musicxml_Tupletu45dotFormat: scalaxb.XMLFormat[musicxml.Tupletu45dot] = new DefaultMusicxml_Tupletu45dotFormat {}
  implicit lazy val Musicxml_Tupletu45numberFormat: scalaxb.XMLFormat[musicxml.Tupletu45number] = new DefaultMusicxml_Tupletu45numberFormat {}
  implicit lazy val Musicxml_Tupletu45portionFormat: scalaxb.XMLFormat[musicxml.Tupletu45portion] = new DefaultMusicxml_Tupletu45portionFormat {}
  implicit lazy val Musicxml_Tupletu45typeFormat: scalaxb.XMLFormat[musicxml.Tupletu45type] = new DefaultMusicxml_Tupletu45typeFormat {}
  implicit lazy val Musicxml_UnpitchedFormat: scalaxb.XMLFormat[musicxml.Unpitched] = new DefaultMusicxml_UnpitchedFormat {}
  implicit lazy val Musicxml_CreditFormat: scalaxb.XMLFormat[musicxml.Credit] = new DefaultMusicxml_CreditFormat {}
  implicit lazy val Musicxml_CreditSequence2Format: scalaxb.XMLFormat[musicxml.CreditSequence2] = new DefaultMusicxml_CreditSequence2Format {}
  implicit lazy val Musicxml_CreditSequence1Format: scalaxb.XMLFormat[musicxml.CreditSequence1] = new DefaultMusicxml_CreditSequence1Format {}
  implicit lazy val Musicxml_DefaultsFormat: scalaxb.XMLFormat[musicxml.Defaults] = new DefaultMusicxml_DefaultsFormat {}
  implicit lazy val Musicxml_Emptyu45fontFormat: scalaxb.XMLFormat[musicxml.Emptyu45font] = new DefaultMusicxml_Emptyu45fontFormat {}
  implicit lazy val Musicxml_Groupu45barlineFormat: scalaxb.XMLFormat[musicxml.Groupu45barline] = new DefaultMusicxml_Groupu45barlineFormat {}
  implicit lazy val Musicxml_Groupu45nameFormat: scalaxb.XMLFormat[musicxml.Groupu45name] = new DefaultMusicxml_Groupu45nameFormat {}
  implicit lazy val Musicxml_Groupu45symbolFormat: scalaxb.XMLFormat[musicxml.Groupu45symbol] = new DefaultMusicxml_Groupu45symbolFormat {}
  implicit lazy val Musicxml_Lyricu45fontFormat: scalaxb.XMLFormat[musicxml.Lyricu45font] = new DefaultMusicxml_Lyricu45fontFormat {}
  implicit lazy val Musicxml_Lyricu45languageFormat: scalaxb.XMLFormat[musicxml.Lyricu45language] = new DefaultMusicxml_Lyricu45languageFormat {}
  implicit lazy val Musicxml_Partu45groupFormat: scalaxb.XMLFormat[musicxml.Partu45group] = new DefaultMusicxml_Partu45groupFormat {}
  implicit lazy val Musicxml_Partu45listFormat: scalaxb.XMLFormat[musicxml.Partu45list] = new DefaultMusicxml_Partu45listFormat {}
  implicit lazy val Musicxml_Partu45nameFormat: scalaxb.XMLFormat[musicxml.Partu45name] = new DefaultMusicxml_Partu45nameFormat {}
  implicit lazy val Musicxml_Scoreu45instrumentFormat: scalaxb.XMLFormat[musicxml.Scoreu45instrument] = new DefaultMusicxml_Scoreu45instrumentFormat {}
  implicit lazy val Musicxml_Scoreu45partFormat: scalaxb.XMLFormat[musicxml.Scoreu45part] = new DefaultMusicxml_Scoreu45partFormat {}
  implicit lazy val Musicxml_Scoreu45partSequence1Format: scalaxb.XMLFormat[musicxml.Scoreu45partSequence1] = new DefaultMusicxml_Scoreu45partSequence1Format {}
  implicit lazy val Musicxml_Virtualu45instrumentFormat: scalaxb.XMLFormat[musicxml.Virtualu45instrument] = new DefaultMusicxml_Virtualu45instrumentFormat {}
  implicit lazy val Musicxml_WorkFormat: scalaxb.XMLFormat[musicxml.Work] = new DefaultMusicxml_WorkFormat {}
  implicit lazy val Musicxml_MeasureFormat: scalaxb.XMLFormat[musicxml.Measure] = new DefaultMusicxml_MeasureFormat {}
  implicit lazy val Musicxml_PartFormat: scalaxb.XMLFormat[musicxml.Part] = new DefaultMusicxml_PartFormat {}
  implicit lazy val Musicxml_Scoreu45partwiseFormat: scalaxb.XMLFormat[musicxml.Scoreu45partwise] = new DefaultMusicxml_Scoreu45partwiseFormat {}
  implicit lazy val Musicxml_Part2Format: scalaxb.XMLFormat[musicxml.Part2] = new DefaultMusicxml_Part2Format {}
  implicit lazy val Musicxml_Measure2Format: scalaxb.XMLFormat[musicxml.Measure2] = new DefaultMusicxml_Measure2Format {}
  implicit lazy val Musicxml_Scoreu45timewiseFormat: scalaxb.XMLFormat[musicxml.Scoreu45timewise] = new DefaultMusicxml_Scoreu45timewiseFormat {}
  implicit lazy val Musicxml_Scoreu45partSequenceFormat: scalaxb.XMLFormat[musicxml.Scoreu45partSequence] = new DefaultMusicxml_Scoreu45partSequenceFormat {}
  implicit lazy val Musicxml_Partu45groupSequenceFormat: scalaxb.XMLFormat[musicxml.Partu45groupSequence] = new DefaultMusicxml_Partu45groupSequenceFormat {}
  implicit lazy val Musicxml_Fullu45noteSequenceFormat: scalaxb.XMLFormat[musicxml.Fullu45noteSequence] = new DefaultMusicxml_Fullu45noteSequenceFormat {}
  implicit lazy val Musicxml_DurationSequenceFormat: scalaxb.XMLFormat[musicxml.DurationSequence] = new DefaultMusicxml_DurationSequenceFormat {}
  implicit lazy val Musicxml_LayoutSequenceFormat: scalaxb.XMLFormat[musicxml.LayoutSequence] = new DefaultMusicxml_LayoutSequenceFormat {}
  implicit lazy val Musicxml_Harmonyu45chordSequenceFormat: scalaxb.XMLFormat[musicxml.Harmonyu45chordSequence] = new DefaultMusicxml_Harmonyu45chordSequenceFormat {}
  implicit lazy val Musicxml_Traditionalu45keySequenceFormat: scalaxb.XMLFormat[musicxml.Traditionalu45keySequence] = new DefaultMusicxml_Traditionalu45keySequenceFormat {}
  implicit lazy val Musicxml_SlashSequenceFormat: scalaxb.XMLFormat[musicxml.SlashSequence] = new DefaultMusicxml_SlashSequenceFormat {}
  implicit lazy val Musicxml_SlashSequence2Format: scalaxb.XMLFormat[musicxml.SlashSequence2] = new DefaultMusicxml_SlashSequence2Format {}
  implicit lazy val Musicxml_VoiceSequenceFormat: scalaxb.XMLFormat[musicxml.VoiceSequence] = new DefaultMusicxml_VoiceSequenceFormat {}
  implicit lazy val Musicxml_StaffSequenceFormat: scalaxb.XMLFormat[musicxml.StaffSequence] = new DefaultMusicxml_StaffSequenceFormat {}
  implicit lazy val Musicxml_FootnoteSequenceFormat: scalaxb.XMLFormat[musicxml.FootnoteSequence] = new DefaultMusicxml_FootnoteSequenceFormat {}
  implicit lazy val Musicxml_Editorialu45voiceSequenceFormat: scalaxb.XMLFormat[musicxml.Editorialu45voiceSequence] = new DefaultMusicxml_Editorialu45voiceSequenceFormat {}
  implicit lazy val Musicxml_EditorialSequenceFormat: scalaxb.XMLFormat[musicxml.EditorialSequence] = new DefaultMusicxml_EditorialSequenceFormat {}
  implicit lazy val Musicxml_Editorialu45voiceu45directionSequenceFormat: scalaxb.XMLFormat[musicxml.Editorialu45voiceu45directionSequence] = new DefaultMusicxml_Editorialu45voiceu45directionSequenceFormat {}
  implicit lazy val Musicxml_LevelSequenceFormat: scalaxb.XMLFormat[musicxml.LevelSequence] = new DefaultMusicxml_LevelSequenceFormat {}
  implicit lazy val Musicxml_TuningSequenceFormat: scalaxb.XMLFormat[musicxml.TuningSequence] = new DefaultMusicxml_TuningSequenceFormat {}
  implicit lazy val Musicxml_Nonu45traditionalu45keySequenceFormat: scalaxb.XMLFormat[musicxml.Nonu45traditionalu45keySequence] = new DefaultMusicxml_Nonu45traditionalu45keySequenceFormat {}
  implicit lazy val Musicxml_Timeu45signatureSequenceFormat: scalaxb.XMLFormat[musicxml.Timeu45signatureSequence] = new DefaultMusicxml_Timeu45signatureSequenceFormat {}
  implicit lazy val Musicxml_Beatu45unitSequenceFormat: scalaxb.XMLFormat[musicxml.Beatu45unitSequence] = new DefaultMusicxml_Beatu45unitSequenceFormat {}
  implicit lazy val Musicxml_Allu45marginsSequenceFormat: scalaxb.XMLFormat[musicxml.Allu45marginsSequence] = new DefaultMusicxml_Allu45marginsSequenceFormat {}
  implicit lazy val Musicxml_Leftu45rightu45marginsSequenceFormat: scalaxb.XMLFormat[musicxml.Leftu45rightu45marginsSequence] = new DefaultMusicxml_Leftu45rightu45marginsSequenceFormat {}
  implicit lazy val Musicxml_Displayu45stepu45octaveSequenceFormat: scalaxb.XMLFormat[musicxml.Displayu45stepu45octaveSequence] = new DefaultMusicxml_Displayu45stepu45octaveSequenceFormat {}
  implicit lazy val Musicxml_Scoreu45headerSequenceFormat: scalaxb.XMLFormat[musicxml.Scoreu45headerSequence] = new DefaultMusicxml_Scoreu45headerSequenceFormat {}
  implicit lazy val Musicxml_Partu45nameu45textFormat: scalaxb.AttributeGroupFormat[musicxml.Partu45nameu45text] = new DefaultMusicxml_Partu45nameu45textFormat {}
  implicit lazy val Musicxml_Measureu45attributesFormat: scalaxb.AttributeGroupFormat[musicxml.Measureu45attributes] = new DefaultMusicxml_Measureu45attributesFormat {}
  implicit lazy val Musicxml_Linku45attributesFormat: scalaxb.AttributeGroupFormat[musicxml.Linku45attributes] = new DefaultMusicxml_Linku45attributesFormat {}
  implicit lazy val Musicxml_Printu45attributesFormat: scalaxb.AttributeGroupFormat[musicxml.Printu45attributes] = new DefaultMusicxml_Printu45attributesFormat {}
  implicit lazy val Musicxml_Yu45positionFormat: scalaxb.AttributeGroupFormat[musicxml.Yu45position] = new DefaultMusicxml_Yu45positionFormat {}
  implicit lazy val Musicxml_Valignu45imageTypeFormat: scalaxb.AttributeGroupFormat[musicxml.Valignu45imageType] = new DefaultMusicxml_Valignu45imageTypeFormat {}
  implicit lazy val Musicxml_Trillu45soundFormat: scalaxb.AttributeGroupFormat[musicxml.Trillu45sound] = new DefaultMusicxml_Trillu45soundFormat {}
  implicit lazy val Musicxml_Textu45formattingFormat: scalaxb.AttributeGroupFormat[musicxml.Textu45formatting] = new DefaultMusicxml_Textu45formattingFormat {}
  implicit lazy val Musicxml_Textu45decorationFormat: scalaxb.AttributeGroupFormat[musicxml.Textu45decoration] = new DefaultMusicxml_Textu45decorationFormat {}
  implicit lazy val Musicxml_SmuflFormat: scalaxb.AttributeGroupFormat[musicxml.Smufl] = new DefaultMusicxml_SmuflFormat {}
  implicit lazy val Musicxml_Printu45styleu45alignFormat: scalaxb.AttributeGroupFormat[musicxml.Printu45styleu45align] = new DefaultMusicxml_Printu45styleu45alignFormat {}
  implicit lazy val Musicxml_Printu45spacingFormat: scalaxb.AttributeGroupFormat[musicxml.Printu45spacing] = new DefaultMusicxml_Printu45spacingFormat {}
  implicit lazy val Musicxml_PositionFormat: scalaxb.AttributeGroupFormat[musicxml.Position] = new DefaultMusicxml_PositionFormat {}
  implicit lazy val Musicxml_OrientationFormat: scalaxb.AttributeGroupFormat[musicxml.Orientation] = new DefaultMusicxml_OrientationFormat {}
  implicit lazy val Musicxml_Lineu45typeTypeFormat: scalaxb.AttributeGroupFormat[musicxml.Lineu45typeType] = new DefaultMusicxml_Lineu45typeTypeFormat {}
  implicit lazy val Musicxml_Lineu45lengthTypeFormat: scalaxb.AttributeGroupFormat[musicxml.Lineu45lengthType] = new DefaultMusicxml_Lineu45lengthTypeFormat {}
  implicit lazy val Musicxml_Levelu45displayFormat: scalaxb.AttributeGroupFormat[musicxml.Levelu45display] = new DefaultMusicxml_Levelu45displayFormat {}
  implicit lazy val Musicxml_JustifyFormat: scalaxb.AttributeGroupFormat[musicxml.Justify] = new DefaultMusicxml_JustifyFormat {}
  implicit lazy val Musicxml_FontFormat: scalaxb.AttributeGroupFormat[musicxml.Font] = new DefaultMusicxml_FontFormat {}
  implicit lazy val Musicxml_Documentu45attributesFormat: scalaxb.AttributeGroupFormat[musicxml.Documentu45attributes] = new DefaultMusicxml_Documentu45attributesFormat {}
  implicit lazy val Musicxml_Dashedu45formattingFormat: scalaxb.AttributeGroupFormat[musicxml.Dashedu45formatting] = new DefaultMusicxml_Dashedu45formattingFormat {}
  implicit lazy val Musicxml_BezierFormat: scalaxb.AttributeGroupFormat[musicxml.Bezier] = new DefaultMusicxml_BezierFormat {}
  implicit lazy val Musicxml_Bendu45soundFormat: scalaxb.AttributeGroupFormat[musicxml.Bendu45sound] = new DefaultMusicxml_Bendu45soundFormat {}
  implicit lazy val Musicxml_ColorFormat: scalaxb.AttributeGroupFormat[musicxml.Color] = new DefaultMusicxml_ColorFormat {}
  implicit lazy val Musicxml_DirectiveTypeFormat: scalaxb.AttributeGroupFormat[musicxml.DirectiveType] = new DefaultMusicxml_DirectiveTypeFormat {}
  implicit lazy val Musicxml_EnclosureFormat: scalaxb.AttributeGroupFormat[musicxml.Enclosure] = new DefaultMusicxml_EnclosureFormat {}
  implicit lazy val Musicxml_HalignFormat: scalaxb.AttributeGroupFormat[musicxml.Halign] = new DefaultMusicxml_HalignFormat {}
  implicit lazy val Musicxml_Letteru45spacingFormat: scalaxb.AttributeGroupFormat[musicxml.Letteru45spacing] = new DefaultMusicxml_Letteru45spacingFormat {}
  implicit lazy val Musicxml_Lineu45heightFormat: scalaxb.AttributeGroupFormat[musicxml.Lineu45height] = new DefaultMusicxml_Lineu45heightFormat {}
  implicit lazy val Musicxml_Lineu45shapeTypeFormat: scalaxb.AttributeGroupFormat[musicxml.Lineu45shapeType] = new DefaultMusicxml_Lineu45shapeTypeFormat {}
  implicit lazy val Musicxml_Optionalu45uniqueu45idFormat: scalaxb.AttributeGroupFormat[musicxml.Optionalu45uniqueu45id] = new DefaultMusicxml_Optionalu45uniqueu45idFormat {}
  implicit lazy val Musicxml_PlacementFormat: scalaxb.AttributeGroupFormat[musicxml.Placement] = new DefaultMusicxml_PlacementFormat {}
  implicit lazy val Musicxml_Printu45objectFormat: scalaxb.AttributeGroupFormat[musicxml.Printu45object] = new DefaultMusicxml_Printu45objectFormat {}
  implicit lazy val Musicxml_Printu45styleFormat: scalaxb.AttributeGroupFormat[musicxml.Printu45style] = new DefaultMusicxml_Printu45styleFormat {}
  implicit lazy val Musicxml_PrintoutFormat: scalaxb.AttributeGroupFormat[musicxml.Printout] = new DefaultMusicxml_PrintoutFormat {}
  implicit lazy val Musicxml_Symbolu45formattingFormat: scalaxb.AttributeGroupFormat[musicxml.Symbolu45formatting] = new DefaultMusicxml_Symbolu45formattingFormat {}
  implicit lazy val Musicxml_Textu45directionTypeFormat: scalaxb.AttributeGroupFormat[musicxml.Textu45directionType] = new DefaultMusicxml_Textu45directionTypeFormat {}
  implicit lazy val Musicxml_Textu45rotationFormat: scalaxb.AttributeGroupFormat[musicxml.Textu45rotation] = new DefaultMusicxml_Textu45rotationFormat {}
  implicit lazy val Musicxml_ValignTypeFormat: scalaxb.AttributeGroupFormat[musicxml.ValignType] = new DefaultMusicxml_ValignTypeFormat {}
  implicit lazy val Musicxml_Xu45positionFormat: scalaxb.AttributeGroupFormat[musicxml.Xu45position] = new DefaultMusicxml_Xu45positionFormat {}
  implicit lazy val Musicxml_Imageu45attributesFormat: scalaxb.AttributeGroupFormat[musicxml.Imageu45attributes] = new DefaultMusicxml_Imageu45attributesFormat {}
  implicit lazy val Musicxml_Elementu45positionFormat: scalaxb.AttributeGroupFormat[musicxml.Elementu45position] = new DefaultMusicxml_Elementu45positionFormat {}
  implicit lazy val Musicxml_Groupu45nameu45textFormat: scalaxb.AttributeGroupFormat[musicxml.Groupu45nameu45text] = new DefaultMusicxml_Groupu45nameu45textFormat {}
  implicit lazy val Musicxml_Partu45attributesFormat: scalaxb.AttributeGroupFormat[musicxml.Partu45attributes] = new DefaultMusicxml_Partu45attributesFormat {}
  implicit lazy val Musicxml_Yesu45noFormat: scalaxb.XMLFormat[musicxml.Yesu45no] = new DefaultMusicxml_Yesu45noFormat {}
  implicit lazy val Musicxml_OpusFormat: scalaxb.XMLFormat[musicxml.Opus] = new DefaultMusicxml_OpusFormat {}
  implicit lazy val Musicxml_Opusu45linkFormat: scalaxb.XMLFormat[musicxml.Opusu45link] = new DefaultMusicxml_Opusu45linkFormat {}
  implicit lazy val Musicxml_ScoreFormat: scalaxb.XMLFormat[musicxml.Score] = new DefaultMusicxml_ScoreFormat {}
  implicit lazy val Musicxml_TypeFormat: scalaxb.XMLFormat[musicxml.Type] = new DefaultMusicxml_TypeFormat {}
  implicit lazy val Musicxml_ShowFormat: scalaxb.XMLFormat[musicxml.Show] = new DefaultMusicxml_ShowFormat {}
  implicit lazy val Musicxml_ActuateFormat: scalaxb.XMLFormat[musicxml.Actuate] = new DefaultMusicxml_ActuateFormat {}
  implicit lazy val Musicxml_SpaceTypeFormat: scalaxb.XMLFormat[musicxml.SpaceType] = new DefaultMusicxml_SpaceTypeFormat {}
  implicit lazy val Musicxml_SpecialAttrsFormat: scalaxb.AttributeGroupFormat[musicxml.SpecialAttrs] = new DefaultMusicxml_SpecialAttrsFormat {}


  implicit val fromAnySchemaType: scala.xml.Elem => Option[scalaxb.DataRecord[Any]] = {elem =>
    import scalaxb.{Helper, DataRecord, fromXML}

    val ns = Helper.nullOrEmpty(elem.scope.getURI(elem.prefix))
    val key = Some(elem.label)
    val (xsns, xstype) = Helper.instanceType(elem)

    (key, ns) match {
      case (Some("string"), Some("http://www.webserviceX.NET/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[String](elem)))
      case (Some("score-timewise"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[musicxml.Scoreu45timewise](elem)))
      case (Some("score-partwise"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[musicxml.Scoreu45partwise](elem)))
      case (Some("opus"), None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[musicxml.Opus](elem)))

      case _ => None
    }

  }


  def buildMusicxml_Aboveu45belowFormat = new DefaultMusicxml_Aboveu45belowFormat {}
  trait DefaultMusicxml_Aboveu45belowFormat extends scalaxb.XMLFormat[musicxml.Aboveu45below] {
    val targetNamespace: Option[String] = None
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): musicxml.Aboveu45below =
        (fromString0(value, scope)).apply(scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, musicxml.Aboveu45below] = {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("above")) => musicxml.Above
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("below")) => musicxml.BelowValue

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Aboveu45below] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: musicxml.Aboveu45below, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def buildMusicxml_Cssu45fontu45sizeFormat = new DefaultMusicxml_Cssu45fontu45sizeFormat {}
  trait DefaultMusicxml_Cssu45fontu45sizeFormat extends scalaxb.XMLFormat[musicxml.Cssu45fontu45size] {
    val targetNamespace: Option[String] = None
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): musicxml.Cssu45fontu45size =
        (fromString0(value, scope)).apply(scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, musicxml.Cssu45fontu45size] = {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("xx-small")) => musicxml.Xxu45small
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("x-small")) => musicxml.Xu45small
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("small")) => musicxml.Small
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("medium")) => musicxml.MediumValue
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("large")) => musicxml.Large
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("x-large")) => musicxml.Xu45large
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("xx-large")) => musicxml.Xxu45large

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Cssu45fontu45size] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: musicxml.Cssu45fontu45size, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def buildMusicxml_Enclosureu45shapeFormat = new DefaultMusicxml_Enclosureu45shapeFormat {}
  trait DefaultMusicxml_Enclosureu45shapeFormat extends scalaxb.XMLFormat[musicxml.Enclosureu45shape] {
    val targetNamespace: Option[String] = None
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): musicxml.Enclosureu45shape =
        (fromString0(value, scope)).apply(scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, musicxml.Enclosureu45shape] = {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("rectangle")) => musicxml.RectangleValue
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("square")) => musicxml.SquareValue3
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("oval")) => musicxml.Oval
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("circle")) => musicxml.Circle
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("bracket")) => musicxml.BracketValue3
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("triangle")) => musicxml.TriangleValue2
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("diamond")) => musicxml.DiamondValue
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("pentagon")) => musicxml.Pentagon
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("hexagon")) => musicxml.Hexagon
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("heptagon")) => musicxml.Heptagon
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("octagon")) => musicxml.Octagon
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("nonagon")) => musicxml.Nonagon
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("decagon")) => musicxml.Decagon
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("none")) => musicxml.NoneTypeValue9

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Enclosureu45shape] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: musicxml.Enclosureu45shape, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def buildMusicxml_Fermatau45shapeFormat = new DefaultMusicxml_Fermatau45shapeFormat {}
  trait DefaultMusicxml_Fermatau45shapeFormat extends scalaxb.XMLFormat[musicxml.Fermatau45shape] {
    val targetNamespace: Option[String] = None
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): musicxml.Fermatau45shape =
        (fromString0(value, scope)).apply(scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, musicxml.Fermatau45shape] = {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("normal")) => musicxml.NormalValue3
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("angled")) => musicxml.Angled
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("square")) => musicxml.SquareValue2
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("double-angled")) => musicxml.Doubleu45angled
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("double-square")) => musicxml.Doubleu45square
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("double-dot")) => musicxml.Doubleu45dot
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("half-curve")) => musicxml.Halfu45curve
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("curlew")) => musicxml.Curlew
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("")) => musicxml.BlankValue

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Fermatau45shape] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: musicxml.Fermatau45shape, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def buildMusicxml_Fontu45styleFormat = new DefaultMusicxml_Fontu45styleFormat {}
  trait DefaultMusicxml_Fontu45styleFormat extends scalaxb.XMLFormat[musicxml.Fontu45style] {
    val targetNamespace: Option[String] = None
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): musicxml.Fontu45style =
        (fromString0(value, scope)).apply(scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, musicxml.Fontu45style] = {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("normal")) => musicxml.NormalValue2
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("italic")) => musicxml.Italic

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Fontu45style] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: musicxml.Fontu45style, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def buildMusicxml_Fontu45weightFormat = new DefaultMusicxml_Fontu45weightFormat {}
  trait DefaultMusicxml_Fontu45weightFormat extends scalaxb.XMLFormat[musicxml.Fontu45weight] {
    val targetNamespace: Option[String] = None
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): musicxml.Fontu45weight =
        (fromString0(value, scope)).apply(scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, musicxml.Fontu45weight] = {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("normal")) => musicxml.NormalValue4
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("bold")) => musicxml.Bold

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Fontu45weight] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: musicxml.Fontu45weight, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def buildMusicxml_Leftu45centeru45rightFormat = new DefaultMusicxml_Leftu45centeru45rightFormat {}
  trait DefaultMusicxml_Leftu45centeru45rightFormat extends scalaxb.XMLFormat[musicxml.Leftu45centeru45right] {
    val targetNamespace: Option[String] = None
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): musicxml.Leftu45centeru45right =
        (fromString0(value, scope)).apply(scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, musicxml.Leftu45centeru45right] = {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("left")) => musicxml.LeftTypeValue2
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("center")) => musicxml.CenterValue
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("right")) => musicxml.RightTypeValue2

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Leftu45centeru45right] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: musicxml.Leftu45centeru45right, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def buildMusicxml_Leftu45rightFormat = new DefaultMusicxml_Leftu45rightFormat {}
  trait DefaultMusicxml_Leftu45rightFormat extends scalaxb.XMLFormat[musicxml.Leftu45right] {
    val targetNamespace: Option[String] = None
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): musicxml.Leftu45right =
        (fromString0(value, scope)).apply(scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, musicxml.Leftu45right] = {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("left")) => musicxml.LeftTypeValue3
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("right")) => musicxml.RightTypeValue3

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Leftu45right] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: musicxml.Leftu45right, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def buildMusicxml_Lineu45lengthFormat = new DefaultMusicxml_Lineu45lengthFormat {}
  trait DefaultMusicxml_Lineu45lengthFormat extends scalaxb.XMLFormat[musicxml.Lineu45length] {
    val targetNamespace: Option[String] = None
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): musicxml.Lineu45length =
        (fromString0(value, scope)).apply(scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, musicxml.Lineu45length] = {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("short")) => musicxml.ShortTypeValue
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("medium")) => musicxml.Medium
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("long")) => musicxml.LongType

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Lineu45length] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: musicxml.Lineu45length, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def buildMusicxml_Lineu45shapeFormat = new DefaultMusicxml_Lineu45shapeFormat {}
  trait DefaultMusicxml_Lineu45shapeFormat extends scalaxb.XMLFormat[musicxml.Lineu45shape] {
    val targetNamespace: Option[String] = None
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): musicxml.Lineu45shape =
        (fromString0(value, scope)).apply(scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, musicxml.Lineu45shape] = {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("straight")) => musicxml.StraightValue2
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("curved")) => musicxml.CurvedValue

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Lineu45shape] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: musicxml.Lineu45shape, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def buildMusicxml_Lineu45typeFormat = new DefaultMusicxml_Lineu45typeFormat {}
  trait DefaultMusicxml_Lineu45typeFormat extends scalaxb.XMLFormat[musicxml.Lineu45type] {
    val targetNamespace: Option[String] = None
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): musicxml.Lineu45type =
        (fromString0(value, scope)).apply(scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, musicxml.Lineu45type] = {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("solid")) => musicxml.Solid
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("dashed")) => musicxml.DashedValue
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("dotted")) => musicxml.DottedValue
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("wavy")) => musicxml.Wavy

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Lineu45type] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: musicxml.Lineu45type, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def buildMusicxml_MuteFormat = new DefaultMusicxml_MuteFormat {}
  trait DefaultMusicxml_MuteFormat extends scalaxb.XMLFormat[musicxml.Mute] {
    val targetNamespace: Option[String] = None
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): musicxml.Mute =
        (fromString0(value, scope)).apply(scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, musicxml.Mute] = {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("on")) => musicxml.On
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("off")) => musicxml.Off
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("straight")) => musicxml.StraightValue
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("cup")) => musicxml.Cup
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("harmon-no-stem")) => musicxml.Harmonu45nou45stem
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("harmon-stem")) => musicxml.Harmonu45stem
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("bucket")) => musicxml.Bucket
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("plunger")) => musicxml.Plunger
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("hat")) => musicxml.Hat
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("solotone")) => musicxml.Solotone
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("practice")) => musicxml.Practice
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("stop-mute")) => musicxml.Stopu45mute
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("stop-hand")) => musicxml.Stopu45hand
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("echo")) => musicxml.EchoValue
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("palm")) => musicxml.Palm

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Mute] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: musicxml.Mute, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def buildMusicxml_Overu45underFormat = new DefaultMusicxml_Overu45underFormat {}
  trait DefaultMusicxml_Overu45underFormat extends scalaxb.XMLFormat[musicxml.Overu45under] {
    val targetNamespace: Option[String] = None
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): musicxml.Overu45under =
        (fromString0(value, scope)).apply(scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, musicxml.Overu45under] = {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("over")) => musicxml.Over
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("under")) => musicxml.Under

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Overu45under] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: musicxml.Overu45under, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def buildMusicxml_Semiu45pitchedFormat = new DefaultMusicxml_Semiu45pitchedFormat {}
  trait DefaultMusicxml_Semiu45pitchedFormat extends scalaxb.XMLFormat[musicxml.Semiu45pitched] {
    val targetNamespace: Option[String] = None
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): musicxml.Semiu45pitched =
        (fromString0(value, scope)).apply(scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, musicxml.Semiu45pitched] = {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("high")) => musicxml.High
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("medium-high")) => musicxml.Mediumu45high
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("medium")) => musicxml.MediumValue2
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("medium-low")) => musicxml.Mediumu45low
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("low")) => musicxml.Low
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("very-low")) => musicxml.Veryu45low

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Semiu45pitched] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: musicxml.Semiu45pitched, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def buildMusicxml_Startu45noteFormat = new DefaultMusicxml_Startu45noteFormat {}
  trait DefaultMusicxml_Startu45noteFormat extends scalaxb.XMLFormat[musicxml.Startu45note] {
    val targetNamespace: Option[String] = None
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): musicxml.Startu45note =
        (fromString0(value, scope)).apply(scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, musicxml.Startu45note] = {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("upper")) => musicxml.Upper
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("main")) => musicxml.Main
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("below")) => musicxml.Below

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Startu45note] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: musicxml.Startu45note, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def buildMusicxml_Startu45stopFormat = new DefaultMusicxml_Startu45stopFormat {}
  trait DefaultMusicxml_Startu45stopFormat extends scalaxb.XMLFormat[musicxml.Startu45stop] {
    val targetNamespace: Option[String] = None
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): musicxml.Startu45stop =
        (fromString0(value, scope)).apply(scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, musicxml.Startu45stop] = {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("start")) => musicxml.StartValue4
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("stop")) => musicxml.StopValue5

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Startu45stop] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: musicxml.Startu45stop, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def buildMusicxml_Startu45stopu45continueFormat = new DefaultMusicxml_Startu45stopu45continueFormat {}
  trait DefaultMusicxml_Startu45stopu45continueFormat extends scalaxb.XMLFormat[musicxml.Startu45stopu45continue] {
    val targetNamespace: Option[String] = None
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): musicxml.Startu45stopu45continue =
        (fromString0(value, scope)).apply(scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, musicxml.Startu45stopu45continue] = {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("start")) => musicxml.StartValue3
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("stop")) => musicxml.StopValue4
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("continue")) => musicxml.ContinueValue4

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Startu45stopu45continue] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: musicxml.Startu45stopu45continue, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def buildMusicxml_Startu45stopu45singleFormat = new DefaultMusicxml_Startu45stopu45singleFormat {}
  trait DefaultMusicxml_Startu45stopu45singleFormat extends scalaxb.XMLFormat[musicxml.Startu45stopu45single] {
    val targetNamespace: Option[String] = None
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): musicxml.Startu45stopu45single =
        (fromString0(value, scope)).apply(scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, musicxml.Startu45stopu45single] = {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("start")) => musicxml.StartValue5
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("stop")) => musicxml.StopValue6
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("single")) => musicxml.SingleValue2

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Startu45stopu45single] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: musicxml.Startu45stopu45single, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def buildMusicxml_Symbolu45sizeFormat = new DefaultMusicxml_Symbolu45sizeFormat {}
  trait DefaultMusicxml_Symbolu45sizeFormat extends scalaxb.XMLFormat[musicxml.Symbolu45size] {
    val targetNamespace: Option[String] = None
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): musicxml.Symbolu45size =
        (fromString0(value, scope)).apply(scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, musicxml.Symbolu45size] = {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("full")) => musicxml.Full
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("cue")) => musicxml.Cue
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("grace-cue")) => musicxml.Graceu45cue
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("large")) => musicxml.LargeValue

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Symbolu45size] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: musicxml.Symbolu45size, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def buildMusicxml_Textu45directionFormat = new DefaultMusicxml_Textu45directionFormat {}
  trait DefaultMusicxml_Textu45directionFormat extends scalaxb.XMLFormat[musicxml.Textu45direction] {
    val targetNamespace: Option[String] = None
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): musicxml.Textu45direction =
        (fromString0(value, scope)).apply(scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, musicxml.Textu45direction] = {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("ltr")) => musicxml.Ltr
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("rtl")) => musicxml.Rtl
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("lro")) => musicxml.Lro
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("rlo")) => musicxml.Rlo

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Textu45direction] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: musicxml.Textu45direction, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def buildMusicxml_Tiedu45typeFormat = new DefaultMusicxml_Tiedu45typeFormat {}
  trait DefaultMusicxml_Tiedu45typeFormat extends scalaxb.XMLFormat[musicxml.Tiedu45type] {
    val targetNamespace: Option[String] = None
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): musicxml.Tiedu45type =
        (fromString0(value, scope)).apply(scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, musicxml.Tiedu45type] = {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("start")) => musicxml.StartValue2
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("stop")) => musicxml.StopValue3
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("continue")) => musicxml.ContinueValue3
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("let-ring")) => musicxml.Letu45ring

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Tiedu45type] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: musicxml.Tiedu45type, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def buildMusicxml_Topu45bottomFormat = new DefaultMusicxml_Topu45bottomFormat {}
  trait DefaultMusicxml_Topu45bottomFormat extends scalaxb.XMLFormat[musicxml.Topu45bottom] {
    val targetNamespace: Option[String] = None
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): musicxml.Topu45bottom =
        (fromString0(value, scope)).apply(scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, musicxml.Topu45bottom] = {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("top")) => musicxml.TopValue
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("bottom")) => musicxml.BottomValue

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Topu45bottom] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: musicxml.Topu45bottom, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def buildMusicxml_Tremolou45typeFormat = new DefaultMusicxml_Tremolou45typeFormat {}
  trait DefaultMusicxml_Tremolou45typeFormat extends scalaxb.XMLFormat[musicxml.Tremolou45type] {
    val targetNamespace: Option[String] = None
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): musicxml.Tremolou45type =
        (fromString0(value, scope)).apply(scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, musicxml.Tremolou45type] = {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("start")) => musicxml.StartValue6
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("stop")) => musicxml.StopValue7
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("single")) => musicxml.SingleValue3
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("unmeasured")) => musicxml.Unmeasured

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Tremolou45type] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: musicxml.Tremolou45type, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def buildMusicxml_Trillu45stepFormat = new DefaultMusicxml_Trillu45stepFormat {}
  trait DefaultMusicxml_Trillu45stepFormat extends scalaxb.XMLFormat[musicxml.Trillu45step] {
    val targetNamespace: Option[String] = None
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): musicxml.Trillu45step =
        (fromString0(value, scope)).apply(scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, musicxml.Trillu45step] = {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("whole")) => musicxml.WholeValue
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("half")) => musicxml.HalfValue3
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("unison")) => musicxml.Unison

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Trillu45step] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: musicxml.Trillu45step, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def buildMusicxml_Twou45noteu45turnFormat = new DefaultMusicxml_Twou45noteu45turnFormat {}
  trait DefaultMusicxml_Twou45noteu45turnFormat extends scalaxb.XMLFormat[musicxml.Twou45noteu45turn] {
    val targetNamespace: Option[String] = None
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): musicxml.Twou45noteu45turn =
        (fromString0(value, scope)).apply(scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, musicxml.Twou45noteu45turn] = {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("whole")) => musicxml.Whole
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("half")) => musicxml.HalfValue2
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("none")) => musicxml.NoneTypeValue8

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Twou45noteu45turn] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: musicxml.Twou45noteu45turn, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def buildMusicxml_Upu45downFormat = new DefaultMusicxml_Upu45downFormat {}
  trait DefaultMusicxml_Upu45downFormat extends scalaxb.XMLFormat[musicxml.Upu45down] {
    val targetNamespace: Option[String] = None
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): musicxml.Upu45down =
        (fromString0(value, scope)).apply(scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, musicxml.Upu45down] = {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("up")) => musicxml.UpValue
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("down")) => musicxml.DownValue

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Upu45down] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: musicxml.Upu45down, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def buildMusicxml_Uprightu45invertedFormat = new DefaultMusicxml_Uprightu45invertedFormat {}
  trait DefaultMusicxml_Uprightu45invertedFormat extends scalaxb.XMLFormat[musicxml.Uprightu45inverted] {
    val targetNamespace: Option[String] = None
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): musicxml.Uprightu45inverted =
        (fromString0(value, scope)).apply(scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, musicxml.Uprightu45inverted] = {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("upright")) => musicxml.Upright
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("inverted")) => musicxml.Inverted

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Uprightu45inverted] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: musicxml.Uprightu45inverted, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def buildMusicxml_ValignFormat = new DefaultMusicxml_ValignFormat {}
  trait DefaultMusicxml_ValignFormat extends scalaxb.XMLFormat[musicxml.Valign] {
    val targetNamespace: Option[String] = None
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): musicxml.Valign =
        (fromString0(value, scope)).apply(scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, musicxml.Valign] = {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("top")) => musicxml.TopValue2
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("middle")) => musicxml.MiddleValue3
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("bottom")) => musicxml.BottomValue2
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("baseline")) => musicxml.Baseline

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Valign] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: musicxml.Valign, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def buildMusicxml_Valignu45imageFormat = new DefaultMusicxml_Valignu45imageFormat {}
  trait DefaultMusicxml_Valignu45imageFormat extends scalaxb.XMLFormat[musicxml.Valignu45image] {
    val targetNamespace: Option[String] = None
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): musicxml.Valignu45image =
        (fromString0(value, scope)).apply(scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, musicxml.Valignu45image] = {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("top")) => musicxml.Top
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("middle")) => musicxml.MiddleValue2
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("bottom")) => musicxml.Bottom

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Valignu45image] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: musicxml.Valignu45image, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def buildMusicxml_Cancelu45locationFormat = new DefaultMusicxml_Cancelu45locationFormat {}
  trait DefaultMusicxml_Cancelu45locationFormat extends scalaxb.XMLFormat[musicxml.Cancelu45location] {
    val targetNamespace: Option[String] = None
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): musicxml.Cancelu45location =
        (fromString0(value, scope)).apply(scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, musicxml.Cancelu45location] = {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("left")) => musicxml.LeftTypeValue
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("right")) => musicxml.RightTypeValue
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("before-barline")) => musicxml.Beforeu45barline

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Cancelu45location] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: musicxml.Cancelu45location, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def buildMusicxml_Clefu45signFormat = new DefaultMusicxml_Clefu45signFormat {}
  trait DefaultMusicxml_Clefu45signFormat extends scalaxb.XMLFormat[musicxml.Clefu45sign] {
    val targetNamespace: Option[String] = None
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): musicxml.Clefu45sign =
        (fromString0(value, scope)).apply(scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, musicxml.Clefu45sign] = {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("G")) => musicxml.G
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("F")) => musicxml.F
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("C")) => musicxml.C
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("percussion")) => musicxml.Percussion
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("TAB")) => musicxml.TAB
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("jianpu")) => musicxml.Jianpu
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("none")) => musicxml.NoneTypeValue10

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Clefu45sign] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: musicxml.Clefu45sign, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def buildMusicxml_Showu45fretsFormat = new DefaultMusicxml_Showu45fretsFormat {}
  trait DefaultMusicxml_Showu45fretsFormat extends scalaxb.XMLFormat[musicxml.Showu45frets] {
    val targetNamespace: Option[String] = None
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): musicxml.Showu45frets =
        (fromString0(value, scope)).apply(scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, musicxml.Showu45frets] = {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("numbers")) => musicxml.Numbers
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("letters")) => musicxml.Letters

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Showu45frets] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: musicxml.Showu45frets, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def buildMusicxml_Staffu45typeFormat = new DefaultMusicxml_Staffu45typeFormat {}
  trait DefaultMusicxml_Staffu45typeFormat extends scalaxb.XMLFormat[musicxml.Staffu45type] {
    val targetNamespace: Option[String] = None
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): musicxml.Staffu45type =
        (fromString0(value, scope)).apply(scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, musicxml.Staffu45type] = {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("ossia")) => musicxml.Ossia
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("cue")) => musicxml.CueValue
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("editorial")) => musicxml.Editorial
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("regular")) => musicxml.RegularValue
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("alternate")) => musicxml.Alternate

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Staffu45type] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: musicxml.Staffu45type, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def buildMusicxml_Timeu45relationFormat = new DefaultMusicxml_Timeu45relationFormat {}
  trait DefaultMusicxml_Timeu45relationFormat extends scalaxb.XMLFormat[musicxml.Timeu45relation] {
    val targetNamespace: Option[String] = None
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): musicxml.Timeu45relation =
        (fromString0(value, scope)).apply(scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, musicxml.Timeu45relation] = {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("parentheses")) => musicxml.Parentheses
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("bracket")) => musicxml.BracketValue2
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("equals")) => musicxml.Equals
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("slash")) => musicxml.SlashValue
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("space")) => musicxml.Space
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("hyphen")) => musicxml.Hyphen

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Timeu45relation] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: musicxml.Timeu45relation, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def buildMusicxml_Timeu45separatorFormat = new DefaultMusicxml_Timeu45separatorFormat {}
  trait DefaultMusicxml_Timeu45separatorFormat extends scalaxb.XMLFormat[musicxml.Timeu45separator] {
    val targetNamespace: Option[String] = None
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): musicxml.Timeu45separator =
        (fromString0(value, scope)).apply(scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, musicxml.Timeu45separator] = {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("none")) => musicxml.NoneTypeValue11
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("horizontal")) => musicxml.Horizontal
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("diagonal")) => musicxml.Diagonal
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("vertical")) => musicxml.Vertical
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("adjacent")) => musicxml.Adjacent

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Timeu45separator] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: musicxml.Timeu45separator, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def buildMusicxml_Timeu45symbolFormat = new DefaultMusicxml_Timeu45symbolFormat {}
  trait DefaultMusicxml_Timeu45symbolFormat extends scalaxb.XMLFormat[musicxml.Timeu45symbol] {
    val targetNamespace: Option[String] = None
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): musicxml.Timeu45symbol =
        (fromString0(value, scope)).apply(scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, musicxml.Timeu45symbol] = {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("common")) => musicxml.Common
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("cut")) => musicxml.Cut
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("single-number")) => musicxml.Singleu45number
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("note")) => musicxml.NoteValue
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("dotted-note")) => musicxml.Dottedu45note
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("normal")) => musicxml.NormalValue

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Timeu45symbol] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: musicxml.Timeu45symbol, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def buildMusicxml_Backwardu45forwardFormat = new DefaultMusicxml_Backwardu45forwardFormat {}
  trait DefaultMusicxml_Backwardu45forwardFormat extends scalaxb.XMLFormat[musicxml.Backwardu45forward] {
    val targetNamespace: Option[String] = None
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): musicxml.Backwardu45forward =
        (fromString0(value, scope)).apply(scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, musicxml.Backwardu45forward] = {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("backward")) => musicxml.Backward
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("forward")) => musicxml.ForwardValue

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Backwardu45forward] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: musicxml.Backwardu45forward, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def buildMusicxml_Baru45styleFormat = new DefaultMusicxml_Baru45styleFormat {}
  trait DefaultMusicxml_Baru45styleFormat extends scalaxb.XMLFormat[musicxml.Baru45style] {
    val targetNamespace: Option[String] = None
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): musicxml.Baru45style =
        (fromString0(value, scope)).apply(scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, musicxml.Baru45style] = {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("regular")) => musicxml.Regular
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("dotted")) => musicxml.Dotted
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("dashed")) => musicxml.Dashed
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("heavy")) => musicxml.Heavy
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("light-light")) => musicxml.Lightu45light
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("light-heavy")) => musicxml.Lightu45heavy
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("heavy-light")) => musicxml.Heavyu45light
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("heavy-heavy")) => musicxml.Heavyu45heavy
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("tick")) => musicxml.TickValue
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("short")) => musicxml.ShortType
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("none")) => musicxml.NoneTypeValue7

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Baru45style] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: musicxml.Baru45style, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def buildMusicxml_Rightu45leftu45middleFormat = new DefaultMusicxml_Rightu45leftu45middleFormat {}
  trait DefaultMusicxml_Rightu45leftu45middleFormat extends scalaxb.XMLFormat[musicxml.Rightu45leftu45middle] {
    val targetNamespace: Option[String] = None
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): musicxml.Rightu45leftu45middle =
        (fromString0(value, scope)).apply(scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, musicxml.Rightu45leftu45middle] = {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("right")) => musicxml.RightType
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("left")) => musicxml.LeftType
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("middle")) => musicxml.MiddleValue

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Rightu45leftu45middle] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: musicxml.Rightu45leftu45middle, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def buildMusicxml_Startu45stopu45discontinueFormat = new DefaultMusicxml_Startu45stopu45discontinueFormat {}
  trait DefaultMusicxml_Startu45stopu45discontinueFormat extends scalaxb.XMLFormat[musicxml.Startu45stopu45discontinue] {
    val targetNamespace: Option[String] = None
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): musicxml.Startu45stopu45discontinue =
        (fromString0(value, scope)).apply(scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, musicxml.Startu45stopu45discontinue] = {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("start")) => musicxml.StartValue7
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("stop")) => musicxml.StopValue8
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("discontinue")) => musicxml.Discontinue

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Startu45stopu45discontinue] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: musicxml.Startu45stopu45discontinue, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def buildMusicxml_WingedFormat = new DefaultMusicxml_WingedFormat {}
  trait DefaultMusicxml_WingedFormat extends scalaxb.XMLFormat[musicxml.Winged] {
    val targetNamespace: Option[String] = None
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): musicxml.Winged =
        (fromString0(value, scope)).apply(scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, musicxml.Winged] = {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("none")) => musicxml.NoneTypeValue6
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("straight")) => musicxml.Straight
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("curved")) => musicxml.Curved
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("double-straight")) => musicxml.Doubleu45straight
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("double-curved")) => musicxml.Doubleu45curved

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Winged] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: musicxml.Winged, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def buildMusicxml_Beateru45valueFormat = new DefaultMusicxml_Beateru45valueFormat {}
  trait DefaultMusicxml_Beateru45valueFormat extends scalaxb.XMLFormat[musicxml.Beateru45value] {
    val targetNamespace: Option[String] = None
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): musicxml.Beateru45value =
        (fromString0(value, scope)).apply(scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, musicxml.Beateru45value] = {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("bow")) => musicxml.Bow
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("chime hammer")) => musicxml.Chimehammer
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("coin")) => musicxml.Coin
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("drum stick")) => musicxml.Drumstick
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("finger")) => musicxml.Finger
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("fingernail")) => musicxml.Fingernail
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("fist")) => musicxml.Fist
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("guiro scraper")) => musicxml.Guiroscraper
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("hammer")) => musicxml.HammerValue
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("hand")) => musicxml.Hand
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("jazz stick")) => musicxml.Jazzstick
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("knitting needle")) => musicxml.Knittingneedle
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("metal hammer")) => musicxml.Metalhammer
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("slide brush on gong")) => musicxml.Slidebrushongong
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("snare stick")) => musicxml.Snarestick
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("spoon mallet")) => musicxml.Spoonmallet
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("superball")) => musicxml.SuperballValue
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("triangle beater")) => musicxml.Trianglebeater
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("triangle beater plain")) => musicxml.Trianglebeaterplain
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("wire brush")) => musicxml.Wirebrush

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Beateru45value] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: musicxml.Beateru45value, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def buildMusicxml_Degreeu45symbolu45valueFormat = new DefaultMusicxml_Degreeu45symbolu45valueFormat {}
  trait DefaultMusicxml_Degreeu45symbolu45valueFormat extends scalaxb.XMLFormat[musicxml.Degreeu45symbolu45value] {
    val targetNamespace: Option[String] = None
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): musicxml.Degreeu45symbolu45value =
        (fromString0(value, scope)).apply(scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, musicxml.Degreeu45symbolu45value] = {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("major")) => musicxml.MajorValue
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("minor")) => musicxml.MinorValue
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("augmented")) => musicxml.AugmentedValue
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("diminished")) => musicxml.DiminishedValue
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("half-diminished")) => musicxml.Halfu45diminishedValue

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Degreeu45symbolu45value] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: musicxml.Degreeu45symbolu45value, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def buildMusicxml_Degreeu45typeu45valueFormat = new DefaultMusicxml_Degreeu45typeu45valueFormat {}
  trait DefaultMusicxml_Degreeu45typeu45valueFormat extends scalaxb.XMLFormat[musicxml.Degreeu45typeu45value] {
    val targetNamespace: Option[String] = None
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): musicxml.Degreeu45typeu45value =
        (fromString0(value, scope)).apply(scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, musicxml.Degreeu45typeu45value] = {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("add")) => musicxml.Add
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("alter")) => musicxml.Alter
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("subtract")) => musicxml.Subtract

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Degreeu45typeu45value] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: musicxml.Degreeu45typeu45value, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def buildMusicxml_EffectFormat = new DefaultMusicxml_EffectFormat {}
  trait DefaultMusicxml_EffectFormat extends scalaxb.XMLFormat[musicxml.Effect] {
    val targetNamespace: Option[String] = None
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): musicxml.Effect =
        (fromString0(value, scope)).apply(scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, musicxml.Effect] = {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("anvil")) => musicxml.Anvil
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("auto horn")) => musicxml.Autohorn
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("bird whistle")) => musicxml.Birdwhistle
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("cannon")) => musicxml.Cannon
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("duck call")) => musicxml.Duckcall
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("gun shot")) => musicxml.Gunshot
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("klaxon horn")) => musicxml.Klaxonhorn
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("lions roar")) => musicxml.Lionsroar
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("lotus flute")) => musicxml.Lotusflute
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("megaphone")) => musicxml.Megaphone
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("police whistle")) => musicxml.Policewhistle
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("siren")) => musicxml.Siren
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("slide whistle")) => musicxml.Slidewhistle
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("thunder sheet")) => musicxml.Thundersheet
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("wind machine")) => musicxml.Windmachine
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("wind whistle")) => musicxml.Windwhistle

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Effect] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: musicxml.Effect, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def buildMusicxml_Glassu45valueFormat = new DefaultMusicxml_Glassu45valueFormat {}
  trait DefaultMusicxml_Glassu45valueFormat extends scalaxb.XMLFormat[musicxml.Glassu45value] {
    val targetNamespace: Option[String] = None
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): musicxml.Glassu45value =
        (fromString0(value, scope)).apply(scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, musicxml.Glassu45value] = {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("glass harmonica")) => musicxml.Glassharmonica
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("glass harp")) => musicxml.Glassharp
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("wind chimes")) => musicxml.Windchimes

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Glassu45value] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: musicxml.Glassu45value, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def buildMusicxml_Harmonyu45typeFormat = new DefaultMusicxml_Harmonyu45typeFormat {}
  trait DefaultMusicxml_Harmonyu45typeFormat extends scalaxb.XMLFormat[musicxml.Harmonyu45type] {
    val targetNamespace: Option[String] = None
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): musicxml.Harmonyu45type =
        (fromString0(value, scope)).apply(scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, musicxml.Harmonyu45type] = {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("explicit")) => musicxml.Explicit
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("implied")) => musicxml.Implied
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("alternate")) => musicxml.AlternateValue

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Harmonyu45type] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: musicxml.Harmonyu45type, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def buildMusicxml_Kindu45valueFormat = new DefaultMusicxml_Kindu45valueFormat {}
  trait DefaultMusicxml_Kindu45valueFormat extends scalaxb.XMLFormat[musicxml.Kindu45value] {
    val targetNamespace: Option[String] = None
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): musicxml.Kindu45value =
        (fromString0(value, scope)).apply(scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, musicxml.Kindu45value] = {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("major")) => musicxml.Major
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("minor")) => musicxml.Minor
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("augmented")) => musicxml.Augmented
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("diminished")) => musicxml.Diminished
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("dominant")) => musicxml.Dominant
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("major-seventh")) => musicxml.Majoru45seventh
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("minor-seventh")) => musicxml.Minoru45seventh
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("diminished-seventh")) => musicxml.Diminishedu45seventh
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("augmented-seventh")) => musicxml.Augmentedu45seventh
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("half-diminished")) => musicxml.Halfu45diminished
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("major-minor")) => musicxml.Majoru45minor
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("major-sixth")) => musicxml.Majoru45sixth
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("minor-sixth")) => musicxml.Minoru45sixth
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("dominant-ninth")) => musicxml.Dominantu45ninth
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("major-ninth")) => musicxml.Majoru45ninth
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("minor-ninth")) => musicxml.Minoru45ninth
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("dominant-11th")) => musicxml.Dominantu4511th
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("major-11th")) => musicxml.Majoru4511th
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("minor-11th")) => musicxml.Minoru4511th
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("dominant-13th")) => musicxml.Dominantu4513th
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("major-13th")) => musicxml.Majoru4513th
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("minor-13th")) => musicxml.Minoru4513th
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("suspended-second")) => musicxml.Suspendedu45second
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("suspended-fourth")) => musicxml.Suspendedu45fourth
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("Neapolitan")) => musicxml.Neapolitan
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("Italian")) => musicxml.Italian
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("French")) => musicxml.French
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("German")) => musicxml.German
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("pedal")) => musicxml.PedalValue
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("power")) => musicxml.Power
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("Tristan")) => musicxml.Tristan
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("other")) => musicxml.OtherValue3
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("none")) => musicxml.NoneTypeValue5

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Kindu45value] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: musicxml.Kindu45value, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def buildMusicxml_Lineu45endFormat = new DefaultMusicxml_Lineu45endFormat {}
  trait DefaultMusicxml_Lineu45endFormat extends scalaxb.XMLFormat[musicxml.Lineu45end] {
    val targetNamespace: Option[String] = None
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): musicxml.Lineu45end =
        (fromString0(value, scope)).apply(scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, musicxml.Lineu45end] = {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("up")) => musicxml.UpValue2
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("down")) => musicxml.DownValue2
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("both")) => musicxml.Both
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("arrow")) => musicxml.Arrow
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("none")) => musicxml.NoneTypeValue12

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Lineu45end] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: musicxml.Lineu45end, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def buildMusicxml_Measureu45numberingu45valueFormat = new DefaultMusicxml_Measureu45numberingu45valueFormat {}
  trait DefaultMusicxml_Measureu45numberingu45valueFormat extends scalaxb.XMLFormat[musicxml.Measureu45numberingu45value] {
    val targetNamespace: Option[String] = None
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): musicxml.Measureu45numberingu45value =
        (fromString0(value, scope)).apply(scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, musicxml.Measureu45numberingu45value] = {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("none")) => musicxml.NoneTypeValue4
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("measure")) => musicxml.MeasureValue
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("system")) => musicxml.System

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Measureu45numberingu45value] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: musicxml.Measureu45numberingu45value, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def buildMusicxml_MembraneFormat = new DefaultMusicxml_MembraneFormat {}
  trait DefaultMusicxml_MembraneFormat extends scalaxb.XMLFormat[musicxml.Membrane] {
    val targetNamespace: Option[String] = None
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): musicxml.Membrane =
        (fromString0(value, scope)).apply(scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, musicxml.Membrane] = {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("bass drum")) => musicxml.BassdrumValue
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("bass drum on side")) => musicxml.Bassdrumonside
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("bongos")) => musicxml.Bongos
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("Chinese tomtom")) => musicxml.Chinesetomtom
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("conga drum")) => musicxml.Congadrum
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("cuica")) => musicxml.Cuica
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("goblet drum")) => musicxml.Gobletdrum
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("Indo-American tomtom")) => musicxml.Indou45Americantomtom
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("Japanese tomtom")) => musicxml.Japanesetomtom
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("military drum")) => musicxml.Militarydrum
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("snare drum")) => musicxml.Snaredrum
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("snare drum snares off")) => musicxml.Snaredrumsnaresoff
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("tabla")) => musicxml.Tabla
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("tambourine")) => musicxml.Tambourine
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("tenor drum")) => musicxml.Tenordrum
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("timbales")) => musicxml.Timbales
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("tomtom")) => musicxml.Tomtom

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Membrane] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: musicxml.Membrane, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def buildMusicxml_MetalFormat = new DefaultMusicxml_MetalFormat {}
  trait DefaultMusicxml_MetalFormat extends scalaxb.XMLFormat[musicxml.Metal] {
    val targetNamespace: Option[String] = None
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): musicxml.Metal =
        (fromString0(value, scope)).apply(scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, musicxml.Metal] = {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("agogo")) => musicxml.Agogo
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("almglocken")) => musicxml.Almglocken
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("bell")) => musicxml.Bell
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("bell plate")) => musicxml.Bellplate
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("bell tree")) => musicxml.BelltreeValue
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("brake drum")) => musicxml.Brakedrum
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("cencerro")) => musicxml.Cencerro
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("chain rattle")) => musicxml.Chainrattle
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("Chinese cymbal")) => musicxml.Chinesecymbal
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("cowbell")) => musicxml.Cowbell
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("crash cymbals")) => musicxml.Crashcymbals
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("crotale")) => musicxml.Crotale
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("cymbal tongs")) => musicxml.Cymbaltongs
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("domed gong")) => musicxml.Domedgong
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("finger cymbals")) => musicxml.Fingercymbals
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("flexatone")) => musicxml.Flexatone
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("gong")) => musicxml.Gong
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("hi-hat")) => musicxml.Hiu45hat
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("high-hat cymbals")) => musicxml.Highu45hatcymbals
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("handbell")) => musicxml.HandbellValue
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("jaw harp")) => musicxml.Jawharp
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("jingle bells")) => musicxml.Jinglebells
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("musical saw")) => musicxml.Musicalsaw
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("shell bells")) => musicxml.Shellbells
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("sistrum")) => musicxml.Sistrum
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("sizzle cymbal")) => musicxml.Sizzlecymbal
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("sleigh bells")) => musicxml.Sleighbells
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("suspended cymbal")) => musicxml.Suspendedcymbal
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("tam tam")) => musicxml.Tamtam
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("tam tam with beater")) => musicxml.Tamtamwithbeater
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("triangle")) => musicxml.TriangleValue
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("Vietnamese hat")) => musicxml.Vietnamesehat

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Metal] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: musicxml.Metal, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def buildMusicxml_Onu45offFormat = new DefaultMusicxml_Onu45offFormat {}
  trait DefaultMusicxml_Onu45offFormat extends scalaxb.XMLFormat[musicxml.Onu45off] {
    val targetNamespace: Option[String] = None
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): musicxml.Onu45off =
        (fromString0(value, scope)).apply(scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, musicxml.Onu45off] = {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("on")) => musicxml.OnValue
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("off")) => musicxml.OffValue

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Onu45off] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: musicxml.Onu45off, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def buildMusicxml_Pedalu45typeFormat = new DefaultMusicxml_Pedalu45typeFormat {}
  trait DefaultMusicxml_Pedalu45typeFormat extends scalaxb.XMLFormat[musicxml.Pedalu45type] {
    val targetNamespace: Option[String] = None
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): musicxml.Pedalu45type =
        (fromString0(value, scope)).apply(scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, musicxml.Pedalu45type] = {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("start")) => musicxml.StartValue
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("stop")) => musicxml.StopValue2
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("sostenuto")) => musicxml.Sostenuto
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("change")) => musicxml.ChangeValue
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("continue")) => musicxml.ContinueValue2

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Pedalu45type] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: musicxml.Pedalu45type, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def buildMusicxml_Pitchedu45valueFormat = new DefaultMusicxml_Pitchedu45valueFormat {}
  trait DefaultMusicxml_Pitchedu45valueFormat extends scalaxb.XMLFormat[musicxml.Pitchedu45value] {
    val targetNamespace: Option[String] = None
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): musicxml.Pitchedu45value =
        (fromString0(value, scope)).apply(scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, musicxml.Pitchedu45value] = {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("celesta")) => musicxml.Celesta
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("chimes")) => musicxml.Chimes
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("glockenspiel")) => musicxml.GlockenspielValue
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("lithophone")) => musicxml.Lithophone
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("mallet")) => musicxml.Mallet
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("marimba")) => musicxml.Marimba
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("steel drums")) => musicxml.Steeldrums
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("tubaphone")) => musicxml.Tubaphone
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("tubular chimes")) => musicxml.Tubularchimes
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("vibraphone")) => musicxml.Vibraphone
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("xylophone")) => musicxml.XylophoneValue

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Pitchedu45value] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: musicxml.Pitchedu45value, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def buildMusicxml_Principalu45voiceu45symbolFormat = new DefaultMusicxml_Principalu45voiceu45symbolFormat {}
  trait DefaultMusicxml_Principalu45voiceu45symbolFormat extends scalaxb.XMLFormat[musicxml.Principalu45voiceu45symbol] {
    val targetNamespace: Option[String] = None
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): musicxml.Principalu45voiceu45symbol =
        (fromString0(value, scope)).apply(scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, musicxml.Principalu45voiceu45symbol] = {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("Hauptstimme")) => musicxml.Hauptstimme
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("Nebenstimme")) => musicxml.Nebenstimme
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("plain")) => musicxml.Plain
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("none")) => musicxml.NoneTypeValue3

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Principalu45voiceu45symbol] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: musicxml.Principalu45voiceu45symbol, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def buildMusicxml_Staffu45divideu45symbolFormat = new DefaultMusicxml_Staffu45divideu45symbolFormat {}
  trait DefaultMusicxml_Staffu45divideu45symbolFormat extends scalaxb.XMLFormat[musicxml.Staffu45divideu45symbol] {
    val targetNamespace: Option[String] = None
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): musicxml.Staffu45divideu45symbol =
        (fromString0(value, scope)).apply(scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, musicxml.Staffu45divideu45symbol] = {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("down")) => musicxml.DownValue3
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("up")) => musicxml.UpValue3
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("up-down")) => musicxml.Upu45downValue

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Staffu45divideu45symbol] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: musicxml.Staffu45divideu45symbol, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def buildMusicxml_Startu45stopu45changeu45continueFormat = new DefaultMusicxml_Startu45stopu45changeu45continueFormat {}
  trait DefaultMusicxml_Startu45stopu45changeu45continueFormat extends scalaxb.XMLFormat[musicxml.Startu45stopu45changeu45continue] {
    val targetNamespace: Option[String] = None
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): musicxml.Startu45stopu45changeu45continue =
        (fromString0(value, scope)).apply(scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, musicxml.Startu45stopu45changeu45continue] = {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("start")) => musicxml.Start
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("stop")) => musicxml.StopValue
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("change")) => musicxml.Change
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("continue")) => musicxml.ContinueValue

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Startu45stopu45changeu45continue] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: musicxml.Startu45stopu45changeu45continue, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def buildMusicxml_Tipu45directionFormat = new DefaultMusicxml_Tipu45directionFormat {}
  trait DefaultMusicxml_Tipu45directionFormat extends scalaxb.XMLFormat[musicxml.Tipu45direction] {
    val targetNamespace: Option[String] = None
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): musicxml.Tipu45direction =
        (fromString0(value, scope)).apply(scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, musicxml.Tipu45direction] = {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("up")) => musicxml.UpValue4
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("down")) => musicxml.DownValue4
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("left")) => musicxml.LeftTypeValue4
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("right")) => musicxml.RightTypeValue4
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("northwest")) => musicxml.Northwest
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("northeast")) => musicxml.Northeast
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("southeast")) => musicxml.Southeast
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("southwest")) => musicxml.Southwest

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Tipu45direction] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: musicxml.Tipu45direction, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def buildMusicxml_Sticku45locationFormat = new DefaultMusicxml_Sticku45locationFormat {}
  trait DefaultMusicxml_Sticku45locationFormat extends scalaxb.XMLFormat[musicxml.Sticku45location] {
    val targetNamespace: Option[String] = None
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): musicxml.Sticku45location =
        (fromString0(value, scope)).apply(scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, musicxml.Sticku45location] = {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("center")) => musicxml.Center
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("rim")) => musicxml.Rim
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("cymbal bell")) => musicxml.Cymbalbell
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("cymbal edge")) => musicxml.Cymbaledge

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Sticku45location] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: musicxml.Sticku45location, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def buildMusicxml_Sticku45materialFormat = new DefaultMusicxml_Sticku45materialFormat {}
  trait DefaultMusicxml_Sticku45materialFormat extends scalaxb.XMLFormat[musicxml.Sticku45material] {
    val targetNamespace: Option[String] = None
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): musicxml.Sticku45material =
        (fromString0(value, scope)).apply(scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, musicxml.Sticku45material] = {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("soft")) => musicxml.Soft
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("medium")) => musicxml.MediumValue3
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("hard")) => musicxml.Hard
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("shaded")) => musicxml.Shaded
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("x")) => musicxml.XValue

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Sticku45material] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: musicxml.Sticku45material, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def buildMusicxml_Sticku45typeFormat = new DefaultMusicxml_Sticku45typeFormat {}
  trait DefaultMusicxml_Sticku45typeFormat extends scalaxb.XMLFormat[musicxml.Sticku45type] {
    val targetNamespace: Option[String] = None
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): musicxml.Sticku45type =
        (fromString0(value, scope)).apply(scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, musicxml.Sticku45type] = {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("bass drum")) => musicxml.Bassdrum
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("double bass drum")) => musicxml.Doublebassdrum
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("glockenspiel")) => musicxml.Glockenspiel
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("gum")) => musicxml.Gum
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("hammer")) => musicxml.Hammer
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("superball")) => musicxml.Superball
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("timpani")) => musicxml.Timpani
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("wound")) => musicxml.Wound
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("xylophone")) => musicxml.Xylophone
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("yarn")) => musicxml.Yarn

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Sticku45type] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: musicxml.Sticku45type, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def buildMusicxml_Upu45downu45stopu45continueFormat = new DefaultMusicxml_Upu45downu45stopu45continueFormat {}
  trait DefaultMusicxml_Upu45downu45stopu45continueFormat extends scalaxb.XMLFormat[musicxml.Upu45downu45stopu45continue] {
    val targetNamespace: Option[String] = None
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): musicxml.Upu45downu45stopu45continue =
        (fromString0(value, scope)).apply(scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, musicxml.Upu45downu45stopu45continue] = {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("up")) => musicxml.UpValue5
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("down")) => musicxml.DownValue5
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("stop")) => musicxml.StopValue9
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("continue")) => musicxml.ContinueValue5

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Upu45downu45stopu45continue] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: musicxml.Upu45downu45stopu45continue, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def buildMusicxml_Wedgeu45typeFormat = new DefaultMusicxml_Wedgeu45typeFormat {}
  trait DefaultMusicxml_Wedgeu45typeFormat extends scalaxb.XMLFormat[musicxml.Wedgeu45type] {
    val targetNamespace: Option[String] = None
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): musicxml.Wedgeu45type =
        (fromString0(value, scope)).apply(scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, musicxml.Wedgeu45type] = {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("crescendo")) => musicxml.Crescendo
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("diminuendo")) => musicxml.Diminuendo
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("stop")) => musicxml.Stop
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("continue")) => musicxml.Continue

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Wedgeu45type] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: musicxml.Wedgeu45type, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def buildMusicxml_WoodFormat = new DefaultMusicxml_WoodFormat {}
  trait DefaultMusicxml_WoodFormat extends scalaxb.XMLFormat[musicxml.Wood] {
    val targetNamespace: Option[String] = None
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): musicxml.Wood =
        (fromString0(value, scope)).apply(scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, musicxml.Wood] = {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("bamboo scraper")) => musicxml.Bambooscraper
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("board clapper")) => musicxml.Boardclapper
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("cabasa")) => musicxml.Cabasa
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("castanets")) => musicxml.Castanets
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("castanets with handle")) => musicxml.Castanetswithhandle
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("claves")) => musicxml.Claves
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("football rattle")) => musicxml.Footballrattle
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("guiro")) => musicxml.Guiro
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("log drum")) => musicxml.Logdrum
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("maraca")) => musicxml.Maraca
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("maracas")) => musicxml.Maracas
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("quijada")) => musicxml.Quijada
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("rainstick")) => musicxml.Rainstick
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("ratchet")) => musicxml.Ratchet
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("reco-reco")) => musicxml.Recou45reco
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("sandpaper blocks")) => musicxml.Sandpaperblocks
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("slit drum")) => musicxml.Slitdrum
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("temple block")) => musicxml.Templeblock
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("vibraslap")) => musicxml.Vibraslap
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("whip")) => musicxml.Whip
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("wood block")) => musicxml.Woodblock

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Wood] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: musicxml.Wood, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def buildMusicxml_Marginu45typeFormat = new DefaultMusicxml_Marginu45typeFormat {}
  trait DefaultMusicxml_Marginu45typeFormat extends scalaxb.XMLFormat[musicxml.Marginu45type] {
    val targetNamespace: Option[String] = None
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): musicxml.Marginu45type =
        (fromString0(value, scope)).apply(scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, musicxml.Marginu45type] = {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("odd")) => musicxml.Odd
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("even")) => musicxml.Even
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("both")) => musicxml.BothValue

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Marginu45type] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: musicxml.Marginu45type, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def buildMusicxml_Noteu45sizeu45typeFormat = new DefaultMusicxml_Noteu45sizeu45typeFormat {}
  trait DefaultMusicxml_Noteu45sizeu45typeFormat extends scalaxb.XMLFormat[musicxml.Noteu45sizeu45type] {
    val targetNamespace: Option[String] = None
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): musicxml.Noteu45sizeu45type =
        (fromString0(value, scope)).apply(scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, musicxml.Noteu45sizeu45type] = {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("cue")) => musicxml.CueValue2
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("grace")) => musicxml.GraceValue
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("grace-cue")) => musicxml.Graceu45cueValue
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("large")) => musicxml.LargeValue2

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Noteu45sizeu45type] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: musicxml.Noteu45sizeu45type, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def buildMusicxml_Accidentalu45valueFormat = new DefaultMusicxml_Accidentalu45valueFormat {}
  trait DefaultMusicxml_Accidentalu45valueFormat extends scalaxb.XMLFormat[musicxml.Accidentalu45value] {
    val targetNamespace: Option[String] = None
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): musicxml.Accidentalu45value =
        (fromString0(value, scope)).apply(scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, musicxml.Accidentalu45value] = {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("sharp")) => musicxml.Sharp
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("natural")) => musicxml.Natural
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("flat")) => musicxml.Flat
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("double-sharp")) => musicxml.Doubleu45sharp
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("sharp-sharp")) => musicxml.Sharpu45sharp
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("flat-flat")) => musicxml.Flatu45flat
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("natural-sharp")) => musicxml.Naturalu45sharp
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("natural-flat")) => musicxml.Naturalu45flat
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("quarter-flat")) => musicxml.Quarteru45flat
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("quarter-sharp")) => musicxml.Quarteru45sharp
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("three-quarters-flat")) => musicxml.Threeu45quartersu45flat
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("three-quarters-sharp")) => musicxml.Threeu45quartersu45sharp
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("sharp-down")) => musicxml.Sharpu45down
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("sharp-up")) => musicxml.Sharpu45up
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("natural-down")) => musicxml.Naturalu45down
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("natural-up")) => musicxml.Naturalu45up
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("flat-down")) => musicxml.Flatu45down
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("flat-up")) => musicxml.Flatu45up
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("double-sharp-down")) => musicxml.Doubleu45sharpu45down
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("double-sharp-up")) => musicxml.Doubleu45sharpu45up
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("flat-flat-down")) => musicxml.Flatu45flatu45down
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("flat-flat-up")) => musicxml.Flatu45flatu45up
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("arrow-down")) => musicxml.Arrowu45down
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("arrow-up")) => musicxml.Arrowu45up
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("triple-sharp")) => musicxml.Tripleu45sharp
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("triple-flat")) => musicxml.Tripleu45flat
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("slash-quarter-sharp")) => musicxml.Slashu45quarteru45sharp
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("slash-sharp")) => musicxml.Slashu45sharp
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("slash-flat")) => musicxml.Slashu45flat
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("double-slash-flat")) => musicxml.Doubleu45slashu45flat
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("sharp-1")) => musicxml.Sharpu451
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("sharp-2")) => musicxml.Sharpu452
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("sharp-3")) => musicxml.Sharpu453
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("sharp-5")) => musicxml.Sharpu455
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("flat-1")) => musicxml.Flatu451
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("flat-2")) => musicxml.Flatu452
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("flat-3")) => musicxml.Flatu453
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("flat-4")) => musicxml.Flatu454
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("sori")) => musicxml.Sori
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("koron")) => musicxml.Koron
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("other")) => musicxml.OtherValue2

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Accidentalu45value] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: musicxml.Accidentalu45value, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def buildMusicxml_Arrowu45directionFormat = new DefaultMusicxml_Arrowu45directionFormat {}
  trait DefaultMusicxml_Arrowu45directionFormat extends scalaxb.XMLFormat[musicxml.Arrowu45direction] {
    val targetNamespace: Option[String] = None
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): musicxml.Arrowu45direction =
        (fromString0(value, scope)).apply(scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, musicxml.Arrowu45direction] = {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("left")) => musicxml.LeftTypeValue5
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("up")) => musicxml.UpValue6
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("right")) => musicxml.RightTypeValue5
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("down")) => musicxml.DownValue6
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("northwest")) => musicxml.NorthwestValue
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("northeast")) => musicxml.NortheastValue
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("southeast")) => musicxml.SoutheastValue
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("southwest")) => musicxml.SouthwestValue
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("left right")) => musicxml.Leftright
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("up down")) => musicxml.Updown
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("northwest southeast")) => musicxml.Northwestsoutheast
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("northeast southwest")) => musicxml.Northeastsouthwest
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("other")) => musicxml.OtherValue4

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Arrowu45direction] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: musicxml.Arrowu45direction, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def buildMusicxml_Arrowu45styleFormat = new DefaultMusicxml_Arrowu45styleFormat {}
  trait DefaultMusicxml_Arrowu45styleFormat extends scalaxb.XMLFormat[musicxml.Arrowu45style] {
    val targetNamespace: Option[String] = None
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): musicxml.Arrowu45style =
        (fromString0(value, scope)).apply(scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, musicxml.Arrowu45style] = {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("single")) => musicxml.SingleValue
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("double")) => musicxml.DoubleTypeValue
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("filled")) => musicxml.Filled
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("hollow")) => musicxml.Hollow
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("paired")) => musicxml.Paired
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("combined")) => musicxml.Combined
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("other")) => musicxml.OtherValue

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Arrowu45style] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: musicxml.Arrowu45style, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def buildMusicxml_Beamu45valueFormat = new DefaultMusicxml_Beamu45valueFormat {}
  trait DefaultMusicxml_Beamu45valueFormat extends scalaxb.XMLFormat[musicxml.Beamu45value] {
    val targetNamespace: Option[String] = None
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): musicxml.Beamu45value =
        (fromString0(value, scope)).apply(scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, musicxml.Beamu45value] = {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("begin")) => musicxml.BeginValue
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("continue")) => musicxml.ContinueValue6
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("end")) => musicxml.EndValue
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("forward hook")) => musicxml.Forwardhook
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("backward hook")) => musicxml.Backwardhook

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Beamu45value] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: musicxml.Beamu45value, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def buildMusicxml_Breathu45marku45valueFormat = new DefaultMusicxml_Breathu45marku45valueFormat {}
  trait DefaultMusicxml_Breathu45marku45valueFormat extends scalaxb.XMLFormat[musicxml.Breathu45marku45value] {
    val targetNamespace: Option[String] = None
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): musicxml.Breathu45marku45value =
        (fromString0(value, scope)).apply(scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, musicxml.Breathu45marku45value] = {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("")) => musicxml.Blank
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("comma")) => musicxml.Comma
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("tick")) => musicxml.Tick
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("upbow")) => musicxml.Upbow
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("salzedo")) => musicxml.Salzedo

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Breathu45marku45value] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: musicxml.Breathu45marku45value, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def buildMusicxml_Caesurau45valueFormat = new DefaultMusicxml_Caesurau45valueFormat {}
  trait DefaultMusicxml_Caesurau45valueFormat extends scalaxb.XMLFormat[musicxml.Caesurau45value] {
    val targetNamespace: Option[String] = None
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): musicxml.Caesurau45value =
        (fromString0(value, scope)).apply(scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, musicxml.Caesurau45value] = {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("normal")) => musicxml.NormalValue5
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("thick")) => musicxml.Thick
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("short")) => musicxml.ShortTypeValue2
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("curved")) => musicxml.CurvedValue2
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("single")) => musicxml.SingleValue4
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("")) => musicxml.BlankValue2

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Caesurau45value] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: musicxml.Caesurau45value, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def buildMusicxml_Circularu45arrowFormat = new DefaultMusicxml_Circularu45arrowFormat {}
  trait DefaultMusicxml_Circularu45arrowFormat extends scalaxb.XMLFormat[musicxml.Circularu45arrow] {
    val targetNamespace: Option[String] = None
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): musicxml.Circularu45arrow =
        (fromString0(value, scope)).apply(scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, musicxml.Circularu45arrow] = {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("clockwise")) => musicxml.Clockwise
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("anticlockwise")) => musicxml.Anticlockwise

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Circularu45arrow] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: musicxml.Circularu45arrow, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def buildMusicxml_FanFormat = new DefaultMusicxml_FanFormat {}
  trait DefaultMusicxml_FanFormat extends scalaxb.XMLFormat[musicxml.Fan] {
    val targetNamespace: Option[String] = None
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): musicxml.Fan =
        (fromString0(value, scope)).apply(scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, musicxml.Fan] = {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("accel")) => musicxml.Accel
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("rit")) => musicxml.Rit
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("none")) => musicxml.NoneTypeValue13

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Fan] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: musicxml.Fan, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def buildMusicxml_Handbellu45valueFormat = new DefaultMusicxml_Handbellu45valueFormat {}
  trait DefaultMusicxml_Handbellu45valueFormat extends scalaxb.XMLFormat[musicxml.Handbellu45value] {
    val targetNamespace: Option[String] = None
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): musicxml.Handbellu45value =
        (fromString0(value, scope)).apply(scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, musicxml.Handbellu45value] = {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("belltree")) => musicxml.Belltree
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("damp")) => musicxml.Damp
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("echo")) => musicxml.Echo
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("gyro")) => musicxml.Gyro
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("hand martellato")) => musicxml.Handmartellato
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("mallet lift")) => musicxml.Malletlift
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("mallet table")) => musicxml.Mallettable
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("martellato")) => musicxml.Martellato
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("martellato lift")) => musicxml.Martellatolift
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("muted martellato")) => musicxml.Mutedmartellato
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("pluck lift")) => musicxml.Plucklift
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("swing")) => musicxml.Swing

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Handbellu45value] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: musicxml.Handbellu45value, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def buildMusicxml_Harmonu45closedu45locationFormat = new DefaultMusicxml_Harmonu45closedu45locationFormat {}
  trait DefaultMusicxml_Harmonu45closedu45locationFormat extends scalaxb.XMLFormat[musicxml.Harmonu45closedu45location] {
    val targetNamespace: Option[String] = None
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): musicxml.Harmonu45closedu45location =
        (fromString0(value, scope)).apply(scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, musicxml.Harmonu45closedu45location] = {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("right")) => musicxml.RightTypeValue6
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("bottom")) => musicxml.BottomValue3
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("left")) => musicxml.LeftTypeValue6
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("top")) => musicxml.TopValue3

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Harmonu45closedu45location] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: musicxml.Harmonu45closedu45location, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def buildMusicxml_Harmonu45closedu45valueFormat = new DefaultMusicxml_Harmonu45closedu45valueFormat {}
  trait DefaultMusicxml_Harmonu45closedu45valueFormat extends scalaxb.XMLFormat[musicxml.Harmonu45closedu45value] {
    val targetNamespace: Option[String] = None
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): musicxml.Harmonu45closedu45value =
        (fromString0(value, scope)).apply(scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, musicxml.Harmonu45closedu45value] = {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("yes")) => musicxml.YesValue2
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("no")) => musicxml.NoValue2
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("half")) => musicxml.HalfValue

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Harmonu45closedu45value] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: musicxml.Harmonu45closedu45value, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def buildMusicxml_Holeu45closedu45locationFormat = new DefaultMusicxml_Holeu45closedu45locationFormat {}
  trait DefaultMusicxml_Holeu45closedu45locationFormat extends scalaxb.XMLFormat[musicxml.Holeu45closedu45location] {
    val targetNamespace: Option[String] = None
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): musicxml.Holeu45closedu45location =
        (fromString0(value, scope)).apply(scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, musicxml.Holeu45closedu45location] = {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("right")) => musicxml.RightTypeValue7
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("bottom")) => musicxml.BottomValue4
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("left")) => musicxml.LeftTypeValue7
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("top")) => musicxml.TopValue4

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Holeu45closedu45location] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: musicxml.Holeu45closedu45location, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def buildMusicxml_Holeu45closedu45valueFormat = new DefaultMusicxml_Holeu45closedu45valueFormat {}
  trait DefaultMusicxml_Holeu45closedu45valueFormat extends scalaxb.XMLFormat[musicxml.Holeu45closedu45value] {
    val targetNamespace: Option[String] = None
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): musicxml.Holeu45closedu45value =
        (fromString0(value, scope)).apply(scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, musicxml.Holeu45closedu45value] = {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("yes")) => musicxml.YesValue
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("no")) => musicxml.NoValue
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("half")) => musicxml.Half

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Holeu45closedu45value] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: musicxml.Holeu45closedu45value, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def buildMusicxml_Noteu45typeu45valueFormat = new DefaultMusicxml_Noteu45typeu45valueFormat {}
  trait DefaultMusicxml_Noteu45typeu45valueFormat extends scalaxb.XMLFormat[musicxml.Noteu45typeu45value] {
    val targetNamespace: Option[String] = None
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): musicxml.Noteu45typeu45value =
        (fromString0(value, scope)).apply(scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, musicxml.Noteu45typeu45value] = {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("1024th")) => musicxml.Number1024th
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("512th")) => musicxml.Number512th
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("256th")) => musicxml.Number256th
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("128th")) => musicxml.Number128th
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("64th")) => musicxml.Number64th
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("32nd")) => musicxml.Number32nd
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("16th")) => musicxml.Number16th
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("eighth")) => musicxml.Eighth
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("quarter")) => musicxml.Quarter
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("half")) => musicxml.HalfValue4
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("whole")) => musicxml.WholeValue2
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("breve")) => musicxml.Breve
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("long")) => musicxml.LongTypeValue
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("maxima")) => musicxml.Maxima

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Noteu45typeu45value] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: musicxml.Noteu45typeu45value, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def buildMusicxml_Noteheadu45valueFormat = new DefaultMusicxml_Noteheadu45valueFormat {}
  trait DefaultMusicxml_Noteheadu45valueFormat extends scalaxb.XMLFormat[musicxml.Noteheadu45value] {
    val targetNamespace: Option[String] = None
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): musicxml.Noteheadu45value =
        (fromString0(value, scope)).apply(scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, musicxml.Noteheadu45value] = {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("slash")) => musicxml.Slash
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("triangle")) => musicxml.Triangle
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("diamond")) => musicxml.Diamond
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("square")) => musicxml.SquareValue
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("cross")) => musicxml.Cross
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("x")) => musicxml.X
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("circle-x")) => musicxml.Circleu45x
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("inverted triangle")) => musicxml.Invertedtriangle
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("arrow down")) => musicxml.Arrowdown
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("arrow up")) => musicxml.Arrowup
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("circled")) => musicxml.Circled
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("slashed")) => musicxml.Slashed
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("back slashed")) => musicxml.Backslashed
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("normal")) => musicxml.Normal
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("cluster")) => musicxml.Cluster
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("circle dot")) => musicxml.Circledot
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("left triangle")) => musicxml.Lefttriangle
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("rectangle")) => musicxml.Rectangle
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("none")) => musicxml.NoneTypeValue2
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("do")) => musicxml.Do
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("re")) => musicxml.Re
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("mi")) => musicxml.Mi
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("fa")) => musicxml.Fa
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("fa up")) => musicxml.Faup
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("so")) => musicxml.So
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("la")) => musicxml.La
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("ti")) => musicxml.Ti
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("other")) => musicxml.Other

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Noteheadu45value] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: musicxml.Noteheadu45value, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def buildMusicxml_Showu45tupletFormat = new DefaultMusicxml_Showu45tupletFormat {}
  trait DefaultMusicxml_Showu45tupletFormat extends scalaxb.XMLFormat[musicxml.Showu45tuplet] {
    val targetNamespace: Option[String] = None
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): musicxml.Showu45tuplet =
        (fromString0(value, scope)).apply(scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, musicxml.Showu45tuplet] = {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("actual")) => musicxml.Actual
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("both")) => musicxml.BothValue2
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("none")) => musicxml.NoneTypeValue14

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Showu45tuplet] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: musicxml.Showu45tuplet, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def buildMusicxml_Stemu45valueFormat = new DefaultMusicxml_Stemu45valueFormat {}
  trait DefaultMusicxml_Stemu45valueFormat extends scalaxb.XMLFormat[musicxml.Stemu45value] {
    val targetNamespace: Option[String] = None
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): musicxml.Stemu45value =
        (fromString0(value, scope)).apply(scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, musicxml.Stemu45value] = {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("down")) => musicxml.Down
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("up")) => musicxml.Up
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("double")) => musicxml.DoubleType
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("none")) => musicxml.NoneTypeValue

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Stemu45value] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: musicxml.Stemu45value, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def buildMusicxml_StepFormat = new DefaultMusicxml_StepFormat {}
  trait DefaultMusicxml_StepFormat extends scalaxb.XMLFormat[musicxml.Step] {
    val targetNamespace: Option[String] = None
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): musicxml.Step =
        (fromString0(value, scope)).apply(scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, musicxml.Step] = {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("A")) => musicxml.A
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("B")) => musicxml.B
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("C")) => musicxml.CValue
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("D")) => musicxml.D
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("E")) => musicxml.E
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("F")) => musicxml.FValue
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("G")) => musicxml.GValue

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Step] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: musicxml.Step, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def buildMusicxml_SyllabicFormat = new DefaultMusicxml_SyllabicFormat {}
  trait DefaultMusicxml_SyllabicFormat extends scalaxb.XMLFormat[musicxml.Syllabic] {
    val targetNamespace: Option[String] = None
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): musicxml.Syllabic =
        (fromString0(value, scope)).apply(scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, musicxml.Syllabic] = {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("single")) => musicxml.Single
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("begin")) => musicxml.Begin
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("end")) => musicxml.End
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("middle")) => musicxml.Middle

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Syllabic] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: musicxml.Syllabic, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def buildMusicxml_Tapu45handFormat = new DefaultMusicxml_Tapu45handFormat {}
  trait DefaultMusicxml_Tapu45handFormat extends scalaxb.XMLFormat[musicxml.Tapu45hand] {
    val targetNamespace: Option[String] = None
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): musicxml.Tapu45hand =
        (fromString0(value, scope)).apply(scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, musicxml.Tapu45hand] = {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("left")) => musicxml.LeftTypeValue8
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("right")) => musicxml.RightTypeValue8

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Tapu45hand] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: musicxml.Tapu45hand, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def buildMusicxml_Groupu45barlineu45valueFormat = new DefaultMusicxml_Groupu45barlineu45valueFormat {}
  trait DefaultMusicxml_Groupu45barlineu45valueFormat extends scalaxb.XMLFormat[musicxml.Groupu45barlineu45value] {
    val targetNamespace: Option[String] = None
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): musicxml.Groupu45barlineu45value =
        (fromString0(value, scope)).apply(scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, musicxml.Groupu45barlineu45value] = {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("yes")) => musicxml.YesValue3
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("no")) => musicxml.NoValue3
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("Mensurstrich")) => musicxml.Mensurstrich

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Groupu45barlineu45value] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: musicxml.Groupu45barlineu45value, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def buildMusicxml_Groupu45symbolu45valueFormat = new DefaultMusicxml_Groupu45symbolu45valueFormat {}
  trait DefaultMusicxml_Groupu45symbolu45valueFormat extends scalaxb.XMLFormat[musicxml.Groupu45symbolu45value] {
    val targetNamespace: Option[String] = None
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): musicxml.Groupu45symbolu45value =
        (fromString0(value, scope)).apply(scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, musicxml.Groupu45symbolu45value] = {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("none")) => musicxml.NoneType
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("brace")) => musicxml.Brace
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("line")) => musicxml.Line
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("bracket")) => musicxml.BracketValue
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("square")) => musicxml.Square

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Groupu45symbolu45value] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: musicxml.Groupu45symbolu45value, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  trait DefaultMusicxml_Accidentalu45textFormat extends scalaxb.XMLFormat[musicxml.Accidentalu45text] with scalaxb.CanWriteChildNodes[musicxml.Accidentalu45text] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Accidentalu45text] = seq match {
      case node: scala.xml.Node => Right(musicxml.Accidentalu45text(scalaxb.fromXML[musicxml.Accidentalu45value](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@justify").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Leftu45centeru45right](x, scalaxb.ElemName(node) :: stack)) } map { "@justify" -> _ },
        (node \ "@default-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-x" -> _ },
        (node \ "@default-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-y" -> _ },
        (node \ "@relative-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-x" -> _ },
        (node \ "@relative-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-y" -> _ },
        (node \ "@font-family").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-family" -> _ },
        (node \ "@font-style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45style](x, scalaxb.ElemName(node) :: stack)) } map { "@font-style" -> _ },
        (node \ "@font-size").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-size" -> _ },
        (node \ "@font-weight").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45weight](x, scalaxb.ElemName(node) :: stack)) } map { "@font-weight" -> _ },
        (node \ "@color").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@color" -> _ },
        (node \ "@halign").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Leftu45centeru45right](x, scalaxb.ElemName(node) :: stack)) } map { "@halign" -> _ },
        (node \ "@valign").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Valign](x, scalaxb.ElemName(node) :: stack)) } map { "@valign" -> _ },
        (node \ "@underline").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigInt](x, scalaxb.ElemName(node) :: stack)) } map { "@underline" -> _ },
        (node \ "@overline").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigInt](x, scalaxb.ElemName(node) :: stack)) } map { "@overline" -> _ },
        (node \ "@line-through").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigInt](x, scalaxb.ElemName(node) :: stack)) } map { "@line-through" -> _ },
        (node \ "@rotation").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@rotation" -> _ },
        (node \ "@letter-spacing").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@letter-spacing" -> _ },
        (node \ "@line-height").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@line-height" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}lang").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}lang" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}space").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}space" -> _ },
        (node \ "@dir").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Textu45direction](x, scalaxb.ElemName(node) :: stack)) } map { "@dir" -> _ },
        (node \ "@enclosure").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Enclosureu45shape](x, scalaxb.ElemName(node) :: stack)) } map { "@enclosure" -> _ },
        (node \ "@smufl").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@smufl" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Accidentalu45text, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@justify", _) => __obj.justify foreach { x => attr = scala.xml.Attribute(null, "justify", x.toString, attr) }
        case ("@default-x", _) => __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.bigDecimal.toPlainString, attr) }
        case ("@default-y", _) => __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.bigDecimal.toPlainString, attr) }
        case ("@relative-x", _) => __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.bigDecimal.toPlainString, attr) }
        case ("@relative-y", _) => __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.bigDecimal.toPlainString, attr) }
        case ("@font-family", _) => __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
        case ("@font-style", _) => __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
        case ("@font-size", _) => __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
        case ("@font-weight", _) => __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
        case ("@color", _) => __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
        case ("@halign", _) => __obj.halign foreach { x => attr = scala.xml.Attribute(null, "halign", x.toString, attr) }
        case ("@valign", _) => __obj.valign foreach { x => attr = scala.xml.Attribute(null, "valign", x.toString, attr) }
        case ("@underline", _) => __obj.underline foreach { x => attr = scala.xml.Attribute(null, "underline", x.toString, attr) }
        case ("@overline", _) => __obj.overline foreach { x => attr = scala.xml.Attribute(null, "overline", x.toString, attr) }
        case ("@line-through", _) => __obj.lineu45through foreach { x => attr = scala.xml.Attribute(null, "line-through", x.toString, attr) }
        case ("@rotation", _) => __obj.rotation foreach { x => attr = scala.xml.Attribute(null, "rotation", x.bigDecimal.toPlainString, attr) }
        case ("@letter-spacing", _) => __obj.letteru45spacing foreach { x => attr = scala.xml.Attribute(null, "letter-spacing", x.toString, attr) }
        case ("@line-height", _) => __obj.lineu45height foreach { x => attr = scala.xml.Attribute(null, "line-height", x.toString, attr) }
        case ("@{http://www.w3.org/XML/1998/namespace}lang", _) => __obj.xmllang foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", x.toString, attr) }
        case ("@{http://www.w3.org/XML/1998/namespace}space", _) => __obj.xmlspace foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "space", x.toString, attr) }
        case ("@dir", _) => __obj.dir foreach { x => attr = scala.xml.Attribute(null, "dir", x.toString, attr) }
        case ("@enclosure", _) => __obj.enclosure foreach { x => attr = scala.xml.Attribute(null, "enclosure", x.toString, attr) }
        case ("@smufl", _) => __obj.smufl foreach { x => attr = scala.xml.Attribute(null, "smufl", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Accidentalu45text, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultMusicxml_CodaFormat extends scalaxb.XMLFormat[musicxml.Coda] with scalaxb.CanWriteChildNodes[musicxml.Coda] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Coda] = seq match {
      case node: scala.xml.Node => Right(musicxml.Coda(scala.collection.immutable.ListMap(List(
        (node \ "@default-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-x" -> _ },
        (node \ "@default-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-y" -> _ },
        (node \ "@relative-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-x" -> _ },
        (node \ "@relative-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-y" -> _ },
        (node \ "@font-family").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-family" -> _ },
        (node \ "@font-style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45style](x, scalaxb.ElemName(node) :: stack)) } map { "@font-style" -> _ },
        (node \ "@font-size").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-size" -> _ },
        (node \ "@font-weight").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45weight](x, scalaxb.ElemName(node) :: stack)) } map { "@font-weight" -> _ },
        (node \ "@color").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@color" -> _ },
        (node \ "@halign").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Leftu45centeru45right](x, scalaxb.ElemName(node) :: stack)) } map { "@halign" -> _ },
        (node \ "@valign").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Valign](x, scalaxb.ElemName(node) :: stack)) } map { "@valign" -> _ },
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@smufl").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@smufl" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Coda, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@default-x", _) => __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.bigDecimal.toPlainString, attr) }
        case ("@default-y", _) => __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.bigDecimal.toPlainString, attr) }
        case ("@relative-x", _) => __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.bigDecimal.toPlainString, attr) }
        case ("@relative-y", _) => __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.bigDecimal.toPlainString, attr) }
        case ("@font-family", _) => __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
        case ("@font-style", _) => __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
        case ("@font-size", _) => __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
        case ("@font-weight", _) => __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
        case ("@color", _) => __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
        case ("@halign", _) => __obj.halign foreach { x => attr = scala.xml.Attribute(null, "halign", x.toString, attr) }
        case ("@valign", _) => __obj.valign foreach { x => attr = scala.xml.Attribute(null, "valign", x.toString, attr) }
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@smufl", _) => __obj.smufl foreach { x => attr = scala.xml.Attribute(null, "smufl", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Coda, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil

  }

  trait DefaultMusicxml_DynamicsFormat extends scalaxb.ElemNameParser[musicxml.Dynamics] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("dynamics")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[musicxml.Dynamics] =
      phrase(safeRep(((scalaxb.ElemName(None, "p")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Empty](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "pp")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Empty](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "ppp")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Empty](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "pppp")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Empty](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "ppppp")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Empty](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "pppppp")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Empty](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "f")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Empty](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "ff")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Empty](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "fff")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Empty](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "ffff")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Empty](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "fffff")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Empty](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "ffffff")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Empty](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "mp")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Empty](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "mf")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Empty](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "sf")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Empty](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "sfp")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Empty](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "sfpp")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Empty](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "fp")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Empty](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "rf")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Empty](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "rfz")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Empty](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "sfz")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Empty](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "sffz")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Empty](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "fz")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Empty](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "n")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Empty](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "pf")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Empty](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "sfzp")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Empty](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "other-dynamics")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Otheru45text](x, scalaxb.ElemName(node) :: stack))))) ^^
      { case p1 =>
      musicxml.Dynamics(p1,
        scala.collection.immutable.ListMap(List(
        (node \ "@default-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-x" -> _ },
        (node \ "@default-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-y" -> _ },
        (node \ "@relative-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-x" -> _ },
        (node \ "@relative-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-y" -> _ },
        (node \ "@font-family").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-family" -> _ },
        (node \ "@font-style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45style](x, scalaxb.ElemName(node) :: stack)) } map { "@font-style" -> _ },
        (node \ "@font-size").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-size" -> _ },
        (node \ "@font-weight").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45weight](x, scalaxb.ElemName(node) :: stack)) } map { "@font-weight" -> _ },
        (node \ "@color").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@color" -> _ },
        (node \ "@halign").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Leftu45centeru45right](x, scalaxb.ElemName(node) :: stack)) } map { "@halign" -> _ },
        (node \ "@valign").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Valign](x, scalaxb.ElemName(node) :: stack)) } map { "@valign" -> _ },
        (node \ "@placement").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Aboveu45below](x, scalaxb.ElemName(node) :: stack)) } map { "@placement" -> _ },
        (node \ "@underline").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigInt](x, scalaxb.ElemName(node) :: stack)) } map { "@underline" -> _ },
        (node \ "@overline").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigInt](x, scalaxb.ElemName(node) :: stack)) } map { "@overline" -> _ },
        (node \ "@line-through").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigInt](x, scalaxb.ElemName(node) :: stack)) } map { "@line-through" -> _ },
        (node \ "@enclosure").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Enclosureu45shape](x, scalaxb.ElemName(node) :: stack)) } map { "@enclosure" -> _ },
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: musicxml.Dynamics, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@default-x", _) => __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.bigDecimal.toPlainString, attr) }
        case ("@default-y", _) => __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.bigDecimal.toPlainString, attr) }
        case ("@relative-x", _) => __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.bigDecimal.toPlainString, attr) }
        case ("@relative-y", _) => __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.bigDecimal.toPlainString, attr) }
        case ("@font-family", _) => __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
        case ("@font-style", _) => __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
        case ("@font-size", _) => __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
        case ("@font-weight", _) => __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
        case ("@color", _) => __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
        case ("@halign", _) => __obj.halign foreach { x => attr = scala.xml.Attribute(null, "halign", x.toString, attr) }
        case ("@valign", _) => __obj.valign foreach { x => attr = scala.xml.Attribute(null, "valign", x.toString, attr) }
        case ("@placement", _) => __obj.placement foreach { x => attr = scala.xml.Attribute(null, "placement", x.toString, attr) }
        case ("@underline", _) => __obj.underline foreach { x => attr = scala.xml.Attribute(null, "underline", x.toString, attr) }
        case ("@overline", _) => __obj.overline foreach { x => attr = scala.xml.Attribute(null, "overline", x.toString, attr) }
        case ("@line-through", _) => __obj.lineu45through foreach { x => attr = scala.xml.Attribute(null, "line-through", x.toString, attr) }
        case ("@enclosure", _) => __obj.enclosure foreach { x => attr = scala.xml.Attribute(null, "enclosure", x.toString, attr) }
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Dynamics, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.dynamicsoption flatMap { x => scalaxb.toXML[scalaxb.DataRecord[musicxml.DynamicsOption]](x, x.namespace, x.key, __scope, false) })
  }

  trait DefaultMusicxml_EmptyFormat extends scalaxb.XMLFormat[musicxml.Empty] with scalaxb.CanWriteChildNodes[musicxml.Empty] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Empty] = seq match {
      case node: scala.xml.Node => Right(musicxml.Empty())
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def writesChildNodes(__obj: musicxml.Empty, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil

  }
  trait DefaultMusicxml_Emptyu45placementableFormat extends scalaxb.XMLFormat[musicxml.Emptyu45placementable] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Emptyu45placementable] = seq match {
      case node: scala.xml.Node =>     
        scalaxb.Helper.instanceType(node) match {
          case (None, Some("heel-toe")) => Right(scalaxb.fromXML[musicxml.Heelu45toe](node, stack))
          case (None, Some("strong-accent")) => Right(scalaxb.fromXML[musicxml.Strongu45accent](node, stack))
          case _ => Right(scalaxb.fromXML[musicxml.Emptyu45placement](node, stack))
        }
      case _ => Left("reads failed: seq must be scala.xml.Node")  
    }
    
    def writes(__obj: musicxml.Emptyu45placementable, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq = __obj match {
      case x: musicxml.Heelu45toe => scalaxb.toXML[musicxml.Heelu45toe](x, __namespace, __elementLabel, __scope, true)
      case x: musicxml.Strongu45accent => scalaxb.toXML[musicxml.Strongu45accent](x, __namespace, __elementLabel, __scope, true)
      case x: musicxml.Emptyu45placement => scalaxb.toXML[musicxml.Emptyu45placement](x, __namespace, __elementLabel, __scope, __typeAttribute)
    }
  }

  trait DefaultMusicxml_Emptyu45placementFormat extends scalaxb.XMLFormat[musicxml.Emptyu45placement] with scalaxb.CanWriteChildNodes[musicxml.Emptyu45placement] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Emptyu45placement] = seq match {
      case node: scala.xml.Node => Right(musicxml.Emptyu45placement(scala.collection.immutable.ListMap(List(
        (node \ "@default-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-x" -> _ },
        (node \ "@default-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-y" -> _ },
        (node \ "@relative-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-x" -> _ },
        (node \ "@relative-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-y" -> _ },
        (node \ "@font-family").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-family" -> _ },
        (node \ "@font-style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45style](x, scalaxb.ElemName(node) :: stack)) } map { "@font-style" -> _ },
        (node \ "@font-size").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-size" -> _ },
        (node \ "@font-weight").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45weight](x, scalaxb.ElemName(node) :: stack)) } map { "@font-weight" -> _ },
        (node \ "@color").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@color" -> _ },
        (node \ "@placement").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Aboveu45below](x, scalaxb.ElemName(node) :: stack)) } map { "@placement" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Emptyu45placement, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@default-x", _) => __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.bigDecimal.toPlainString, attr) }
        case ("@default-y", _) => __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.bigDecimal.toPlainString, attr) }
        case ("@relative-x", _) => __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.bigDecimal.toPlainString, attr) }
        case ("@relative-y", _) => __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.bigDecimal.toPlainString, attr) }
        case ("@font-family", _) => __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
        case ("@font-style", _) => __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
        case ("@font-size", _) => __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
        case ("@font-weight", _) => __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
        case ("@color", _) => __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
        case ("@placement", _) => __obj.placement foreach { x => attr = scala.xml.Attribute(null, "placement", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Emptyu45placement, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil

  }

  trait DefaultMusicxml_Emptyu45placementu45smuflFormat extends scalaxb.XMLFormat[musicxml.Emptyu45placementu45smufl] with scalaxb.CanWriteChildNodes[musicxml.Emptyu45placementu45smufl] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Emptyu45placementu45smufl] = seq match {
      case node: scala.xml.Node => Right(musicxml.Emptyu45placementu45smufl(scala.collection.immutable.ListMap(List(
        (node \ "@default-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-x" -> _ },
        (node \ "@default-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-y" -> _ },
        (node \ "@relative-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-x" -> _ },
        (node \ "@relative-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-y" -> _ },
        (node \ "@font-family").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-family" -> _ },
        (node \ "@font-style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45style](x, scalaxb.ElemName(node) :: stack)) } map { "@font-style" -> _ },
        (node \ "@font-size").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-size" -> _ },
        (node \ "@font-weight").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45weight](x, scalaxb.ElemName(node) :: stack)) } map { "@font-weight" -> _ },
        (node \ "@color").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@color" -> _ },
        (node \ "@placement").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Aboveu45below](x, scalaxb.ElemName(node) :: stack)) } map { "@placement" -> _ },
        (node \ "@smufl").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@smufl" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Emptyu45placementu45smufl, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@default-x", _) => __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.bigDecimal.toPlainString, attr) }
        case ("@default-y", _) => __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.bigDecimal.toPlainString, attr) }
        case ("@relative-x", _) => __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.bigDecimal.toPlainString, attr) }
        case ("@relative-y", _) => __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.bigDecimal.toPlainString, attr) }
        case ("@font-family", _) => __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
        case ("@font-style", _) => __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
        case ("@font-size", _) => __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
        case ("@font-weight", _) => __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
        case ("@color", _) => __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
        case ("@placement", _) => __obj.placement foreach { x => attr = scala.xml.Attribute(null, "placement", x.toString, attr) }
        case ("@smufl", _) => __obj.smufl foreach { x => attr = scala.xml.Attribute(null, "smufl", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Emptyu45placementu45smufl, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil

  }

  trait DefaultMusicxml_Emptyu45printu45styleFormat extends scalaxb.XMLFormat[musicxml.Emptyu45printu45style] with scalaxb.CanWriteChildNodes[musicxml.Emptyu45printu45style] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Emptyu45printu45style] = seq match {
      case node: scala.xml.Node => Right(musicxml.Emptyu45printu45style(scala.collection.immutable.ListMap(List(
        (node \ "@default-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-x" -> _ },
        (node \ "@default-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-y" -> _ },
        (node \ "@relative-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-x" -> _ },
        (node \ "@relative-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-y" -> _ },
        (node \ "@font-family").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-family" -> _ },
        (node \ "@font-style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45style](x, scalaxb.ElemName(node) :: stack)) } map { "@font-style" -> _ },
        (node \ "@font-size").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-size" -> _ },
        (node \ "@font-weight").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45weight](x, scalaxb.ElemName(node) :: stack)) } map { "@font-weight" -> _ },
        (node \ "@color").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@color" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Emptyu45printu45style, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@default-x", _) => __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.bigDecimal.toPlainString, attr) }
        case ("@default-y", _) => __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.bigDecimal.toPlainString, attr) }
        case ("@relative-x", _) => __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.bigDecimal.toPlainString, attr) }
        case ("@relative-y", _) => __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.bigDecimal.toPlainString, attr) }
        case ("@font-family", _) => __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
        case ("@font-style", _) => __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
        case ("@font-size", _) => __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
        case ("@font-weight", _) => __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
        case ("@color", _) => __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Emptyu45printu45style, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil

  }

  trait DefaultMusicxml_Emptyu45printu45styleu45alignFormat extends scalaxb.XMLFormat[musicxml.Emptyu45printu45styleu45align] with scalaxb.CanWriteChildNodes[musicxml.Emptyu45printu45styleu45align] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Emptyu45printu45styleu45align] = seq match {
      case node: scala.xml.Node => Right(musicxml.Emptyu45printu45styleu45align(scala.collection.immutable.ListMap(List(
        (node \ "@default-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-x" -> _ },
        (node \ "@default-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-y" -> _ },
        (node \ "@relative-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-x" -> _ },
        (node \ "@relative-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-y" -> _ },
        (node \ "@font-family").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-family" -> _ },
        (node \ "@font-style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45style](x, scalaxb.ElemName(node) :: stack)) } map { "@font-style" -> _ },
        (node \ "@font-size").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-size" -> _ },
        (node \ "@font-weight").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45weight](x, scalaxb.ElemName(node) :: stack)) } map { "@font-weight" -> _ },
        (node \ "@color").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@color" -> _ },
        (node \ "@halign").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Leftu45centeru45right](x, scalaxb.ElemName(node) :: stack)) } map { "@halign" -> _ },
        (node \ "@valign").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Valign](x, scalaxb.ElemName(node) :: stack)) } map { "@valign" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Emptyu45printu45styleu45align, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@default-x", _) => __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.bigDecimal.toPlainString, attr) }
        case ("@default-y", _) => __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.bigDecimal.toPlainString, attr) }
        case ("@relative-x", _) => __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.bigDecimal.toPlainString, attr) }
        case ("@relative-y", _) => __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.bigDecimal.toPlainString, attr) }
        case ("@font-family", _) => __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
        case ("@font-style", _) => __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
        case ("@font-size", _) => __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
        case ("@font-weight", _) => __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
        case ("@color", _) => __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
        case ("@halign", _) => __obj.halign foreach { x => attr = scala.xml.Attribute(null, "halign", x.toString, attr) }
        case ("@valign", _) => __obj.valign foreach { x => attr = scala.xml.Attribute(null, "valign", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Emptyu45printu45styleu45align, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil

  }

  trait DefaultMusicxml_Emptyu45printu45styleu45alignu45idFormat extends scalaxb.XMLFormat[musicxml.Emptyu45printu45styleu45alignu45id] with scalaxb.CanWriteChildNodes[musicxml.Emptyu45printu45styleu45alignu45id] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Emptyu45printu45styleu45alignu45id] = seq match {
      case node: scala.xml.Node => Right(musicxml.Emptyu45printu45styleu45alignu45id(scala.collection.immutable.ListMap(List(
        (node \ "@default-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-x" -> _ },
        (node \ "@default-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-y" -> _ },
        (node \ "@relative-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-x" -> _ },
        (node \ "@relative-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-y" -> _ },
        (node \ "@font-family").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-family" -> _ },
        (node \ "@font-style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45style](x, scalaxb.ElemName(node) :: stack)) } map { "@font-style" -> _ },
        (node \ "@font-size").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-size" -> _ },
        (node \ "@font-weight").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45weight](x, scalaxb.ElemName(node) :: stack)) } map { "@font-weight" -> _ },
        (node \ "@color").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@color" -> _ },
        (node \ "@halign").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Leftu45centeru45right](x, scalaxb.ElemName(node) :: stack)) } map { "@halign" -> _ },
        (node \ "@valign").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Valign](x, scalaxb.ElemName(node) :: stack)) } map { "@valign" -> _ },
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Emptyu45printu45styleu45alignu45id, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@default-x", _) => __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.bigDecimal.toPlainString, attr) }
        case ("@default-y", _) => __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.bigDecimal.toPlainString, attr) }
        case ("@relative-x", _) => __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.bigDecimal.toPlainString, attr) }
        case ("@relative-y", _) => __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.bigDecimal.toPlainString, attr) }
        case ("@font-family", _) => __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
        case ("@font-style", _) => __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
        case ("@font-size", _) => __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
        case ("@font-weight", _) => __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
        case ("@color", _) => __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
        case ("@halign", _) => __obj.halign foreach { x => attr = scala.xml.Attribute(null, "halign", x.toString, attr) }
        case ("@valign", _) => __obj.valign foreach { x => attr = scala.xml.Attribute(null, "valign", x.toString, attr) }
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Emptyu45printu45styleu45alignu45id, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil

  }

  trait DefaultMusicxml_Emptyu45printu45objectu45styleu45alignFormat extends scalaxb.XMLFormat[musicxml.Emptyu45printu45objectu45styleu45align] with scalaxb.CanWriteChildNodes[musicxml.Emptyu45printu45objectu45styleu45align] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Emptyu45printu45objectu45styleu45align] = seq match {
      case node: scala.xml.Node => Right(musicxml.Emptyu45printu45objectu45styleu45align(scala.collection.immutable.ListMap(List(
        (node \ "@print-object").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Yesu45no](x, scalaxb.ElemName(node) :: stack)) } map { "@print-object" -> _ },
        (node \ "@default-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-x" -> _ },
        (node \ "@default-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-y" -> _ },
        (node \ "@relative-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-x" -> _ },
        (node \ "@relative-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-y" -> _ },
        (node \ "@font-family").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-family" -> _ },
        (node \ "@font-style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45style](x, scalaxb.ElemName(node) :: stack)) } map { "@font-style" -> _ },
        (node \ "@font-size").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-size" -> _ },
        (node \ "@font-weight").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45weight](x, scalaxb.ElemName(node) :: stack)) } map { "@font-weight" -> _ },
        (node \ "@color").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@color" -> _ },
        (node \ "@halign").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Leftu45centeru45right](x, scalaxb.ElemName(node) :: stack)) } map { "@halign" -> _ },
        (node \ "@valign").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Valign](x, scalaxb.ElemName(node) :: stack)) } map { "@valign" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Emptyu45printu45objectu45styleu45align, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@print-object", _) => __obj.printu45object foreach { x => attr = scala.xml.Attribute(null, "print-object", x.toString, attr) }
        case ("@default-x", _) => __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.bigDecimal.toPlainString, attr) }
        case ("@default-y", _) => __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.bigDecimal.toPlainString, attr) }
        case ("@relative-x", _) => __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.bigDecimal.toPlainString, attr) }
        case ("@relative-y", _) => __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.bigDecimal.toPlainString, attr) }
        case ("@font-family", _) => __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
        case ("@font-style", _) => __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
        case ("@font-size", _) => __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
        case ("@font-weight", _) => __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
        case ("@color", _) => __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
        case ("@halign", _) => __obj.halign foreach { x => attr = scala.xml.Attribute(null, "halign", x.toString, attr) }
        case ("@valign", _) => __obj.valign foreach { x => attr = scala.xml.Attribute(null, "valign", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Emptyu45printu45objectu45styleu45align, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil

  }

  trait DefaultMusicxml_Emptyu45trillu45soundableFormat extends scalaxb.XMLFormat[musicxml.Emptyu45trillu45soundable] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Emptyu45trillu45soundable] = seq match {
      case node: scala.xml.Node =>     
        scalaxb.Helper.instanceType(node) match {
          case (None, Some("mordent")) => Right(scalaxb.fromXML[musicxml.Mordent](node, stack))
          case _ => Right(scalaxb.fromXML[musicxml.Emptyu45trillu45sound](node, stack))
        }
      case _ => Left("reads failed: seq must be scala.xml.Node")  
    }
    
    def writes(__obj: musicxml.Emptyu45trillu45soundable, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq = __obj match {
      case x: musicxml.Mordent => scalaxb.toXML[musicxml.Mordent](x, __namespace, __elementLabel, __scope, true)
      case x: musicxml.Emptyu45trillu45sound => scalaxb.toXML[musicxml.Emptyu45trillu45sound](x, __namespace, __elementLabel, __scope, __typeAttribute)
    }
  }
  trait DefaultMusicxml_Emptyu45trillu45soundFormat extends scalaxb.XMLFormat[musicxml.Emptyu45trillu45sound] with scalaxb.CanWriteChildNodes[musicxml.Emptyu45trillu45sound] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Emptyu45trillu45sound] = seq match {
      case node: scala.xml.Node => Right(musicxml.Emptyu45trillu45sound(scala.collection.immutable.ListMap(List(
        (node \ "@default-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-x" -> _ },
        (node \ "@default-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-y" -> _ },
        (node \ "@relative-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-x" -> _ },
        (node \ "@relative-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-y" -> _ },
        (node \ "@font-family").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-family" -> _ },
        (node \ "@font-style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45style](x, scalaxb.ElemName(node) :: stack)) } map { "@font-style" -> _ },
        (node \ "@font-size").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-size" -> _ },
        (node \ "@font-weight").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45weight](x, scalaxb.ElemName(node) :: stack)) } map { "@font-weight" -> _ },
        (node \ "@color").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@color" -> _ },
        (node \ "@placement").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Aboveu45below](x, scalaxb.ElemName(node) :: stack)) } map { "@placement" -> _ },
        (node \ "@start-note").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Startu45note](x, scalaxb.ElemName(node) :: stack)) } map { "@start-note" -> _ },
        (node \ "@trill-step").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Trillu45step](x, scalaxb.ElemName(node) :: stack)) } map { "@trill-step" -> _ },
        (node \ "@two-note-turn").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Twou45noteu45turn](x, scalaxb.ElemName(node) :: stack)) } map { "@two-note-turn" -> _ },
        (node \ "@accelerate").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Yesu45no](x, scalaxb.ElemName(node) :: stack)) } map { "@accelerate" -> _ },
        (node \ "@beats").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@beats" -> _ },
        (node \ "@second-beat").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@second-beat" -> _ },
        (node \ "@last-beat").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@last-beat" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Emptyu45trillu45sound, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@default-x", _) => __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.bigDecimal.toPlainString, attr) }
        case ("@default-y", _) => __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.bigDecimal.toPlainString, attr) }
        case ("@relative-x", _) => __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.bigDecimal.toPlainString, attr) }
        case ("@relative-y", _) => __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.bigDecimal.toPlainString, attr) }
        case ("@font-family", _) => __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
        case ("@font-style", _) => __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
        case ("@font-size", _) => __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
        case ("@font-weight", _) => __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
        case ("@color", _) => __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
        case ("@placement", _) => __obj.placement foreach { x => attr = scala.xml.Attribute(null, "placement", x.toString, attr) }
        case ("@start-note", _) => __obj.startu45note foreach { x => attr = scala.xml.Attribute(null, "start-note", x.toString, attr) }
        case ("@trill-step", _) => __obj.trillu45step foreach { x => attr = scala.xml.Attribute(null, "trill-step", x.toString, attr) }
        case ("@two-note-turn", _) => __obj.twou45noteu45turn foreach { x => attr = scala.xml.Attribute(null, "two-note-turn", x.toString, attr) }
        case ("@accelerate", _) => __obj.accelerate foreach { x => attr = scala.xml.Attribute(null, "accelerate", x.toString, attr) }
        case ("@beats", _) => __obj.beats foreach { x => attr = scala.xml.Attribute(null, "beats", x.bigDecimal.toPlainString, attr) }
        case ("@second-beat", _) => __obj.secondu45beat foreach { x => attr = scala.xml.Attribute(null, "second-beat", x.bigDecimal.toPlainString, attr) }
        case ("@last-beat", _) => __obj.lastu45beat foreach { x => attr = scala.xml.Attribute(null, "last-beat", x.bigDecimal.toPlainString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Emptyu45trillu45sound, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil

  }

  trait DefaultMusicxml_Horizontalu45turnFormat extends scalaxb.XMLFormat[musicxml.Horizontalu45turn] with scalaxb.CanWriteChildNodes[musicxml.Horizontalu45turn] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Horizontalu45turn] = seq match {
      case node: scala.xml.Node => Right(musicxml.Horizontalu45turn(scala.collection.immutable.ListMap(List(
        (node \ "@default-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-x" -> _ },
        (node \ "@default-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-y" -> _ },
        (node \ "@relative-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-x" -> _ },
        (node \ "@relative-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-y" -> _ },
        (node \ "@font-family").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-family" -> _ },
        (node \ "@font-style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45style](x, scalaxb.ElemName(node) :: stack)) } map { "@font-style" -> _ },
        (node \ "@font-size").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-size" -> _ },
        (node \ "@font-weight").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45weight](x, scalaxb.ElemName(node) :: stack)) } map { "@font-weight" -> _ },
        (node \ "@color").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@color" -> _ },
        (node \ "@placement").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Aboveu45below](x, scalaxb.ElemName(node) :: stack)) } map { "@placement" -> _ },
        (node \ "@start-note").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Startu45note](x, scalaxb.ElemName(node) :: stack)) } map { "@start-note" -> _ },
        (node \ "@trill-step").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Trillu45step](x, scalaxb.ElemName(node) :: stack)) } map { "@trill-step" -> _ },
        (node \ "@two-note-turn").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Twou45noteu45turn](x, scalaxb.ElemName(node) :: stack)) } map { "@two-note-turn" -> _ },
        (node \ "@accelerate").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Yesu45no](x, scalaxb.ElemName(node) :: stack)) } map { "@accelerate" -> _ },
        (node \ "@beats").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@beats" -> _ },
        (node \ "@second-beat").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@second-beat" -> _ },
        (node \ "@last-beat").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@last-beat" -> _ },
        (node \ "@slash").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Yesu45no](x, scalaxb.ElemName(node) :: stack)) } map { "@slash" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Horizontalu45turn, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@default-x", _) => __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.bigDecimal.toPlainString, attr) }
        case ("@default-y", _) => __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.bigDecimal.toPlainString, attr) }
        case ("@relative-x", _) => __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.bigDecimal.toPlainString, attr) }
        case ("@relative-y", _) => __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.bigDecimal.toPlainString, attr) }
        case ("@font-family", _) => __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
        case ("@font-style", _) => __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
        case ("@font-size", _) => __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
        case ("@font-weight", _) => __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
        case ("@color", _) => __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
        case ("@placement", _) => __obj.placement foreach { x => attr = scala.xml.Attribute(null, "placement", x.toString, attr) }
        case ("@start-note", _) => __obj.startu45note foreach { x => attr = scala.xml.Attribute(null, "start-note", x.toString, attr) }
        case ("@trill-step", _) => __obj.trillu45step foreach { x => attr = scala.xml.Attribute(null, "trill-step", x.toString, attr) }
        case ("@two-note-turn", _) => __obj.twou45noteu45turn foreach { x => attr = scala.xml.Attribute(null, "two-note-turn", x.toString, attr) }
        case ("@accelerate", _) => __obj.accelerate foreach { x => attr = scala.xml.Attribute(null, "accelerate", x.toString, attr) }
        case ("@beats", _) => __obj.beats foreach { x => attr = scala.xml.Attribute(null, "beats", x.bigDecimal.toPlainString, attr) }
        case ("@second-beat", _) => __obj.secondu45beat foreach { x => attr = scala.xml.Attribute(null, "second-beat", x.bigDecimal.toPlainString, attr) }
        case ("@last-beat", _) => __obj.lastu45beat foreach { x => attr = scala.xml.Attribute(null, "last-beat", x.bigDecimal.toPlainString, attr) }
        case ("@slash", _) => __obj.slash foreach { x => attr = scala.xml.Attribute(null, "slash", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Horizontalu45turn, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil

  }

  trait DefaultMusicxml_FermataFormat extends scalaxb.XMLFormat[musicxml.Fermata] with scalaxb.CanWriteChildNodes[musicxml.Fermata] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Fermata] = seq match {
      case node: scala.xml.Node => Right(musicxml.Fermata(scalaxb.fromXML[musicxml.Fermatau45shape](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Uprightu45inverted](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ },
        (node \ "@default-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-x" -> _ },
        (node \ "@default-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-y" -> _ },
        (node \ "@relative-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-x" -> _ },
        (node \ "@relative-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-y" -> _ },
        (node \ "@font-family").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-family" -> _ },
        (node \ "@font-style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45style](x, scalaxb.ElemName(node) :: stack)) } map { "@font-style" -> _ },
        (node \ "@font-size").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-size" -> _ },
        (node \ "@font-weight").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45weight](x, scalaxb.ElemName(node) :: stack)) } map { "@font-weight" -> _ },
        (node \ "@color").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@color" -> _ },
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Fermata, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => __obj.typeValue foreach { x => attr = scala.xml.Attribute(null, "type", x.toString, attr) }
        case ("@default-x", _) => __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.bigDecimal.toPlainString, attr) }
        case ("@default-y", _) => __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.bigDecimal.toPlainString, attr) }
        case ("@relative-x", _) => __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.bigDecimal.toPlainString, attr) }
        case ("@relative-y", _) => __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.bigDecimal.toPlainString, attr) }
        case ("@font-family", _) => __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
        case ("@font-style", _) => __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
        case ("@font-size", _) => __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
        case ("@font-weight", _) => __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
        case ("@color", _) => __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Fermata, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultMusicxml_FingeringFormat extends scalaxb.XMLFormat[musicxml.Fingering] with scalaxb.CanWriteChildNodes[musicxml.Fingering] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Fingering] = seq match {
      case node: scala.xml.Node => Right(musicxml.Fingering(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@substitution").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Yesu45no](x, scalaxb.ElemName(node) :: stack)) } map { "@substitution" -> _ },
        (node \ "@alternate").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Yesu45no](x, scalaxb.ElemName(node) :: stack)) } map { "@alternate" -> _ },
        (node \ "@default-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-x" -> _ },
        (node \ "@default-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-y" -> _ },
        (node \ "@relative-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-x" -> _ },
        (node \ "@relative-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-y" -> _ },
        (node \ "@font-family").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-family" -> _ },
        (node \ "@font-style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45style](x, scalaxb.ElemName(node) :: stack)) } map { "@font-style" -> _ },
        (node \ "@font-size").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-size" -> _ },
        (node \ "@font-weight").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45weight](x, scalaxb.ElemName(node) :: stack)) } map { "@font-weight" -> _ },
        (node \ "@color").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@color" -> _ },
        (node \ "@placement").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Aboveu45below](x, scalaxb.ElemName(node) :: stack)) } map { "@placement" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Fingering, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@substitution", _) => __obj.substitution foreach { x => attr = scala.xml.Attribute(null, "substitution", x.toString, attr) }
        case ("@alternate", _) => __obj.alternate foreach { x => attr = scala.xml.Attribute(null, "alternate", x.toString, attr) }
        case ("@default-x", _) => __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.bigDecimal.toPlainString, attr) }
        case ("@default-y", _) => __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.bigDecimal.toPlainString, attr) }
        case ("@relative-x", _) => __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.bigDecimal.toPlainString, attr) }
        case ("@relative-y", _) => __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.bigDecimal.toPlainString, attr) }
        case ("@font-family", _) => __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
        case ("@font-style", _) => __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
        case ("@font-size", _) => __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
        case ("@font-weight", _) => __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
        case ("@color", _) => __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
        case ("@placement", _) => __obj.placement foreach { x => attr = scala.xml.Attribute(null, "placement", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Fingering, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultMusicxml_Formattedu45symbolFormat extends scalaxb.XMLFormat[musicxml.Formattedu45symbol] with scalaxb.CanWriteChildNodes[musicxml.Formattedu45symbol] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Formattedu45symbol] = seq match {
      case node: scala.xml.Node => Right(musicxml.Formattedu45symbol(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@justify").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Leftu45centeru45right](x, scalaxb.ElemName(node) :: stack)) } map { "@justify" -> _ },
        (node \ "@default-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-x" -> _ },
        (node \ "@default-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-y" -> _ },
        (node \ "@relative-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-x" -> _ },
        (node \ "@relative-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-y" -> _ },
        (node \ "@font-family").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-family" -> _ },
        (node \ "@font-style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45style](x, scalaxb.ElemName(node) :: stack)) } map { "@font-style" -> _ },
        (node \ "@font-size").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-size" -> _ },
        (node \ "@font-weight").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45weight](x, scalaxb.ElemName(node) :: stack)) } map { "@font-weight" -> _ },
        (node \ "@color").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@color" -> _ },
        (node \ "@halign").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Leftu45centeru45right](x, scalaxb.ElemName(node) :: stack)) } map { "@halign" -> _ },
        (node \ "@valign").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Valign](x, scalaxb.ElemName(node) :: stack)) } map { "@valign" -> _ },
        (node \ "@underline").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigInt](x, scalaxb.ElemName(node) :: stack)) } map { "@underline" -> _ },
        (node \ "@overline").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigInt](x, scalaxb.ElemName(node) :: stack)) } map { "@overline" -> _ },
        (node \ "@line-through").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigInt](x, scalaxb.ElemName(node) :: stack)) } map { "@line-through" -> _ },
        (node \ "@rotation").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@rotation" -> _ },
        (node \ "@letter-spacing").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@letter-spacing" -> _ },
        (node \ "@line-height").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@line-height" -> _ },
        (node \ "@dir").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Textu45direction](x, scalaxb.ElemName(node) :: stack)) } map { "@dir" -> _ },
        (node \ "@enclosure").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Enclosureu45shape](x, scalaxb.ElemName(node) :: stack)) } map { "@enclosure" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Formattedu45symbol, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@justify", _) => __obj.justify foreach { x => attr = scala.xml.Attribute(null, "justify", x.toString, attr) }
        case ("@default-x", _) => __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.bigDecimal.toPlainString, attr) }
        case ("@default-y", _) => __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.bigDecimal.toPlainString, attr) }
        case ("@relative-x", _) => __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.bigDecimal.toPlainString, attr) }
        case ("@relative-y", _) => __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.bigDecimal.toPlainString, attr) }
        case ("@font-family", _) => __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
        case ("@font-style", _) => __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
        case ("@font-size", _) => __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
        case ("@font-weight", _) => __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
        case ("@color", _) => __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
        case ("@halign", _) => __obj.halign foreach { x => attr = scala.xml.Attribute(null, "halign", x.toString, attr) }
        case ("@valign", _) => __obj.valign foreach { x => attr = scala.xml.Attribute(null, "valign", x.toString, attr) }
        case ("@underline", _) => __obj.underline foreach { x => attr = scala.xml.Attribute(null, "underline", x.toString, attr) }
        case ("@overline", _) => __obj.overline foreach { x => attr = scala.xml.Attribute(null, "overline", x.toString, attr) }
        case ("@line-through", _) => __obj.lineu45through foreach { x => attr = scala.xml.Attribute(null, "line-through", x.toString, attr) }
        case ("@rotation", _) => __obj.rotation foreach { x => attr = scala.xml.Attribute(null, "rotation", x.bigDecimal.toPlainString, attr) }
        case ("@letter-spacing", _) => __obj.letteru45spacing foreach { x => attr = scala.xml.Attribute(null, "letter-spacing", x.toString, attr) }
        case ("@line-height", _) => __obj.lineu45height foreach { x => attr = scala.xml.Attribute(null, "line-height", x.toString, attr) }
        case ("@dir", _) => __obj.dir foreach { x => attr = scala.xml.Attribute(null, "dir", x.toString, attr) }
        case ("@enclosure", _) => __obj.enclosure foreach { x => attr = scala.xml.Attribute(null, "enclosure", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Formattedu45symbol, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultMusicxml_Formattedu45symbolu45idFormat extends scalaxb.XMLFormat[musicxml.Formattedu45symbolu45id] with scalaxb.CanWriteChildNodes[musicxml.Formattedu45symbolu45id] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Formattedu45symbolu45id] = seq match {
      case node: scala.xml.Node => Right(musicxml.Formattedu45symbolu45id(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@justify").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Leftu45centeru45right](x, scalaxb.ElemName(node) :: stack)) } map { "@justify" -> _ },
        (node \ "@default-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-x" -> _ },
        (node \ "@default-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-y" -> _ },
        (node \ "@relative-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-x" -> _ },
        (node \ "@relative-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-y" -> _ },
        (node \ "@font-family").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-family" -> _ },
        (node \ "@font-style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45style](x, scalaxb.ElemName(node) :: stack)) } map { "@font-style" -> _ },
        (node \ "@font-size").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-size" -> _ },
        (node \ "@font-weight").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45weight](x, scalaxb.ElemName(node) :: stack)) } map { "@font-weight" -> _ },
        (node \ "@color").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@color" -> _ },
        (node \ "@halign").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Leftu45centeru45right](x, scalaxb.ElemName(node) :: stack)) } map { "@halign" -> _ },
        (node \ "@valign").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Valign](x, scalaxb.ElemName(node) :: stack)) } map { "@valign" -> _ },
        (node \ "@underline").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigInt](x, scalaxb.ElemName(node) :: stack)) } map { "@underline" -> _ },
        (node \ "@overline").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigInt](x, scalaxb.ElemName(node) :: stack)) } map { "@overline" -> _ },
        (node \ "@line-through").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigInt](x, scalaxb.ElemName(node) :: stack)) } map { "@line-through" -> _ },
        (node \ "@rotation").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@rotation" -> _ },
        (node \ "@letter-spacing").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@letter-spacing" -> _ },
        (node \ "@line-height").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@line-height" -> _ },
        (node \ "@dir").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Textu45direction](x, scalaxb.ElemName(node) :: stack)) } map { "@dir" -> _ },
        (node \ "@enclosure").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Enclosureu45shape](x, scalaxb.ElemName(node) :: stack)) } map { "@enclosure" -> _ },
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Formattedu45symbolu45id, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@justify", _) => __obj.justify foreach { x => attr = scala.xml.Attribute(null, "justify", x.toString, attr) }
        case ("@default-x", _) => __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.bigDecimal.toPlainString, attr) }
        case ("@default-y", _) => __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.bigDecimal.toPlainString, attr) }
        case ("@relative-x", _) => __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.bigDecimal.toPlainString, attr) }
        case ("@relative-y", _) => __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.bigDecimal.toPlainString, attr) }
        case ("@font-family", _) => __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
        case ("@font-style", _) => __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
        case ("@font-size", _) => __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
        case ("@font-weight", _) => __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
        case ("@color", _) => __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
        case ("@halign", _) => __obj.halign foreach { x => attr = scala.xml.Attribute(null, "halign", x.toString, attr) }
        case ("@valign", _) => __obj.valign foreach { x => attr = scala.xml.Attribute(null, "valign", x.toString, attr) }
        case ("@underline", _) => __obj.underline foreach { x => attr = scala.xml.Attribute(null, "underline", x.toString, attr) }
        case ("@overline", _) => __obj.overline foreach { x => attr = scala.xml.Attribute(null, "overline", x.toString, attr) }
        case ("@line-through", _) => __obj.lineu45through foreach { x => attr = scala.xml.Attribute(null, "line-through", x.toString, attr) }
        case ("@rotation", _) => __obj.rotation foreach { x => attr = scala.xml.Attribute(null, "rotation", x.bigDecimal.toPlainString, attr) }
        case ("@letter-spacing", _) => __obj.letteru45spacing foreach { x => attr = scala.xml.Attribute(null, "letter-spacing", x.toString, attr) }
        case ("@line-height", _) => __obj.lineu45height foreach { x => attr = scala.xml.Attribute(null, "line-height", x.toString, attr) }
        case ("@dir", _) => __obj.dir foreach { x => attr = scala.xml.Attribute(null, "dir", x.toString, attr) }
        case ("@enclosure", _) => __obj.enclosure foreach { x => attr = scala.xml.Attribute(null, "enclosure", x.toString, attr) }
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Formattedu45symbolu45id, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultMusicxml_Formattedu45textFormat extends scalaxb.XMLFormat[musicxml.Formattedu45text] with scalaxb.CanWriteChildNodes[musicxml.Formattedu45text] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Formattedu45text] = seq match {
      case node: scala.xml.Node => Right(musicxml.Formattedu45text(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@justify").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Leftu45centeru45right](x, scalaxb.ElemName(node) :: stack)) } map { "@justify" -> _ },
        (node \ "@default-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-x" -> _ },
        (node \ "@default-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-y" -> _ },
        (node \ "@relative-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-x" -> _ },
        (node \ "@relative-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-y" -> _ },
        (node \ "@font-family").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-family" -> _ },
        (node \ "@font-style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45style](x, scalaxb.ElemName(node) :: stack)) } map { "@font-style" -> _ },
        (node \ "@font-size").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-size" -> _ },
        (node \ "@font-weight").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45weight](x, scalaxb.ElemName(node) :: stack)) } map { "@font-weight" -> _ },
        (node \ "@color").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@color" -> _ },
        (node \ "@halign").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Leftu45centeru45right](x, scalaxb.ElemName(node) :: stack)) } map { "@halign" -> _ },
        (node \ "@valign").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Valign](x, scalaxb.ElemName(node) :: stack)) } map { "@valign" -> _ },
        (node \ "@underline").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigInt](x, scalaxb.ElemName(node) :: stack)) } map { "@underline" -> _ },
        (node \ "@overline").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigInt](x, scalaxb.ElemName(node) :: stack)) } map { "@overline" -> _ },
        (node \ "@line-through").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigInt](x, scalaxb.ElemName(node) :: stack)) } map { "@line-through" -> _ },
        (node \ "@rotation").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@rotation" -> _ },
        (node \ "@letter-spacing").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@letter-spacing" -> _ },
        (node \ "@line-height").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@line-height" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}lang").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}lang" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}space").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}space" -> _ },
        (node \ "@dir").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Textu45direction](x, scalaxb.ElemName(node) :: stack)) } map { "@dir" -> _ },
        (node \ "@enclosure").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Enclosureu45shape](x, scalaxb.ElemName(node) :: stack)) } map { "@enclosure" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Formattedu45text, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@justify", _) => __obj.justify foreach { x => attr = scala.xml.Attribute(null, "justify", x.toString, attr) }
        case ("@default-x", _) => __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.bigDecimal.toPlainString, attr) }
        case ("@default-y", _) => __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.bigDecimal.toPlainString, attr) }
        case ("@relative-x", _) => __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.bigDecimal.toPlainString, attr) }
        case ("@relative-y", _) => __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.bigDecimal.toPlainString, attr) }
        case ("@font-family", _) => __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
        case ("@font-style", _) => __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
        case ("@font-size", _) => __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
        case ("@font-weight", _) => __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
        case ("@color", _) => __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
        case ("@halign", _) => __obj.halign foreach { x => attr = scala.xml.Attribute(null, "halign", x.toString, attr) }
        case ("@valign", _) => __obj.valign foreach { x => attr = scala.xml.Attribute(null, "valign", x.toString, attr) }
        case ("@underline", _) => __obj.underline foreach { x => attr = scala.xml.Attribute(null, "underline", x.toString, attr) }
        case ("@overline", _) => __obj.overline foreach { x => attr = scala.xml.Attribute(null, "overline", x.toString, attr) }
        case ("@line-through", _) => __obj.lineu45through foreach { x => attr = scala.xml.Attribute(null, "line-through", x.toString, attr) }
        case ("@rotation", _) => __obj.rotation foreach { x => attr = scala.xml.Attribute(null, "rotation", x.bigDecimal.toPlainString, attr) }
        case ("@letter-spacing", _) => __obj.letteru45spacing foreach { x => attr = scala.xml.Attribute(null, "letter-spacing", x.toString, attr) }
        case ("@line-height", _) => __obj.lineu45height foreach { x => attr = scala.xml.Attribute(null, "line-height", x.toString, attr) }
        case ("@{http://www.w3.org/XML/1998/namespace}lang", _) => __obj.xmllang foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", x.toString, attr) }
        case ("@{http://www.w3.org/XML/1998/namespace}space", _) => __obj.xmlspace foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "space", x.toString, attr) }
        case ("@dir", _) => __obj.dir foreach { x => attr = scala.xml.Attribute(null, "dir", x.toString, attr) }
        case ("@enclosure", _) => __obj.enclosure foreach { x => attr = scala.xml.Attribute(null, "enclosure", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Formattedu45text, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultMusicxml_Formattedu45textu45idFormat extends scalaxb.XMLFormat[musicxml.Formattedu45textu45id] with scalaxb.CanWriteChildNodes[musicxml.Formattedu45textu45id] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Formattedu45textu45id] = seq match {
      case node: scala.xml.Node => Right(musicxml.Formattedu45textu45id(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@justify").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Leftu45centeru45right](x, scalaxb.ElemName(node) :: stack)) } map { "@justify" -> _ },
        (node \ "@default-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-x" -> _ },
        (node \ "@default-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-y" -> _ },
        (node \ "@relative-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-x" -> _ },
        (node \ "@relative-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-y" -> _ },
        (node \ "@font-family").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-family" -> _ },
        (node \ "@font-style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45style](x, scalaxb.ElemName(node) :: stack)) } map { "@font-style" -> _ },
        (node \ "@font-size").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-size" -> _ },
        (node \ "@font-weight").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45weight](x, scalaxb.ElemName(node) :: stack)) } map { "@font-weight" -> _ },
        (node \ "@color").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@color" -> _ },
        (node \ "@halign").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Leftu45centeru45right](x, scalaxb.ElemName(node) :: stack)) } map { "@halign" -> _ },
        (node \ "@valign").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Valign](x, scalaxb.ElemName(node) :: stack)) } map { "@valign" -> _ },
        (node \ "@underline").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigInt](x, scalaxb.ElemName(node) :: stack)) } map { "@underline" -> _ },
        (node \ "@overline").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigInt](x, scalaxb.ElemName(node) :: stack)) } map { "@overline" -> _ },
        (node \ "@line-through").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigInt](x, scalaxb.ElemName(node) :: stack)) } map { "@line-through" -> _ },
        (node \ "@rotation").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@rotation" -> _ },
        (node \ "@letter-spacing").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@letter-spacing" -> _ },
        (node \ "@line-height").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@line-height" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}lang").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}lang" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}space").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}space" -> _ },
        (node \ "@dir").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Textu45direction](x, scalaxb.ElemName(node) :: stack)) } map { "@dir" -> _ },
        (node \ "@enclosure").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Enclosureu45shape](x, scalaxb.ElemName(node) :: stack)) } map { "@enclosure" -> _ },
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Formattedu45textu45id, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@justify", _) => __obj.justify foreach { x => attr = scala.xml.Attribute(null, "justify", x.toString, attr) }
        case ("@default-x", _) => __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.bigDecimal.toPlainString, attr) }
        case ("@default-y", _) => __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.bigDecimal.toPlainString, attr) }
        case ("@relative-x", _) => __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.bigDecimal.toPlainString, attr) }
        case ("@relative-y", _) => __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.bigDecimal.toPlainString, attr) }
        case ("@font-family", _) => __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
        case ("@font-style", _) => __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
        case ("@font-size", _) => __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
        case ("@font-weight", _) => __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
        case ("@color", _) => __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
        case ("@halign", _) => __obj.halign foreach { x => attr = scala.xml.Attribute(null, "halign", x.toString, attr) }
        case ("@valign", _) => __obj.valign foreach { x => attr = scala.xml.Attribute(null, "valign", x.toString, attr) }
        case ("@underline", _) => __obj.underline foreach { x => attr = scala.xml.Attribute(null, "underline", x.toString, attr) }
        case ("@overline", _) => __obj.overline foreach { x => attr = scala.xml.Attribute(null, "overline", x.toString, attr) }
        case ("@line-through", _) => __obj.lineu45through foreach { x => attr = scala.xml.Attribute(null, "line-through", x.toString, attr) }
        case ("@rotation", _) => __obj.rotation foreach { x => attr = scala.xml.Attribute(null, "rotation", x.bigDecimal.toPlainString, attr) }
        case ("@letter-spacing", _) => __obj.letteru45spacing foreach { x => attr = scala.xml.Attribute(null, "letter-spacing", x.toString, attr) }
        case ("@line-height", _) => __obj.lineu45height foreach { x => attr = scala.xml.Attribute(null, "line-height", x.toString, attr) }
        case ("@{http://www.w3.org/XML/1998/namespace}lang", _) => __obj.xmllang foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", x.toString, attr) }
        case ("@{http://www.w3.org/XML/1998/namespace}space", _) => __obj.xmlspace foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "space", x.toString, attr) }
        case ("@dir", _) => __obj.dir foreach { x => attr = scala.xml.Attribute(null, "dir", x.toString, attr) }
        case ("@enclosure", _) => __obj.enclosure foreach { x => attr = scala.xml.Attribute(null, "enclosure", x.toString, attr) }
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Formattedu45textu45id, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultMusicxml_FretFormat extends scalaxb.XMLFormat[musicxml.Fret] with scalaxb.CanWriteChildNodes[musicxml.Fret] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Fret] = seq match {
      case node: scala.xml.Node => Right(musicxml.Fret(scalaxb.fromXML[BigInt](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@font-family").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-family" -> _ },
        (node \ "@font-style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45style](x, scalaxb.ElemName(node) :: stack)) } map { "@font-style" -> _ },
        (node \ "@font-size").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-size" -> _ },
        (node \ "@font-weight").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45weight](x, scalaxb.ElemName(node) :: stack)) } map { "@font-weight" -> _ },
        (node \ "@color").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@color" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Fret, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@font-family", _) => __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
        case ("@font-style", _) => __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
        case ("@font-size", _) => __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
        case ("@font-weight", _) => __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
        case ("@color", _) => __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Fret, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultMusicxml_LevelFormat extends scalaxb.XMLFormat[musicxml.Level] with scalaxb.CanWriteChildNodes[musicxml.Level] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Level] = seq match {
      case node: scala.xml.Node => Right(musicxml.Level(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@reference").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Yesu45no](x, scalaxb.ElemName(node) :: stack)) } map { "@reference" -> _ },
        (node \ "@parentheses").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Yesu45no](x, scalaxb.ElemName(node) :: stack)) } map { "@parentheses" -> _ },
        (node \ "@bracket").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Yesu45no](x, scalaxb.ElemName(node) :: stack)) } map { "@bracket" -> _ },
        (node \ "@size").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Symbolu45size](x, scalaxb.ElemName(node) :: stack)) } map { "@size" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Level, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@reference", _) => __obj.reference foreach { x => attr = scala.xml.Attribute(null, "reference", x.toString, attr) }
        case ("@parentheses", _) => __obj.parentheses foreach { x => attr = scala.xml.Attribute(null, "parentheses", x.toString, attr) }
        case ("@bracket", _) => __obj.bracket foreach { x => attr = scala.xml.Attribute(null, "bracket", x.toString, attr) }
        case ("@size", _) => __obj.size foreach { x => attr = scala.xml.Attribute(null, "size", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Level, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultMusicxml_Midiu45deviceFormat extends scalaxb.XMLFormat[musicxml.Midiu45device] with scalaxb.CanWriteChildNodes[musicxml.Midiu45device] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Midiu45device] = seq match {
      case node: scala.xml.Node => Right(musicxml.Midiu45device(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@port").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigInt](x, scalaxb.ElemName(node) :: stack)) } map { "@port" -> _ },
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Midiu45device, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@port", _) => __obj.port foreach { x => attr = scala.xml.Attribute(null, "port", x.toString, attr) }
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Midiu45device, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultMusicxml_Midiu45instrumentFormat extends scalaxb.ElemNameParser[musicxml.Midiu45instrument] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("midi-instrument")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[musicxml.Midiu45instrument] =
      phrase(opt(scalaxb.ElemName(None, "midi-channel")) ~ 
      opt(scalaxb.ElemName(None, "midi-name")) ~ 
      opt(scalaxb.ElemName(None, "midi-bank")) ~ 
      opt(scalaxb.ElemName(None, "midi-program")) ~ 
      opt(scalaxb.ElemName(None, "midi-unpitched")) ~ 
      opt(scalaxb.ElemName(None, "volume")) ~ 
      opt(scalaxb.ElemName(None, "pan")) ~ 
      opt(scalaxb.ElemName(None, "elevation")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 =>
      musicxml.Midiu45instrument(p1.headOption map { scalaxb.fromXML[BigInt](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        p3.headOption map { scalaxb.fromXML[BigInt](_, scalaxb.ElemName(node) :: stack) },
        p4.headOption map { scalaxb.fromXML[BigInt](_, scalaxb.ElemName(node) :: stack) },
        p5.headOption map { scalaxb.fromXML[BigInt](_, scalaxb.ElemName(node) :: stack) },
        p6.headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        p7.headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        p8.headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: musicxml.Midiu45instrument, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => attr = scala.xml.Attribute(null, "id", __obj.id.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Midiu45instrument, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.midiu45channel map { scalaxb.toXML[BigInt](_, None, Some("midi-channel"), __scope, false) } getOrElse {Nil},
        __obj.midiu45name map { scalaxb.toXML[String](_, None, Some("midi-name"), __scope, false) } getOrElse {Nil},
        __obj.midiu45bank map { scalaxb.toXML[BigInt](_, None, Some("midi-bank"), __scope, false) } getOrElse {Nil},
        __obj.midiu45program map { scalaxb.toXML[BigInt](_, None, Some("midi-program"), __scope, false) } getOrElse {Nil},
        __obj.midiu45unpitched map { scalaxb.toXML[BigInt](_, None, Some("midi-unpitched"), __scope, false) } getOrElse {Nil},
        __obj.volume map { scalaxb.toXML[BigDecimal](_, None, Some("volume"), __scope, false) } getOrElse {Nil},
        __obj.pan map { scalaxb.toXML[BigDecimal](_, None, Some("pan"), __scope, false) } getOrElse {Nil},
        __obj.elevation map { scalaxb.toXML[BigDecimal](_, None, Some("elevation"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultMusicxml_Nameu45displayFormat extends scalaxb.ElemNameParser[musicxml.Nameu45display] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("name-display")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[musicxml.Nameu45display] =
      phrase(safeRep(((scalaxb.ElemName(None, "display-text")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Formattedu45text](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "accidental-text")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Accidentalu45text](x, scalaxb.ElemName(node) :: stack))))) ^^
      { case p1 =>
      musicxml.Nameu45display(p1,
        scala.collection.immutable.ListMap(List(
        (node \ "@print-object").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Yesu45no](x, scalaxb.ElemName(node) :: stack)) } map { "@print-object" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: musicxml.Nameu45display, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@print-object", _) => __obj.printu45object foreach { x => attr = scala.xml.Attribute(null, "print-object", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Nameu45display, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.nameu45displayoption flatMap { x => scalaxb.toXML[scalaxb.DataRecord[musicxml.Nameu45displayOption]](x, x.namespace, x.key, __scope, false) })
  }

  trait DefaultMusicxml_Otheru45playFormat extends scalaxb.XMLFormat[musicxml.Otheru45play] with scalaxb.CanWriteChildNodes[musicxml.Otheru45play] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Otheru45play] = seq match {
      case node: scala.xml.Node => Right(musicxml.Otheru45play(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Otheru45play, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Otheru45play, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultMusicxml_PlayFormat extends scalaxb.ElemNameParser[musicxml.Play] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("play")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[musicxml.Play] =
      phrase(safeRep(((scalaxb.ElemName(None, "ipa")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "mute")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "semi-pitched")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "other-play")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Otheru45play](x, scalaxb.ElemName(node) :: stack))))) ^^
      { case p1 =>
      musicxml.Play(p1,
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: musicxml.Play, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Play, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.playoption flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) })
  }

  trait DefaultMusicxml_SegnoFormat extends scalaxb.XMLFormat[musicxml.Segno] with scalaxb.CanWriteChildNodes[musicxml.Segno] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Segno] = seq match {
      case node: scala.xml.Node => Right(musicxml.Segno(scala.collection.immutable.ListMap(List(
        (node \ "@default-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-x" -> _ },
        (node \ "@default-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-y" -> _ },
        (node \ "@relative-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-x" -> _ },
        (node \ "@relative-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-y" -> _ },
        (node \ "@font-family").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-family" -> _ },
        (node \ "@font-style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45style](x, scalaxb.ElemName(node) :: stack)) } map { "@font-style" -> _ },
        (node \ "@font-size").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-size" -> _ },
        (node \ "@font-weight").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45weight](x, scalaxb.ElemName(node) :: stack)) } map { "@font-weight" -> _ },
        (node \ "@color").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@color" -> _ },
        (node \ "@halign").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Leftu45centeru45right](x, scalaxb.ElemName(node) :: stack)) } map { "@halign" -> _ },
        (node \ "@valign").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Valign](x, scalaxb.ElemName(node) :: stack)) } map { "@valign" -> _ },
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@smufl").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@smufl" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Segno, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@default-x", _) => __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.bigDecimal.toPlainString, attr) }
        case ("@default-y", _) => __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.bigDecimal.toPlainString, attr) }
        case ("@relative-x", _) => __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.bigDecimal.toPlainString, attr) }
        case ("@relative-y", _) => __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.bigDecimal.toPlainString, attr) }
        case ("@font-family", _) => __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
        case ("@font-style", _) => __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
        case ("@font-size", _) => __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
        case ("@font-weight", _) => __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
        case ("@color", _) => __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
        case ("@halign", _) => __obj.halign foreach { x => attr = scala.xml.Attribute(null, "halign", x.toString, attr) }
        case ("@valign", _) => __obj.valign foreach { x => attr = scala.xml.Attribute(null, "valign", x.toString, attr) }
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@smufl", _) => __obj.smufl foreach { x => attr = scala.xml.Attribute(null, "smufl", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Segno, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil

  }

  trait DefaultMusicxml_StringTypeFormat extends scalaxb.XMLFormat[musicxml.StringType] with scalaxb.CanWriteChildNodes[musicxml.StringType] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.StringType] = seq match {
      case node: scala.xml.Node => Right(musicxml.StringType(scalaxb.fromXML[BigInt](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@default-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-x" -> _ },
        (node \ "@default-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-y" -> _ },
        (node \ "@relative-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-x" -> _ },
        (node \ "@relative-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-y" -> _ },
        (node \ "@font-family").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-family" -> _ },
        (node \ "@font-style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45style](x, scalaxb.ElemName(node) :: stack)) } map { "@font-style" -> _ },
        (node \ "@font-size").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-size" -> _ },
        (node \ "@font-weight").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45weight](x, scalaxb.ElemName(node) :: stack)) } map { "@font-weight" -> _ },
        (node \ "@color").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@color" -> _ },
        (node \ "@placement").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Aboveu45below](x, scalaxb.ElemName(node) :: stack)) } map { "@placement" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.StringType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@default-x", _) => __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.bigDecimal.toPlainString, attr) }
        case ("@default-y", _) => __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.bigDecimal.toPlainString, attr) }
        case ("@relative-x", _) => __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.bigDecimal.toPlainString, attr) }
        case ("@relative-y", _) => __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.bigDecimal.toPlainString, attr) }
        case ("@font-family", _) => __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
        case ("@font-style", _) => __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
        case ("@font-size", _) => __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
        case ("@font-weight", _) => __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
        case ("@color", _) => __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
        case ("@placement", _) => __obj.placement foreach { x => attr = scala.xml.Attribute(null, "placement", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.StringType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultMusicxml_Typedu45textFormat extends scalaxb.XMLFormat[musicxml.Typedu45text] with scalaxb.CanWriteChildNodes[musicxml.Typedu45text] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Typedu45text] = seq match {
      case node: scala.xml.Node => Right(musicxml.Typedu45text(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Typedu45text, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => __obj.typeValue foreach { x => attr = scala.xml.Attribute(null, "type", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Typedu45text, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultMusicxml_Wavyu45lineFormat extends scalaxb.XMLFormat[musicxml.Wavyu45line] with scalaxb.CanWriteChildNodes[musicxml.Wavyu45line] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Wavyu45line] = seq match {
      case node: scala.xml.Node => Right(musicxml.Wavyu45line(scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Startu45stopu45continue](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ },
        (node \ "@number").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigInt](x, scalaxb.ElemName(node) :: stack)) } map { "@number" -> _ },
        (node \ "@default-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-x" -> _ },
        (node \ "@default-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-y" -> _ },
        (node \ "@relative-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-x" -> _ },
        (node \ "@relative-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-y" -> _ },
        (node \ "@placement").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Aboveu45below](x, scalaxb.ElemName(node) :: stack)) } map { "@placement" -> _ },
        (node \ "@color").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@color" -> _ },
        (node \ "@start-note").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Startu45note](x, scalaxb.ElemName(node) :: stack)) } map { "@start-note" -> _ },
        (node \ "@trill-step").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Trillu45step](x, scalaxb.ElemName(node) :: stack)) } map { "@trill-step" -> _ },
        (node \ "@two-note-turn").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Twou45noteu45turn](x, scalaxb.ElemName(node) :: stack)) } map { "@two-note-turn" -> _ },
        (node \ "@accelerate").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Yesu45no](x, scalaxb.ElemName(node) :: stack)) } map { "@accelerate" -> _ },
        (node \ "@beats").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@beats" -> _ },
        (node \ "@second-beat").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@second-beat" -> _ },
        (node \ "@last-beat").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@last-beat" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Wavyu45line, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case ("@number", _) => __obj.number foreach { x => attr = scala.xml.Attribute(null, "number", x.toString, attr) }
        case ("@default-x", _) => __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.bigDecimal.toPlainString, attr) }
        case ("@default-y", _) => __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.bigDecimal.toPlainString, attr) }
        case ("@relative-x", _) => __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.bigDecimal.toPlainString, attr) }
        case ("@relative-y", _) => __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.bigDecimal.toPlainString, attr) }
        case ("@placement", _) => __obj.placement foreach { x => attr = scala.xml.Attribute(null, "placement", x.toString, attr) }
        case ("@color", _) => __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
        case ("@start-note", _) => __obj.startu45note foreach { x => attr = scala.xml.Attribute(null, "start-note", x.toString, attr) }
        case ("@trill-step", _) => __obj.trillu45step foreach { x => attr = scala.xml.Attribute(null, "trill-step", x.toString, attr) }
        case ("@two-note-turn", _) => __obj.twou45noteu45turn foreach { x => attr = scala.xml.Attribute(null, "two-note-turn", x.toString, attr) }
        case ("@accelerate", _) => __obj.accelerate foreach { x => attr = scala.xml.Attribute(null, "accelerate", x.toString, attr) }
        case ("@beats", _) => __obj.beats foreach { x => attr = scala.xml.Attribute(null, "beats", x.bigDecimal.toPlainString, attr) }
        case ("@second-beat", _) => __obj.secondu45beat foreach { x => attr = scala.xml.Attribute(null, "second-beat", x.bigDecimal.toPlainString, attr) }
        case ("@last-beat", _) => __obj.lastu45beat foreach { x => attr = scala.xml.Attribute(null, "last-beat", x.bigDecimal.toPlainString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Wavyu45line, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil

  }

  trait DefaultMusicxml_DirectiveFormat extends scalaxb.XMLFormat[musicxml.Directive] with scalaxb.CanWriteChildNodes[musicxml.Directive] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Directive] = seq match {
      case node: scala.xml.Node => Right(musicxml.Directive(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@default-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-x" -> _ },
        (node \ "@default-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-y" -> _ },
        (node \ "@relative-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-x" -> _ },
        (node \ "@relative-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-y" -> _ },
        (node \ "@font-family").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-family" -> _ },
        (node \ "@font-style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45style](x, scalaxb.ElemName(node) :: stack)) } map { "@font-style" -> _ },
        (node \ "@font-size").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-size" -> _ },
        (node \ "@font-weight").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45weight](x, scalaxb.ElemName(node) :: stack)) } map { "@font-weight" -> _ },
        (node \ "@color").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@color" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}lang").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}lang" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Directive, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@default-x", _) => __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.bigDecimal.toPlainString, attr) }
        case ("@default-y", _) => __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.bigDecimal.toPlainString, attr) }
        case ("@relative-x", _) => __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.bigDecimal.toPlainString, attr) }
        case ("@relative-y", _) => __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.bigDecimal.toPlainString, attr) }
        case ("@font-family", _) => __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
        case ("@font-style", _) => __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
        case ("@font-size", _) => __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
        case ("@font-weight", _) => __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
        case ("@color", _) => __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
        case ("@{http://www.w3.org/XML/1998/namespace}lang", _) => __obj.xmllang foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Directive, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultMusicxml_AttributesTypeFormat extends scalaxb.ElemNameParser[musicxml.AttributesType] with Musicxml_EditorialGroupFormat {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("attributes")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[musicxml.AttributesType] =
      phrase((parseEditorialGroup(node, scalaxb.ElemName(node) :: stack)) ~ 
      opt(scalaxb.ElemName(None, "divisions")) ~ 
      safeRep(scalaxb.ElemName(None, "key")) ~ 
      safeRep(scalaxb.ElemName(None, "time")) ~ 
      opt(scalaxb.ElemName(None, "staves")) ~ 
      opt(scalaxb.ElemName(None, "part-symbol")) ~ 
      opt(scalaxb.ElemName(None, "instruments")) ~ 
      safeRep(scalaxb.ElemName(None, "clef")) ~ 
      safeRep(scalaxb.ElemName(None, "staff-details")) ~ 
      safeRep(scalaxb.ElemName(None, "transpose")) ~ 
      safeRep(scalaxb.ElemName(None, "directive")) ~ 
      safeRep(scalaxb.ElemName(None, "measure-style")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 ~ p9 ~ p10 ~ p11 ~ p12 =>
      musicxml.AttributesType(p1,
        p2.headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[musicxml.Key](_, scalaxb.ElemName(node) :: stack) },
        p4 map { scalaxb.fromXML[musicxml.Time](_, scalaxb.ElemName(node) :: stack) },
        p5.headOption map { scalaxb.fromXML[BigInt](_, scalaxb.ElemName(node) :: stack) },
        p6.headOption map { scalaxb.fromXML[musicxml.Partu45symbol](_, scalaxb.ElemName(node) :: stack) },
        p7.headOption map { scalaxb.fromXML[BigInt](_, scalaxb.ElemName(node) :: stack) },
        p8 map { scalaxb.fromXML[musicxml.Clef](_, scalaxb.ElemName(node) :: stack) },
        p9 map { scalaxb.fromXML[musicxml.Staffu45details](_, scalaxb.ElemName(node) :: stack) },
        p10 map { scalaxb.fromXML[musicxml.Transpose](_, scalaxb.ElemName(node) :: stack) },
        p11 map { scalaxb.fromXML[musicxml.Directive](_, scalaxb.ElemName(node) :: stack) },
        p12 map { scalaxb.fromXML[musicxml.Measureu45style](_, scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: musicxml.AttributesType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(scalaxb.toXML[musicxml.EditorialSequence](__obj.editorialSequence1, None, Some("editorialSequence1"), __scope, false),
        __obj.divisions map { scalaxb.toXML[BigDecimal](_, None, Some("divisions"), __scope, false) } getOrElse {Nil},
        __obj.key flatMap { scalaxb.toXML[musicxml.Key](_, None, Some("key"), __scope, false) },
        __obj.time flatMap { scalaxb.toXML[musicxml.Time](_, None, Some("time"), __scope, false) },
        __obj.staves map { scalaxb.toXML[BigInt](_, None, Some("staves"), __scope, false) } getOrElse {Nil},
        __obj.partu45symbol map { scalaxb.toXML[musicxml.Partu45symbol](_, None, Some("part-symbol"), __scope, false) } getOrElse {Nil},
        __obj.instruments map { scalaxb.toXML[BigInt](_, None, Some("instruments"), __scope, false) } getOrElse {Nil},
        __obj.clef flatMap { scalaxb.toXML[musicxml.Clef](_, None, Some("clef"), __scope, false) },
        __obj.staffu45details flatMap { scalaxb.toXML[musicxml.Staffu45details](_, None, Some("staff-details"), __scope, false) },
        __obj.transpose flatMap { scalaxb.toXML[musicxml.Transpose](_, None, Some("transpose"), __scope, false) },
        __obj.directive flatMap { scalaxb.toXML[musicxml.Directive](_, None, Some("directive"), __scope, false) },
        __obj.measureu45style flatMap { scalaxb.toXML[musicxml.Measureu45style](_, None, Some("measure-style"), __scope, false) })

  }

  trait DefaultMusicxml_Beatu45repeatFormat extends scalaxb.ElemNameParser[musicxml.Beatu45repeat] with Musicxml_SlashGroupFormat {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("beat-repeat")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[musicxml.Beatu45repeat] =
      phrase(opt(parseSlashGroup(node, scalaxb.ElemName(node) :: stack)) ^^
      { case p1 =>
      musicxml.Beatu45repeat(p1,
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Startu45stop](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ },
        (node \ "@slashes").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigInt](x, scalaxb.ElemName(node) :: stack)) } map { "@slashes" -> _ },
        (node \ "@use-dots").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Yesu45no](x, scalaxb.ElemName(node) :: stack)) } map { "@use-dots" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: musicxml.Beatu45repeat, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case ("@slashes", _) => __obj.slashes foreach { x => attr = scala.xml.Attribute(null, "slashes", x.toString, attr) }
        case ("@use-dots", _) => __obj.useu45dots foreach { x => attr = scala.xml.Attribute(null, "use-dots", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Beatu45repeat, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.slashSequence1 map { scalaxb.toXML[musicxml.SlashSequence](_, None, Some("slashSequence1"), __scope, false) } getOrElse {Nil})
  }

  trait DefaultMusicxml_CancelFormat extends scalaxb.XMLFormat[musicxml.Cancel] with scalaxb.CanWriteChildNodes[musicxml.Cancel] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Cancel] = seq match {
      case node: scala.xml.Node => Right(musicxml.Cancel(scalaxb.fromXML[BigInt](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@location").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Cancelu45location](x, scalaxb.ElemName(node) :: stack)) } map { "@location" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Cancel, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@location", _) => __obj.location foreach { x => attr = scala.xml.Attribute(null, "location", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Cancel, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultMusicxml_ClefFormat extends scalaxb.ElemNameParser[musicxml.Clef] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("clef")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[musicxml.Clef] =
      phrase((scalaxb.ElemName(None, "sign")) ~ 
      opt(scalaxb.ElemName(None, "line")) ~ 
      opt(scalaxb.ElemName(None, "clef-octave-change")) ^^
      { case p1 ~ p2 ~ p3 =>
      musicxml.Clef(scalaxb.fromXML[musicxml.Clefu45sign](p1, scalaxb.ElemName(node) :: stack),
        p2.headOption map { scalaxb.fromXML[BigInt](_, scalaxb.ElemName(node) :: stack) },
        p3.headOption map { scalaxb.fromXML[BigInt](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@number").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigInt](x, scalaxb.ElemName(node) :: stack)) } map { "@number" -> _ },
        (node \ "@additional").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Yesu45no](x, scalaxb.ElemName(node) :: stack)) } map { "@additional" -> _ },
        (node \ "@size").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Symbolu45size](x, scalaxb.ElemName(node) :: stack)) } map { "@size" -> _ },
        (node \ "@after-barline").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Yesu45no](x, scalaxb.ElemName(node) :: stack)) } map { "@after-barline" -> _ },
        (node \ "@default-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-x" -> _ },
        (node \ "@default-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-y" -> _ },
        (node \ "@relative-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-x" -> _ },
        (node \ "@relative-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-y" -> _ },
        (node \ "@font-family").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-family" -> _ },
        (node \ "@font-style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45style](x, scalaxb.ElemName(node) :: stack)) } map { "@font-style" -> _ },
        (node \ "@font-size").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-size" -> _ },
        (node \ "@font-weight").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45weight](x, scalaxb.ElemName(node) :: stack)) } map { "@font-weight" -> _ },
        (node \ "@color").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@color" -> _ },
        (node \ "@print-object").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Yesu45no](x, scalaxb.ElemName(node) :: stack)) } map { "@print-object" -> _ },
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: musicxml.Clef, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@number", _) => __obj.number foreach { x => attr = scala.xml.Attribute(null, "number", x.toString, attr) }
        case ("@additional", _) => __obj.additional foreach { x => attr = scala.xml.Attribute(null, "additional", x.toString, attr) }
        case ("@size", _) => __obj.size foreach { x => attr = scala.xml.Attribute(null, "size", x.toString, attr) }
        case ("@after-barline", _) => __obj.afteru45barline foreach { x => attr = scala.xml.Attribute(null, "after-barline", x.toString, attr) }
        case ("@default-x", _) => __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.bigDecimal.toPlainString, attr) }
        case ("@default-y", _) => __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.bigDecimal.toPlainString, attr) }
        case ("@relative-x", _) => __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.bigDecimal.toPlainString, attr) }
        case ("@relative-y", _) => __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.bigDecimal.toPlainString, attr) }
        case ("@font-family", _) => __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
        case ("@font-style", _) => __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
        case ("@font-size", _) => __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
        case ("@font-weight", _) => __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
        case ("@color", _) => __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
        case ("@print-object", _) => __obj.printu45object foreach { x => attr = scala.xml.Attribute(null, "print-object", x.toString, attr) }
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Clef, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(scalaxb.toXML[musicxml.Clefu45sign](__obj.sign, None, Some("sign"), __scope, false),
        __obj.line map { scalaxb.toXML[BigInt](_, None, Some("line"), __scope, false) } getOrElse {Nil},
        __obj.clefu45octaveu45change map { scalaxb.toXML[BigInt](_, None, Some("clef-octave-change"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultMusicxml_InterchangeableFormat extends scalaxb.ElemNameParser[musicxml.Interchangeable] with Musicxml_Timeu45signatureGroupFormat {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("interchangeable")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[musicxml.Interchangeable] =
      phrase(opt(scalaxb.ElemName(None, "time-relation")) ~ 
      safeRep(parseTimeu45signatureGroup(node, scalaxb.ElemName(node) :: stack)) ^^
      { case p1 ~ p2 =>
      musicxml.Interchangeable(p1.headOption map { scalaxb.fromXML[musicxml.Timeu45relation](_, scalaxb.ElemName(node) :: stack) },
        p2,
        scala.collection.immutable.ListMap(List(
        (node \ "@symbol").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Timeu45symbol](x, scalaxb.ElemName(node) :: stack)) } map { "@symbol" -> _ },
        (node \ "@separator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Timeu45separator](x, scalaxb.ElemName(node) :: stack)) } map { "@separator" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: musicxml.Interchangeable, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@symbol", _) => __obj.symbol foreach { x => attr = scala.xml.Attribute(null, "symbol", x.toString, attr) }
        case ("@separator", _) => __obj.separator foreach { x => attr = scala.xml.Attribute(null, "separator", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Interchangeable, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.timeu45relation map { scalaxb.toXML[musicxml.Timeu45relation](_, None, Some("time-relation"), __scope, false) } getOrElse {Nil},
        __obj.timeu45signatureSequence2 flatMap { scalaxb.toXML[musicxml.Timeu45signatureSequence](_, None, Some("timeu45signatureSequence2"), __scope, false) })

  }

  trait DefaultMusicxml_KeyFormat extends scalaxb.ElemNameParser[musicxml.Key] with Musicxml_Traditionalu45keyGroupFormat with Musicxml_Nonu45traditionalu45keyGroupFormat {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("key")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[musicxml.Key] =
      phrase(safeRep((parseTraditionalu45keyGroup(node, scalaxb.ElemName(node) :: stack, true)) ||| 
      (parseNonu45traditionalu45keyGroup(node, scalaxb.ElemName(node) :: stack, true))) ~ 
      safeRep(scalaxb.ElemName(None, "key-octave")) ^^
      { case p1 ~ p2 =>
      musicxml.Key(p1,
        p2 map { scalaxb.fromXML[musicxml.Keyu45octave](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@number").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigInt](x, scalaxb.ElemName(node) :: stack)) } map { "@number" -> _ },
        (node \ "@default-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-x" -> _ },
        (node \ "@default-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-y" -> _ },
        (node \ "@relative-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-x" -> _ },
        (node \ "@relative-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-y" -> _ },
        (node \ "@font-family").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-family" -> _ },
        (node \ "@font-style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45style](x, scalaxb.ElemName(node) :: stack)) } map { "@font-style" -> _ },
        (node \ "@font-size").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-size" -> _ },
        (node \ "@font-weight").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45weight](x, scalaxb.ElemName(node) :: stack)) } map { "@font-weight" -> _ },
        (node \ "@color").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@color" -> _ },
        (node \ "@print-object").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Yesu45no](x, scalaxb.ElemName(node) :: stack)) } map { "@print-object" -> _ },
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: musicxml.Key, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@number", _) => __obj.number foreach { x => attr = scala.xml.Attribute(null, "number", x.toString, attr) }
        case ("@default-x", _) => __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.bigDecimal.toPlainString, attr) }
        case ("@default-y", _) => __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.bigDecimal.toPlainString, attr) }
        case ("@relative-x", _) => __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.bigDecimal.toPlainString, attr) }
        case ("@relative-y", _) => __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.bigDecimal.toPlainString, attr) }
        case ("@font-family", _) => __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
        case ("@font-style", _) => __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
        case ("@font-size", _) => __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
        case ("@font-weight", _) => __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
        case ("@color", _) => __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
        case ("@print-object", _) => __obj.printu45object foreach { x => attr = scala.xml.Attribute(null, "print-object", x.toString, attr) }
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Key, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.keyoption flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) },
        __obj.keyu45octave flatMap { scalaxb.toXML[musicxml.Keyu45octave](_, None, Some("key-octave"), __scope, false) })

  }

  trait DefaultMusicxml_Keyu45accidentalFormat extends scalaxb.XMLFormat[musicxml.Keyu45accidental] with scalaxb.CanWriteChildNodes[musicxml.Keyu45accidental] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Keyu45accidental] = seq match {
      case node: scala.xml.Node => Right(musicxml.Keyu45accidental(scalaxb.fromXML[musicxml.Accidentalu45value](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@smufl").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@smufl" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Keyu45accidental, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@smufl", _) => __obj.smufl foreach { x => attr = scala.xml.Attribute(null, "smufl", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Keyu45accidental, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultMusicxml_Keyu45octaveFormat extends scalaxb.XMLFormat[musicxml.Keyu45octave] with scalaxb.CanWriteChildNodes[musicxml.Keyu45octave] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Keyu45octave] = seq match {
      case node: scala.xml.Node => Right(musicxml.Keyu45octave(scalaxb.fromXML[BigInt](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@number").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigInt](x, scalaxb.ElemName(node) :: stack)) } map { "@number" -> _ },
        (node \ "@cancel").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Yesu45no](x, scalaxb.ElemName(node) :: stack)) } map { "@cancel" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Keyu45octave, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@number", _) => attr = scala.xml.Attribute(null, "number", __obj.number.toString, attr)
        case ("@cancel", _) => __obj.cancel foreach { x => attr = scala.xml.Attribute(null, "cancel", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Keyu45octave, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultMusicxml_Measureu45repeatFormat extends scalaxb.XMLFormat[musicxml.Measureu45repeat] with scalaxb.CanWriteChildNodes[musicxml.Measureu45repeat] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Measureu45repeat] = seq match {
      case node: scala.xml.Node => Right(musicxml.Measureu45repeat(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Startu45stop](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ },
        (node \ "@slashes").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigInt](x, scalaxb.ElemName(node) :: stack)) } map { "@slashes" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Measureu45repeat, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case ("@slashes", _) => __obj.slashes foreach { x => attr = scala.xml.Attribute(null, "slashes", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Measureu45repeat, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultMusicxml_Measureu45styleFormat extends scalaxb.ElemNameParser[musicxml.Measureu45style] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("measure-style")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[musicxml.Measureu45style] =
      phrase((((scalaxb.ElemName(None, "multiple-rest")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Multipleu45rest](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "measure-repeat")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Measureu45repeat](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "beat-repeat")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Beatu45repeat](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "slash")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.SlashType](x, scalaxb.ElemName(node) :: stack))))) ^^
      { case p1 =>
      musicxml.Measureu45style(p1,
        scala.collection.immutable.ListMap(List(
        (node \ "@number").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigInt](x, scalaxb.ElemName(node) :: stack)) } map { "@number" -> _ },
        (node \ "@font-family").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-family" -> _ },
        (node \ "@font-style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45style](x, scalaxb.ElemName(node) :: stack)) } map { "@font-style" -> _ },
        (node \ "@font-size").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-size" -> _ },
        (node \ "@font-weight").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45weight](x, scalaxb.ElemName(node) :: stack)) } map { "@font-weight" -> _ },
        (node \ "@color").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@color" -> _ },
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: musicxml.Measureu45style, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@number", _) => __obj.number foreach { x => attr = scala.xml.Attribute(null, "number", x.toString, attr) }
        case ("@font-family", _) => __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
        case ("@font-style", _) => __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
        case ("@font-size", _) => __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
        case ("@font-weight", _) => __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
        case ("@color", _) => __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Measureu45style, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      ((Some(__obj.measureu45styleoption) map {x => scalaxb.toXML[scalaxb.DataRecord[musicxml.Measureu45styleOption]](x, x.namespace, x.key, __scope, false)}).get)
  }

  trait DefaultMusicxml_Multipleu45restFormat extends scalaxb.XMLFormat[musicxml.Multipleu45rest] with scalaxb.CanWriteChildNodes[musicxml.Multipleu45rest] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Multipleu45rest] = seq match {
      case node: scala.xml.Node => Right(musicxml.Multipleu45rest(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@use-symbols").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Yesu45no](x, scalaxb.ElemName(node) :: stack)) } map { "@use-symbols" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Multipleu45rest, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@use-symbols", _) => __obj.useu45symbols foreach { x => attr = scala.xml.Attribute(null, "use-symbols", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Multipleu45rest, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultMusicxml_Partu45symbolFormat extends scalaxb.XMLFormat[musicxml.Partu45symbol] with scalaxb.CanWriteChildNodes[musicxml.Partu45symbol] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Partu45symbol] = seq match {
      case node: scala.xml.Node => Right(musicxml.Partu45symbol(scalaxb.fromXML[musicxml.Groupu45symbolu45value](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@top-staff").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigInt](x, scalaxb.ElemName(node) :: stack)) } map { "@top-staff" -> _ },
        (node \ "@bottom-staff").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigInt](x, scalaxb.ElemName(node) :: stack)) } map { "@bottom-staff" -> _ },
        (node \ "@default-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-x" -> _ },
        (node \ "@default-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-y" -> _ },
        (node \ "@relative-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-x" -> _ },
        (node \ "@relative-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-y" -> _ },
        (node \ "@color").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@color" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Partu45symbol, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@top-staff", _) => __obj.topu45staff foreach { x => attr = scala.xml.Attribute(null, "top-staff", x.toString, attr) }
        case ("@bottom-staff", _) => __obj.bottomu45staff foreach { x => attr = scala.xml.Attribute(null, "bottom-staff", x.toString, attr) }
        case ("@default-x", _) => __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.bigDecimal.toPlainString, attr) }
        case ("@default-y", _) => __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.bigDecimal.toPlainString, attr) }
        case ("@relative-x", _) => __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.bigDecimal.toPlainString, attr) }
        case ("@relative-y", _) => __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.bigDecimal.toPlainString, attr) }
        case ("@color", _) => __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Partu45symbol, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultMusicxml_SlashTypeFormat extends scalaxb.ElemNameParser[musicxml.SlashType] with Musicxml_SlashGroupFormat {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("slash")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[musicxml.SlashType] =
      phrase(opt(parseSlashGroup(node, scalaxb.ElemName(node) :: stack)) ^^
      { case p1 =>
      musicxml.SlashType(p1,
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Startu45stop](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ },
        (node \ "@use-dots").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Yesu45no](x, scalaxb.ElemName(node) :: stack)) } map { "@use-dots" -> _ },
        (node \ "@use-stems").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Yesu45no](x, scalaxb.ElemName(node) :: stack)) } map { "@use-stems" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: musicxml.SlashType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case ("@use-dots", _) => __obj.useu45dots foreach { x => attr = scala.xml.Attribute(null, "use-dots", x.toString, attr) }
        case ("@use-stems", _) => __obj.useu45stems foreach { x => attr = scala.xml.Attribute(null, "use-stems", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.SlashType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.slashSequence1 map { scalaxb.toXML[musicxml.SlashSequence](_, None, Some("slashSequence1"), __scope, false) } getOrElse {Nil})
  }

  trait DefaultMusicxml_Staffu45detailsFormat extends scalaxb.ElemNameParser[musicxml.Staffu45details] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("staff-details")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[musicxml.Staffu45details] =
      phrase(opt(scalaxb.ElemName(None, "staff-type")) ~ 
      opt(scalaxb.ElemName(None, "staff-lines")) ~ 
      safeRep(scalaxb.ElemName(None, "staff-tuning")) ~ 
      opt(scalaxb.ElemName(None, "capo")) ~ 
      opt(scalaxb.ElemName(None, "staff-size")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 =>
      musicxml.Staffu45details(p1.headOption map { scalaxb.fromXML[musicxml.Staffu45type](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[BigInt](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[musicxml.Staffu45tuning](_, scalaxb.ElemName(node) :: stack) },
        p4.headOption map { scalaxb.fromXML[BigInt](_, scalaxb.ElemName(node) :: stack) },
        p5.headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@number").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigInt](x, scalaxb.ElemName(node) :: stack)) } map { "@number" -> _ },
        (node \ "@show-frets").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Showu45frets](x, scalaxb.ElemName(node) :: stack)) } map { "@show-frets" -> _ },
        (node \ "@print-object").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Yesu45no](x, scalaxb.ElemName(node) :: stack)) } map { "@print-object" -> _ },
        (node \ "@print-spacing").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Yesu45no](x, scalaxb.ElemName(node) :: stack)) } map { "@print-spacing" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: musicxml.Staffu45details, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@number", _) => __obj.number foreach { x => attr = scala.xml.Attribute(null, "number", x.toString, attr) }
        case ("@show-frets", _) => __obj.showu45frets foreach { x => attr = scala.xml.Attribute(null, "show-frets", x.toString, attr) }
        case ("@print-object", _) => __obj.printu45object foreach { x => attr = scala.xml.Attribute(null, "print-object", x.toString, attr) }
        case ("@print-spacing", _) => __obj.printu45spacing foreach { x => attr = scala.xml.Attribute(null, "print-spacing", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Staffu45details, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.staffu45type map { scalaxb.toXML[musicxml.Staffu45type](_, None, Some("staff-type"), __scope, false) } getOrElse {Nil},
        __obj.staffu45lines map { scalaxb.toXML[BigInt](_, None, Some("staff-lines"), __scope, false) } getOrElse {Nil},
        __obj.staffu45tuning flatMap { scalaxb.toXML[musicxml.Staffu45tuning](_, None, Some("staff-tuning"), __scope, false) },
        __obj.capo map { scalaxb.toXML[BigInt](_, None, Some("capo"), __scope, false) } getOrElse {Nil},
        __obj.staffu45size map { scalaxb.toXML[BigDecimal](_, None, Some("staff-size"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultMusicxml_Staffu45tuningFormat extends scalaxb.ElemNameParser[musicxml.Staffu45tuning] with Musicxml_TuningGroupFormat {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("staff-tuning")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[musicxml.Staffu45tuning] =
      phrase((parseTuningGroup(node, scalaxb.ElemName(node) :: stack)) ^^
      { case p1 =>
      musicxml.Staffu45tuning(p1,
        scala.collection.immutable.ListMap(List(
        (node \ "@line").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigInt](x, scalaxb.ElemName(node) :: stack)) } map { "@line" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: musicxml.Staffu45tuning, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@line", _) => __obj.line foreach { x => attr = scala.xml.Attribute(null, "line", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Staffu45tuning, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (scalaxb.toXML[musicxml.TuningSequence](__obj.tuningSequence1, None, Some("tuningSequence1"), __scope, false))
  }

  trait DefaultMusicxml_TimeFormat extends scalaxb.ElemNameParser[musicxml.Time] with Musicxml_Timeu45signatureGroupFormat {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("time")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[musicxml.Time] =
      phrase((((safeRep(parseTimeu45signatureGroup(node, scalaxb.ElemName(node) :: stack)) ~ 
      opt(scalaxb.ElemName(None, "interchangeable"))) ^^ 
        { case p1 ~ p2 => scalaxb.DataRecord(musicxml.TimeSequence1(p1,
        p2.headOption map { scalaxb.fromXML[musicxml.Interchangeable](_, scalaxb.ElemName(node) :: stack) })) }) ||| 
      ((scalaxb.ElemName(None, "senza-misura")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack))))) ^^
      { case p1 =>
      musicxml.Time(p1,
        scala.collection.immutable.ListMap(List(
        (node \ "@number").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigInt](x, scalaxb.ElemName(node) :: stack)) } map { "@number" -> _ },
        (node \ "@symbol").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Timeu45symbol](x, scalaxb.ElemName(node) :: stack)) } map { "@symbol" -> _ },
        (node \ "@separator").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Timeu45separator](x, scalaxb.ElemName(node) :: stack)) } map { "@separator" -> _ },
        (node \ "@default-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-x" -> _ },
        (node \ "@default-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-y" -> _ },
        (node \ "@relative-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-x" -> _ },
        (node \ "@relative-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-y" -> _ },
        (node \ "@font-family").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-family" -> _ },
        (node \ "@font-style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45style](x, scalaxb.ElemName(node) :: stack)) } map { "@font-style" -> _ },
        (node \ "@font-size").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-size" -> _ },
        (node \ "@font-weight").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45weight](x, scalaxb.ElemName(node) :: stack)) } map { "@font-weight" -> _ },
        (node \ "@color").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@color" -> _ },
        (node \ "@halign").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Leftu45centeru45right](x, scalaxb.ElemName(node) :: stack)) } map { "@halign" -> _ },
        (node \ "@valign").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Valign](x, scalaxb.ElemName(node) :: stack)) } map { "@valign" -> _ },
        (node \ "@print-object").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Yesu45no](x, scalaxb.ElemName(node) :: stack)) } map { "@print-object" -> _ },
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: musicxml.Time, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@number", _) => __obj.number foreach { x => attr = scala.xml.Attribute(null, "number", x.toString, attr) }
        case ("@symbol", _) => __obj.symbol foreach { x => attr = scala.xml.Attribute(null, "symbol", x.toString, attr) }
        case ("@separator", _) => __obj.separator foreach { x => attr = scala.xml.Attribute(null, "separator", x.toString, attr) }
        case ("@default-x", _) => __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.bigDecimal.toPlainString, attr) }
        case ("@default-y", _) => __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.bigDecimal.toPlainString, attr) }
        case ("@relative-x", _) => __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.bigDecimal.toPlainString, attr) }
        case ("@relative-y", _) => __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.bigDecimal.toPlainString, attr) }
        case ("@font-family", _) => __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
        case ("@font-style", _) => __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
        case ("@font-size", _) => __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
        case ("@font-weight", _) => __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
        case ("@color", _) => __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
        case ("@halign", _) => __obj.halign foreach { x => attr = scala.xml.Attribute(null, "halign", x.toString, attr) }
        case ("@valign", _) => __obj.valign foreach { x => attr = scala.xml.Attribute(null, "valign", x.toString, attr) }
        case ("@print-object", _) => __obj.printu45object foreach { x => attr = scala.xml.Attribute(null, "print-object", x.toString, attr) }
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Time, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      ((Some(__obj.timeoption) map {x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false)}).get)
  }

  trait DefaultMusicxml_TimeSequence1Format extends scalaxb.XMLFormat[musicxml.TimeSequence1] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.TimeSequence1] = Left("don't call me.")
    
    def writes(__obj: musicxml.TimeSequence1, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(__obj.timeu45signatureSequence1 flatMap { scalaxb.toXML[musicxml.Timeu45signatureSequence](_, None, Some("timeu45signatureSequence1"), __scope, false) },
        __obj.interchangeable map { scalaxb.toXML[musicxml.Interchangeable](_, None, Some("interchangeable"), __scope, false) } getOrElse {Nil})


  }

  trait DefaultMusicxml_TransposeFormat extends scalaxb.ElemNameParser[musicxml.Transpose] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("transpose")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[musicxml.Transpose] =
      phrase(opt(scalaxb.ElemName(None, "diatonic")) ~ 
      (scalaxb.ElemName(None, "chromatic")) ~ 
      opt(scalaxb.ElemName(None, "octave-change")) ~ 
      opt(scalaxb.ElemName(None, "double")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      musicxml.Transpose(p1.headOption map { scalaxb.fromXML[BigInt](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[BigDecimal](p2, scalaxb.ElemName(node) :: stack),
        p3.headOption map { scalaxb.fromXML[BigInt](_, scalaxb.ElemName(node) :: stack) },
        p4.headOption map { scalaxb.fromXML[musicxml.Empty](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@number").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigInt](x, scalaxb.ElemName(node) :: stack)) } map { "@number" -> _ },
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: musicxml.Transpose, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@number", _) => __obj.number foreach { x => attr = scala.xml.Attribute(null, "number", x.toString, attr) }
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Transpose, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.diatonic map { scalaxb.toXML[BigInt](_, None, Some("diatonic"), __scope, false) } getOrElse {Nil},
        scalaxb.toXML[BigDecimal](__obj.chromatic, None, Some("chromatic"), __scope, false),
        __obj.octaveu45change map { scalaxb.toXML[BigInt](_, None, Some("octave-change"), __scope, false) } getOrElse {Nil},
        __obj.double map { scalaxb.toXML[musicxml.Empty](_, None, Some("double"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultMusicxml_Baru45styleu45colorFormat extends scalaxb.XMLFormat[musicxml.Baru45styleu45color] with scalaxb.CanWriteChildNodes[musicxml.Baru45styleu45color] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Baru45styleu45color] = seq match {
      case node: scala.xml.Node => Right(musicxml.Baru45styleu45color(scalaxb.fromXML[musicxml.Baru45style](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@color").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@color" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Baru45styleu45color, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@color", _) => __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Baru45styleu45color, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultMusicxml_BarlineFormat extends scalaxb.ElemNameParser[musicxml.Barline] with Musicxml_EditorialGroupFormat {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("barline")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[musicxml.Barline] =
      phrase(opt(scalaxb.ElemName(None, "bar-style")) ~ 
      (parseEditorialGroup(node, scalaxb.ElemName(node) :: stack)) ~ 
      opt(scalaxb.ElemName(None, "wavy-line")) ~ 
      opt(scalaxb.ElemName(None, "segno")) ~ 
      opt(scalaxb.ElemName(None, "coda")) ~ 
      safeRep(scalaxb.ElemName(None, "fermata")) ~ 
      opt(scalaxb.ElemName(None, "ending")) ~ 
      opt(scalaxb.ElemName(None, "repeat")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 =>
      musicxml.Barline(p1.headOption map { scalaxb.fromXML[musicxml.Baru45styleu45color](_, scalaxb.ElemName(node) :: stack) },
        p2,
        p3.headOption map { scalaxb.fromXML[musicxml.Wavyu45line](_, scalaxb.ElemName(node) :: stack) },
        p4.headOption map { scalaxb.fromXML[musicxml.Segno](_, scalaxb.ElemName(node) :: stack) },
        p5.headOption map { scalaxb.fromXML[musicxml.Coda](_, scalaxb.ElemName(node) :: stack) },
        p6 map { scalaxb.fromXML[musicxml.Fermata](_, scalaxb.ElemName(node) :: stack) },
        p7.headOption map { scalaxb.fromXML[musicxml.Ending](_, scalaxb.ElemName(node) :: stack) },
        p8.headOption map { scalaxb.fromXML[musicxml.Repeat](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@location").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Rightu45leftu45middle](x, scalaxb.ElemName(node) :: stack)) } orElse Some(scalaxb.DataRecord(None, None, scalaxb.fromXML[musicxml.Rightu45leftu45middle](scala.xml.Text("right"), scalaxb.ElemName(node) :: stack))) map { "@location" -> _ },
        (node \ "@segno").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@segno" -> _ },
        (node \ "@coda").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@coda" -> _ },
        (node \ "@divisions").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@divisions" -> _ },
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: musicxml.Barline, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@location", _) => if (__obj.location.toString != "right") attr = scala.xml.Attribute(null, "location", __obj.location.toString, attr)
        case ("@segno", _) => __obj.segno foreach { x => attr = scala.xml.Attribute(null, "segno", x.toString, attr) }
        case ("@coda", _) => __obj.coda foreach { x => attr = scala.xml.Attribute(null, "coda", x.toString, attr) }
        case ("@divisions", _) => __obj.divisions foreach { x => attr = scala.xml.Attribute(null, "divisions", x.bigDecimal.toPlainString, attr) }
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Barline, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.baru45style map { scalaxb.toXML[musicxml.Baru45styleu45color](_, None, Some("bar-style"), __scope, false) } getOrElse {Nil},
        scalaxb.toXML[musicxml.EditorialSequence](__obj.editorialSequence2, None, Some("editorialSequence2"), __scope, false),
        __obj.wavyu45line map { scalaxb.toXML[musicxml.Wavyu45line](_, None, Some("wavy-line"), __scope, false) } getOrElse {Nil},
        __obj.segno2 map { scalaxb.toXML[musicxml.Segno](_, None, Some("segno"), __scope, false) } getOrElse {Nil},
        __obj.coda2 map { scalaxb.toXML[musicxml.Coda](_, None, Some("coda"), __scope, false) } getOrElse {Nil},
        __obj.fermata flatMap { scalaxb.toXML[musicxml.Fermata](_, None, Some("fermata"), __scope, false) },
        __obj.ending map { scalaxb.toXML[musicxml.Ending](_, None, Some("ending"), __scope, false) } getOrElse {Nil},
        __obj.repeat map { scalaxb.toXML[musicxml.Repeat](_, None, Some("repeat"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultMusicxml_EndingFormat extends scalaxb.XMLFormat[musicxml.Ending] with scalaxb.CanWriteChildNodes[musicxml.Ending] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Ending] = seq match {
      case node: scala.xml.Node => Right(musicxml.Ending(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@number").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@number" -> _ },
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Startu45stopu45discontinue](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ },
        (node \ "@print-object").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Yesu45no](x, scalaxb.ElemName(node) :: stack)) } map { "@print-object" -> _ },
        (node \ "@default-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-x" -> _ },
        (node \ "@default-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-y" -> _ },
        (node \ "@relative-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-x" -> _ },
        (node \ "@relative-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-y" -> _ },
        (node \ "@font-family").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-family" -> _ },
        (node \ "@font-style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45style](x, scalaxb.ElemName(node) :: stack)) } map { "@font-style" -> _ },
        (node \ "@font-size").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-size" -> _ },
        (node \ "@font-weight").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45weight](x, scalaxb.ElemName(node) :: stack)) } map { "@font-weight" -> _ },
        (node \ "@color").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@color" -> _ },
        (node \ "@end-length").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@end-length" -> _ },
        (node \ "@text-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@text-x" -> _ },
        (node \ "@text-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@text-y" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Ending, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@number", _) => attr = scala.xml.Attribute(null, "number", __obj.number.toString, attr)
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case ("@print-object", _) => __obj.printu45object foreach { x => attr = scala.xml.Attribute(null, "print-object", x.toString, attr) }
        case ("@default-x", _) => __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.bigDecimal.toPlainString, attr) }
        case ("@default-y", _) => __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.bigDecimal.toPlainString, attr) }
        case ("@relative-x", _) => __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.bigDecimal.toPlainString, attr) }
        case ("@relative-y", _) => __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.bigDecimal.toPlainString, attr) }
        case ("@font-family", _) => __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
        case ("@font-style", _) => __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
        case ("@font-size", _) => __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
        case ("@font-weight", _) => __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
        case ("@color", _) => __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
        case ("@end-length", _) => __obj.endu45length foreach { x => attr = scala.xml.Attribute(null, "end-length", x.bigDecimal.toPlainString, attr) }
        case ("@text-x", _) => __obj.textu45x foreach { x => attr = scala.xml.Attribute(null, "text-x", x.bigDecimal.toPlainString, attr) }
        case ("@text-y", _) => __obj.textu45y foreach { x => attr = scala.xml.Attribute(null, "text-y", x.bigDecimal.toPlainString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Ending, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultMusicxml_RepeatFormat extends scalaxb.XMLFormat[musicxml.Repeat] with scalaxb.CanWriteChildNodes[musicxml.Repeat] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Repeat] = seq match {
      case node: scala.xml.Node => Right(musicxml.Repeat(scala.collection.immutable.ListMap(List(
        (node \ "@direction").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Backwardu45forward](x, scalaxb.ElemName(node) :: stack)) } map { "@direction" -> _ },
        (node \ "@times").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigInt](x, scalaxb.ElemName(node) :: stack)) } map { "@times" -> _ },
        (node \ "@winged").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Winged](x, scalaxb.ElemName(node) :: stack)) } map { "@winged" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Repeat, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@direction", _) => attr = scala.xml.Attribute(null, "direction", __obj.direction.toString, attr)
        case ("@times", _) => __obj.times foreach { x => attr = scala.xml.Attribute(null, "times", x.toString, attr) }
        case ("@winged", _) => __obj.winged foreach { x => attr = scala.xml.Attribute(null, "winged", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Repeat, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil

  }

  trait DefaultMusicxml_AccordFormat extends scalaxb.ElemNameParser[musicxml.Accord] with Musicxml_TuningGroupFormat {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("accord")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[musicxml.Accord] =
      phrase((parseTuningGroup(node, scalaxb.ElemName(node) :: stack)) ^^
      { case p1 =>
      musicxml.Accord(p1,
        scala.collection.immutable.ListMap(List(
        (node \ "@string").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigInt](x, scalaxb.ElemName(node) :: stack)) } map { "@string" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: musicxml.Accord, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@string", _) => __obj.string foreach { x => attr = scala.xml.Attribute(null, "string", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Accord, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (scalaxb.toXML[musicxml.TuningSequence](__obj.tuningSequence1, None, Some("tuningSequence1"), __scope, false))
  }

  trait DefaultMusicxml_Accordionu45registrationFormat extends scalaxb.ElemNameParser[musicxml.Accordionu45registration] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("accordion-registration")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[musicxml.Accordionu45registration] =
      phrase(opt(scalaxb.ElemName(None, "accordion-high")) ~ 
      opt(scalaxb.ElemName(None, "accordion-middle")) ~ 
      opt(scalaxb.ElemName(None, "accordion-low")) ^^
      { case p1 ~ p2 ~ p3 =>
      musicxml.Accordionu45registration(p1.headOption map { scalaxb.fromXML[musicxml.Empty](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[BigInt](_, scalaxb.ElemName(node) :: stack) },
        p3.headOption map { scalaxb.fromXML[musicxml.Empty](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@default-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-x" -> _ },
        (node \ "@default-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-y" -> _ },
        (node \ "@relative-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-x" -> _ },
        (node \ "@relative-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-y" -> _ },
        (node \ "@font-family").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-family" -> _ },
        (node \ "@font-style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45style](x, scalaxb.ElemName(node) :: stack)) } map { "@font-style" -> _ },
        (node \ "@font-size").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-size" -> _ },
        (node \ "@font-weight").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45weight](x, scalaxb.ElemName(node) :: stack)) } map { "@font-weight" -> _ },
        (node \ "@color").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@color" -> _ },
        (node \ "@halign").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Leftu45centeru45right](x, scalaxb.ElemName(node) :: stack)) } map { "@halign" -> _ },
        (node \ "@valign").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Valign](x, scalaxb.ElemName(node) :: stack)) } map { "@valign" -> _ },
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: musicxml.Accordionu45registration, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@default-x", _) => __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.bigDecimal.toPlainString, attr) }
        case ("@default-y", _) => __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.bigDecimal.toPlainString, attr) }
        case ("@relative-x", _) => __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.bigDecimal.toPlainString, attr) }
        case ("@relative-y", _) => __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.bigDecimal.toPlainString, attr) }
        case ("@font-family", _) => __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
        case ("@font-style", _) => __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
        case ("@font-size", _) => __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
        case ("@font-weight", _) => __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
        case ("@color", _) => __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
        case ("@halign", _) => __obj.halign foreach { x => attr = scala.xml.Attribute(null, "halign", x.toString, attr) }
        case ("@valign", _) => __obj.valign foreach { x => attr = scala.xml.Attribute(null, "valign", x.toString, attr) }
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Accordionu45registration, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.accordionu45high map { scalaxb.toXML[musicxml.Empty](_, None, Some("accordion-high"), __scope, false) } getOrElse {Nil},
        __obj.accordionu45middle map { scalaxb.toXML[BigInt](_, None, Some("accordion-middle"), __scope, false) } getOrElse {Nil},
        __obj.accordionu45low map { scalaxb.toXML[musicxml.Empty](_, None, Some("accordion-low"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultMusicxml_BarreFormat extends scalaxb.XMLFormat[musicxml.Barre] with scalaxb.CanWriteChildNodes[musicxml.Barre] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Barre] = seq match {
      case node: scala.xml.Node => Right(musicxml.Barre(scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Startu45stop](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ },
        (node \ "@color").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@color" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Barre, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case ("@color", _) => __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Barre, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil

  }

  trait DefaultMusicxml_BassFormat extends scalaxb.ElemNameParser[musicxml.Bass] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("bass")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[musicxml.Bass] =
      phrase((scalaxb.ElemName(None, "bass-step")) ~ 
      opt(scalaxb.ElemName(None, "bass-alter")) ^^
      { case p1 ~ p2 =>
      musicxml.Bass(scalaxb.fromXML[musicxml.Bassu45step](p1, scalaxb.ElemName(node) :: stack),
        p2.headOption map { scalaxb.fromXML[musicxml.Bassu45alter](_, scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: musicxml.Bass, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(scalaxb.toXML[musicxml.Bassu45step](__obj.bassu45step, None, Some("bass-step"), __scope, false),
        __obj.bassu45alter map { scalaxb.toXML[musicxml.Bassu45alter](_, None, Some("bass-alter"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultMusicxml_Bassu45alterFormat extends scalaxb.XMLFormat[musicxml.Bassu45alter] with scalaxb.CanWriteChildNodes[musicxml.Bassu45alter] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Bassu45alter] = seq match {
      case node: scala.xml.Node => Right(musicxml.Bassu45alter(scalaxb.fromXML[BigDecimal](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@print-object").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Yesu45no](x, scalaxb.ElemName(node) :: stack)) } map { "@print-object" -> _ },
        (node \ "@default-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-x" -> _ },
        (node \ "@default-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-y" -> _ },
        (node \ "@relative-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-x" -> _ },
        (node \ "@relative-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-y" -> _ },
        (node \ "@font-family").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-family" -> _ },
        (node \ "@font-style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45style](x, scalaxb.ElemName(node) :: stack)) } map { "@font-style" -> _ },
        (node \ "@font-size").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-size" -> _ },
        (node \ "@font-weight").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45weight](x, scalaxb.ElemName(node) :: stack)) } map { "@font-weight" -> _ },
        (node \ "@color").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@color" -> _ },
        (node \ "@location").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Leftu45right](x, scalaxb.ElemName(node) :: stack)) } map { "@location" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Bassu45alter, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@print-object", _) => __obj.printu45object foreach { x => attr = scala.xml.Attribute(null, "print-object", x.toString, attr) }
        case ("@default-x", _) => __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.bigDecimal.toPlainString, attr) }
        case ("@default-y", _) => __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.bigDecimal.toPlainString, attr) }
        case ("@relative-x", _) => __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.bigDecimal.toPlainString, attr) }
        case ("@relative-y", _) => __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.bigDecimal.toPlainString, attr) }
        case ("@font-family", _) => __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
        case ("@font-style", _) => __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
        case ("@font-size", _) => __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
        case ("@font-weight", _) => __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
        case ("@color", _) => __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
        case ("@location", _) => __obj.location foreach { x => attr = scala.xml.Attribute(null, "location", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Bassu45alter, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultMusicxml_Bassu45stepFormat extends scalaxb.XMLFormat[musicxml.Bassu45step] with scalaxb.CanWriteChildNodes[musicxml.Bassu45step] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Bassu45step] = seq match {
      case node: scala.xml.Node => Right(musicxml.Bassu45step(scalaxb.fromXML[musicxml.Step](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@text").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@text" -> _ },
        (node \ "@default-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-x" -> _ },
        (node \ "@default-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-y" -> _ },
        (node \ "@relative-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-x" -> _ },
        (node \ "@relative-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-y" -> _ },
        (node \ "@font-family").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-family" -> _ },
        (node \ "@font-style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45style](x, scalaxb.ElemName(node) :: stack)) } map { "@font-style" -> _ },
        (node \ "@font-size").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-size" -> _ },
        (node \ "@font-weight").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45weight](x, scalaxb.ElemName(node) :: stack)) } map { "@font-weight" -> _ },
        (node \ "@color").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@color" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Bassu45step, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@text", _) => __obj.text foreach { x => attr = scala.xml.Attribute(null, "text", x.toString, attr) }
        case ("@default-x", _) => __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.bigDecimal.toPlainString, attr) }
        case ("@default-y", _) => __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.bigDecimal.toPlainString, attr) }
        case ("@relative-x", _) => __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.bigDecimal.toPlainString, attr) }
        case ("@relative-y", _) => __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.bigDecimal.toPlainString, attr) }
        case ("@font-family", _) => __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
        case ("@font-style", _) => __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
        case ("@font-size", _) => __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
        case ("@font-weight", _) => __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
        case ("@color", _) => __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Bassu45step, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultMusicxml_BeaterFormat extends scalaxb.XMLFormat[musicxml.Beater] with scalaxb.CanWriteChildNodes[musicxml.Beater] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Beater] = seq match {
      case node: scala.xml.Node => Right(musicxml.Beater(scalaxb.fromXML[musicxml.Beateru45value](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@tip").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Tipu45direction](x, scalaxb.ElemName(node) :: stack)) } map { "@tip" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Beater, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@tip", _) => __obj.tip foreach { x => attr = scala.xml.Attribute(null, "tip", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Beater, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultMusicxml_Beatu45unitu45tiedFormat extends scalaxb.ElemNameParser[musicxml.Beatu45unitu45tied] with Musicxml_Beatu45unitGroupFormat {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("beat-unit-tied")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[musicxml.Beatu45unitu45tied] =
      phrase((parseBeatu45unitGroup(node, scalaxb.ElemName(node) :: stack)) ^^
      { case p1 =>
      musicxml.Beatu45unitu45tied(p1) })
    
    def writesChildNodes(__obj: musicxml.Beatu45unitu45tied, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (scalaxb.toXML[musicxml.Beatu45unitSequence](__obj.beatu45unitSequence1, None, Some("beatu45unitSequence1"), __scope, false))
  }

  trait DefaultMusicxml_BracketFormat extends scalaxb.XMLFormat[musicxml.Bracket] with scalaxb.CanWriteChildNodes[musicxml.Bracket] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Bracket] = seq match {
      case node: scala.xml.Node => Right(musicxml.Bracket(scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Startu45stopu45continue](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ },
        (node \ "@number").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigInt](x, scalaxb.ElemName(node) :: stack)) } map { "@number" -> _ },
        (node \ "@line-end").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Lineu45end](x, scalaxb.ElemName(node) :: stack)) } map { "@line-end" -> _ },
        (node \ "@end-length").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@end-length" -> _ },
        (node \ "@line-type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Lineu45type](x, scalaxb.ElemName(node) :: stack)) } map { "@line-type" -> _ },
        (node \ "@dash-length").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@dash-length" -> _ },
        (node \ "@space-length").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@space-length" -> _ },
        (node \ "@default-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-x" -> _ },
        (node \ "@default-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-y" -> _ },
        (node \ "@relative-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-x" -> _ },
        (node \ "@relative-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-y" -> _ },
        (node \ "@color").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@color" -> _ },
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Bracket, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case ("@number", _) => __obj.number foreach { x => attr = scala.xml.Attribute(null, "number", x.toString, attr) }
        case ("@line-end", _) => attr = scala.xml.Attribute(null, "line-end", __obj.lineu45end.toString, attr)
        case ("@end-length", _) => __obj.endu45length foreach { x => attr = scala.xml.Attribute(null, "end-length", x.bigDecimal.toPlainString, attr) }
        case ("@line-type", _) => __obj.lineu45type foreach { x => attr = scala.xml.Attribute(null, "line-type", x.toString, attr) }
        case ("@dash-length", _) => __obj.dashu45length foreach { x => attr = scala.xml.Attribute(null, "dash-length", x.bigDecimal.toPlainString, attr) }
        case ("@space-length", _) => __obj.spaceu45length foreach { x => attr = scala.xml.Attribute(null, "space-length", x.bigDecimal.toPlainString, attr) }
        case ("@default-x", _) => __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.bigDecimal.toPlainString, attr) }
        case ("@default-y", _) => __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.bigDecimal.toPlainString, attr) }
        case ("@relative-x", _) => __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.bigDecimal.toPlainString, attr) }
        case ("@relative-y", _) => __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.bigDecimal.toPlainString, attr) }
        case ("@color", _) => __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Bracket, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil

  }

  trait DefaultMusicxml_DashesFormat extends scalaxb.XMLFormat[musicxml.Dashes] with scalaxb.CanWriteChildNodes[musicxml.Dashes] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Dashes] = seq match {
      case node: scala.xml.Node => Right(musicxml.Dashes(scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Startu45stopu45continue](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ },
        (node \ "@number").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigInt](x, scalaxb.ElemName(node) :: stack)) } map { "@number" -> _ },
        (node \ "@dash-length").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@dash-length" -> _ },
        (node \ "@space-length").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@space-length" -> _ },
        (node \ "@default-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-x" -> _ },
        (node \ "@default-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-y" -> _ },
        (node \ "@relative-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-x" -> _ },
        (node \ "@relative-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-y" -> _ },
        (node \ "@color").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@color" -> _ },
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Dashes, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case ("@number", _) => __obj.number foreach { x => attr = scala.xml.Attribute(null, "number", x.toString, attr) }
        case ("@dash-length", _) => __obj.dashu45length foreach { x => attr = scala.xml.Attribute(null, "dash-length", x.bigDecimal.toPlainString, attr) }
        case ("@space-length", _) => __obj.spaceu45length foreach { x => attr = scala.xml.Attribute(null, "space-length", x.bigDecimal.toPlainString, attr) }
        case ("@default-x", _) => __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.bigDecimal.toPlainString, attr) }
        case ("@default-y", _) => __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.bigDecimal.toPlainString, attr) }
        case ("@relative-x", _) => __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.bigDecimal.toPlainString, attr) }
        case ("@relative-y", _) => __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.bigDecimal.toPlainString, attr) }
        case ("@color", _) => __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Dashes, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil

  }

  trait DefaultMusicxml_DegreeFormat extends scalaxb.ElemNameParser[musicxml.Degree] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("degree")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[musicxml.Degree] =
      phrase((scalaxb.ElemName(None, "degree-value")) ~ 
      (scalaxb.ElemName(None, "degree-alter")) ~ 
      (scalaxb.ElemName(None, "degree-type")) ^^
      { case p1 ~ p2 ~ p3 =>
      musicxml.Degree(scalaxb.fromXML[musicxml.Degreeu45value](p1, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[musicxml.Degreeu45alter](p2, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[musicxml.Degreeu45type](p3, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@print-object").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Yesu45no](x, scalaxb.ElemName(node) :: stack)) } map { "@print-object" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: musicxml.Degree, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@print-object", _) => __obj.printu45object foreach { x => attr = scala.xml.Attribute(null, "print-object", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Degree, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(scalaxb.toXML[musicxml.Degreeu45value](__obj.degreeu45value, None, Some("degree-value"), __scope, false),
        scalaxb.toXML[musicxml.Degreeu45alter](__obj.degreeu45alter, None, Some("degree-alter"), __scope, false),
        scalaxb.toXML[musicxml.Degreeu45type](__obj.degreeu45type, None, Some("degree-type"), __scope, false))

  }

  trait DefaultMusicxml_Degreeu45alterFormat extends scalaxb.XMLFormat[musicxml.Degreeu45alter] with scalaxb.CanWriteChildNodes[musicxml.Degreeu45alter] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Degreeu45alter] = seq match {
      case node: scala.xml.Node => Right(musicxml.Degreeu45alter(scalaxb.fromXML[BigDecimal](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@default-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-x" -> _ },
        (node \ "@default-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-y" -> _ },
        (node \ "@relative-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-x" -> _ },
        (node \ "@relative-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-y" -> _ },
        (node \ "@font-family").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-family" -> _ },
        (node \ "@font-style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45style](x, scalaxb.ElemName(node) :: stack)) } map { "@font-style" -> _ },
        (node \ "@font-size").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-size" -> _ },
        (node \ "@font-weight").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45weight](x, scalaxb.ElemName(node) :: stack)) } map { "@font-weight" -> _ },
        (node \ "@color").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@color" -> _ },
        (node \ "@plus-minus").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Yesu45no](x, scalaxb.ElemName(node) :: stack)) } map { "@plus-minus" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Degreeu45alter, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@default-x", _) => __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.bigDecimal.toPlainString, attr) }
        case ("@default-y", _) => __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.bigDecimal.toPlainString, attr) }
        case ("@relative-x", _) => __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.bigDecimal.toPlainString, attr) }
        case ("@relative-y", _) => __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.bigDecimal.toPlainString, attr) }
        case ("@font-family", _) => __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
        case ("@font-style", _) => __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
        case ("@font-size", _) => __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
        case ("@font-weight", _) => __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
        case ("@color", _) => __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
        case ("@plus-minus", _) => __obj.plusu45minus foreach { x => attr = scala.xml.Attribute(null, "plus-minus", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Degreeu45alter, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultMusicxml_Degreeu45typeFormat extends scalaxb.XMLFormat[musicxml.Degreeu45type] with scalaxb.CanWriteChildNodes[musicxml.Degreeu45type] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Degreeu45type] = seq match {
      case node: scala.xml.Node => Right(musicxml.Degreeu45type(scalaxb.fromXML[musicxml.Degreeu45typeu45value](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@text").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@text" -> _ },
        (node \ "@default-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-x" -> _ },
        (node \ "@default-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-y" -> _ },
        (node \ "@relative-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-x" -> _ },
        (node \ "@relative-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-y" -> _ },
        (node \ "@font-family").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-family" -> _ },
        (node \ "@font-style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45style](x, scalaxb.ElemName(node) :: stack)) } map { "@font-style" -> _ },
        (node \ "@font-size").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-size" -> _ },
        (node \ "@font-weight").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45weight](x, scalaxb.ElemName(node) :: stack)) } map { "@font-weight" -> _ },
        (node \ "@color").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@color" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Degreeu45type, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@text", _) => __obj.text foreach { x => attr = scala.xml.Attribute(null, "text", x.toString, attr) }
        case ("@default-x", _) => __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.bigDecimal.toPlainString, attr) }
        case ("@default-y", _) => __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.bigDecimal.toPlainString, attr) }
        case ("@relative-x", _) => __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.bigDecimal.toPlainString, attr) }
        case ("@relative-y", _) => __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.bigDecimal.toPlainString, attr) }
        case ("@font-family", _) => __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
        case ("@font-style", _) => __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
        case ("@font-size", _) => __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
        case ("@font-weight", _) => __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
        case ("@color", _) => __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Degreeu45type, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultMusicxml_Degreeu45valueFormat extends scalaxb.XMLFormat[musicxml.Degreeu45value] with scalaxb.CanWriteChildNodes[musicxml.Degreeu45value] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Degreeu45value] = seq match {
      case node: scala.xml.Node => Right(musicxml.Degreeu45value(scalaxb.fromXML[BigInt](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@symbol").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Degreeu45symbolu45value](x, scalaxb.ElemName(node) :: stack)) } map { "@symbol" -> _ },
        (node \ "@text").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@text" -> _ },
        (node \ "@default-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-x" -> _ },
        (node \ "@default-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-y" -> _ },
        (node \ "@relative-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-x" -> _ },
        (node \ "@relative-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-y" -> _ },
        (node \ "@font-family").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-family" -> _ },
        (node \ "@font-style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45style](x, scalaxb.ElemName(node) :: stack)) } map { "@font-style" -> _ },
        (node \ "@font-size").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-size" -> _ },
        (node \ "@font-weight").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45weight](x, scalaxb.ElemName(node) :: stack)) } map { "@font-weight" -> _ },
        (node \ "@color").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@color" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Degreeu45value, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@symbol", _) => __obj.symbol foreach { x => attr = scala.xml.Attribute(null, "symbol", x.toString, attr) }
        case ("@text", _) => __obj.text foreach { x => attr = scala.xml.Attribute(null, "text", x.toString, attr) }
        case ("@default-x", _) => __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.bigDecimal.toPlainString, attr) }
        case ("@default-y", _) => __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.bigDecimal.toPlainString, attr) }
        case ("@relative-x", _) => __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.bigDecimal.toPlainString, attr) }
        case ("@relative-y", _) => __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.bigDecimal.toPlainString, attr) }
        case ("@font-family", _) => __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
        case ("@font-style", _) => __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
        case ("@font-size", _) => __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
        case ("@font-weight", _) => __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
        case ("@color", _) => __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Degreeu45value, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultMusicxml_DirectionFormat extends scalaxb.ElemNameParser[musicxml.Direction] with Musicxml_Editorialu45voiceu45directionGroupFormat with Musicxml_StaffGroupFormat {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("direction")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[musicxml.Direction] =
      phrase(safeRep(scalaxb.ElemName(None, "direction-type")) ~ 
      opt(scalaxb.ElemName(None, "offset")) ~ 
      (parseEditorialu45voiceu45directionGroup(node, scalaxb.ElemName(node) :: stack)) ~ 
      opt(parseStaffGroup(node, scalaxb.ElemName(node) :: stack)) ~ 
      opt(scalaxb.ElemName(None, "sound")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 =>
      musicxml.Direction(p1 map { scalaxb.fromXML[musicxml.Directionu45type](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[musicxml.Offset](_, scalaxb.ElemName(node) :: stack) },
        p3,
        p4,
        p5.headOption map { scalaxb.fromXML[musicxml.Sound](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@placement").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Aboveu45below](x, scalaxb.ElemName(node) :: stack)) } map { "@placement" -> _ },
        (node \ "@directive").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Yesu45no](x, scalaxb.ElemName(node) :: stack)) } map { "@directive" -> _ },
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: musicxml.Direction, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@placement", _) => __obj.placement foreach { x => attr = scala.xml.Attribute(null, "placement", x.toString, attr) }
        case ("@directive", _) => __obj.directive foreach { x => attr = scala.xml.Attribute(null, "directive", x.toString, attr) }
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Direction, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.directionu45type flatMap { scalaxb.toXML[musicxml.Directionu45type](_, None, Some("direction-type"), __scope, false) },
        __obj.offset map { scalaxb.toXML[musicxml.Offset](_, None, Some("offset"), __scope, false) } getOrElse {Nil},
        scalaxb.toXML[musicxml.Editorialu45voiceu45directionSequence](__obj.editorialu45voiceu45directionSequence3, None, Some("editorialu45voiceu45directionSequence3"), __scope, false),
        __obj.staffSequence4 map { scalaxb.toXML[musicxml.StaffSequence](_, None, Some("staffSequence4"), __scope, false) } getOrElse {Nil},
        __obj.sound map { scalaxb.toXML[musicxml.Sound](_, None, Some("sound"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultMusicxml_Directionu45typeFormat extends scalaxb.ElemNameParser[musicxml.Directionu45type] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("direction-type")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[musicxml.Directionu45type] =
      phrase(safeRep(((scalaxb.ElemName(None, "rehearsal")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Formattedu45textu45id](x, scalaxb.ElemName(node) :: stack)))) ||| 
      ((scalaxb.ElemName(None, "segno")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Segno](x, scalaxb.ElemName(node) :: stack)))) ||| 
      ((scalaxb.ElemName(None, "coda")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Coda](x, scalaxb.ElemName(node) :: stack)))) ||| 
      (((scalaxb.ElemName(None, "words")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Formattedu45textu45id](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "symbol")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Formattedu45symbolu45id](x, scalaxb.ElemName(node) :: stack))))) ||| 
      ((scalaxb.ElemName(None, "wedge")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Wedge](x, scalaxb.ElemName(node) :: stack)))) ||| 
      ((scalaxb.ElemName(None, "dynamics")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Dynamics](x, scalaxb.ElemName(node) :: stack)))) ||| 
      ((scalaxb.ElemName(None, "dashes")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Dashes](x, scalaxb.ElemName(node) :: stack)))) ||| 
      ((scalaxb.ElemName(None, "bracket")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Bracket](x, scalaxb.ElemName(node) :: stack)))) ||| 
      ((scalaxb.ElemName(None, "pedal")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Pedal](x, scalaxb.ElemName(node) :: stack)))) ||| 
      ((scalaxb.ElemName(None, "metronome")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Metronome](x, scalaxb.ElemName(node) :: stack)))) ||| 
      ((scalaxb.ElemName(None, "octave-shift")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Octaveu45shift](x, scalaxb.ElemName(node) :: stack)))) ||| 
      ((scalaxb.ElemName(None, "harp-pedals")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Harpu45pedals](x, scalaxb.ElemName(node) :: stack)))) ||| 
      ((scalaxb.ElemName(None, "damp")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Emptyu45printu45styleu45alignu45id](x, scalaxb.ElemName(node) :: stack)))) ||| 
      ((scalaxb.ElemName(None, "damp-all")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Emptyu45printu45styleu45alignu45id](x, scalaxb.ElemName(node) :: stack)))) ||| 
      ((scalaxb.ElemName(None, "eyeglasses")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Emptyu45printu45styleu45alignu45id](x, scalaxb.ElemName(node) :: stack)))) ||| 
      ((scalaxb.ElemName(None, "string-mute")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Stringu45mute](x, scalaxb.ElemName(node) :: stack)))) ||| 
      ((scalaxb.ElemName(None, "scordatura")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Scordatura](x, scalaxb.ElemName(node) :: stack)))) ||| 
      ((scalaxb.ElemName(None, "image")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Image](x, scalaxb.ElemName(node) :: stack)))) ||| 
      ((scalaxb.ElemName(None, "principal-voice")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Principalu45voice](x, scalaxb.ElemName(node) :: stack)))) ||| 
      ((scalaxb.ElemName(None, "percussion")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.PercussionType](x, scalaxb.ElemName(node) :: stack)))) ||| 
      ((scalaxb.ElemName(None, "accordion-registration")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Accordionu45registration](x, scalaxb.ElemName(node) :: stack)))) ||| 
      ((scalaxb.ElemName(None, "staff-divide")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Staffu45divide](x, scalaxb.ElemName(node) :: stack)))) ||| 
      ((scalaxb.ElemName(None, "other-direction")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Otheru45direction](x, scalaxb.ElemName(node) :: stack))))) ^^
      { case p1 =>
      musicxml.Directionu45type(p1,
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: musicxml.Directionu45type, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Directionu45type, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.directionu45typeoption flatMap { x => scalaxb.toXML[scalaxb.DataRecord[musicxml.Directionu45typeOption]](x, x.namespace, x.key, __scope, false) })
  }

  trait DefaultMusicxml_FeatureFormat extends scalaxb.XMLFormat[musicxml.Feature] with scalaxb.CanWriteChildNodes[musicxml.Feature] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Feature] = seq match {
      case node: scala.xml.Node => Right(musicxml.Feature(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Feature, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => __obj.typeValue foreach { x => attr = scala.xml.Attribute(null, "type", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Feature, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultMusicxml_Firstu45fretFormat extends scalaxb.XMLFormat[musicxml.Firstu45fret] with scalaxb.CanWriteChildNodes[musicxml.Firstu45fret] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Firstu45fret] = seq match {
      case node: scala.xml.Node => Right(musicxml.Firstu45fret(scalaxb.fromXML[BigInt](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@text").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@text" -> _ },
        (node \ "@location").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Leftu45right](x, scalaxb.ElemName(node) :: stack)) } map { "@location" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Firstu45fret, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@text", _) => __obj.text foreach { x => attr = scala.xml.Attribute(null, "text", x.toString, attr) }
        case ("@location", _) => __obj.location foreach { x => attr = scala.xml.Attribute(null, "location", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Firstu45fret, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultMusicxml_FrameFormat extends scalaxb.ElemNameParser[musicxml.Frame] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("frame")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[musicxml.Frame] =
      phrase((scalaxb.ElemName(None, "frame-strings")) ~ 
      (scalaxb.ElemName(None, "frame-frets")) ~ 
      opt(scalaxb.ElemName(None, "first-fret")) ~ 
      safeRep(scalaxb.ElemName(None, "frame-note")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      musicxml.Frame(scalaxb.fromXML[BigInt](p1, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[BigInt](p2, scalaxb.ElemName(node) :: stack),
        p3.headOption map { scalaxb.fromXML[musicxml.Firstu45fret](_, scalaxb.ElemName(node) :: stack) },
        p4 map { scalaxb.fromXML[musicxml.Frameu45note](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@default-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-x" -> _ },
        (node \ "@default-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-y" -> _ },
        (node \ "@relative-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-x" -> _ },
        (node \ "@relative-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-y" -> _ },
        (node \ "@color").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@color" -> _ },
        (node \ "@halign").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Leftu45centeru45right](x, scalaxb.ElemName(node) :: stack)) } map { "@halign" -> _ },
        (node \ "@valign").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Valignu45image](x, scalaxb.ElemName(node) :: stack)) } map { "@valign" -> _ },
        (node \ "@height").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@height" -> _ },
        (node \ "@width").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@width" -> _ },
        (node \ "@unplayed").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@unplayed" -> _ },
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: musicxml.Frame, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@default-x", _) => __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.bigDecimal.toPlainString, attr) }
        case ("@default-y", _) => __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.bigDecimal.toPlainString, attr) }
        case ("@relative-x", _) => __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.bigDecimal.toPlainString, attr) }
        case ("@relative-y", _) => __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.bigDecimal.toPlainString, attr) }
        case ("@color", _) => __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
        case ("@halign", _) => __obj.halign foreach { x => attr = scala.xml.Attribute(null, "halign", x.toString, attr) }
        case ("@valign", _) => __obj.valign foreach { x => attr = scala.xml.Attribute(null, "valign", x.toString, attr) }
        case ("@height", _) => __obj.height foreach { x => attr = scala.xml.Attribute(null, "height", x.bigDecimal.toPlainString, attr) }
        case ("@width", _) => __obj.width foreach { x => attr = scala.xml.Attribute(null, "width", x.bigDecimal.toPlainString, attr) }
        case ("@unplayed", _) => __obj.unplayed foreach { x => attr = scala.xml.Attribute(null, "unplayed", x.toString, attr) }
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Frame, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(scalaxb.toXML[BigInt](__obj.frameu45strings, None, Some("frame-strings"), __scope, false),
        scalaxb.toXML[BigInt](__obj.frameu45frets, None, Some("frame-frets"), __scope, false),
        __obj.firstu45fret map { scalaxb.toXML[musicxml.Firstu45fret](_, None, Some("first-fret"), __scope, false) } getOrElse {Nil},
        __obj.frameu45note flatMap { scalaxb.toXML[musicxml.Frameu45note](_, None, Some("frame-note"), __scope, false) })

  }

  trait DefaultMusicxml_Frameu45noteFormat extends scalaxb.ElemNameParser[musicxml.Frameu45note] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("frame-note")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[musicxml.Frameu45note] =
      phrase((scalaxb.ElemName(None, "string")) ~ 
      (scalaxb.ElemName(None, "fret")) ~ 
      opt(scalaxb.ElemName(None, "fingering")) ~ 
      opt(scalaxb.ElemName(None, "barre")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      musicxml.Frameu45note(scalaxb.fromXML[musicxml.StringType](p1, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[musicxml.Fret](p2, scalaxb.ElemName(node) :: stack),
        p3.headOption map { scalaxb.fromXML[musicxml.Fingering](_, scalaxb.ElemName(node) :: stack) },
        p4.headOption map { scalaxb.fromXML[musicxml.Barre](_, scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: musicxml.Frameu45note, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(scalaxb.toXML[musicxml.StringType](__obj.string, None, Some("string"), __scope, false),
        scalaxb.toXML[musicxml.Fret](__obj.fret, None, Some("fret"), __scope, false),
        __obj.fingering map { scalaxb.toXML[musicxml.Fingering](_, None, Some("fingering"), __scope, false) } getOrElse {Nil},
        __obj.barre map { scalaxb.toXML[musicxml.Barre](_, None, Some("barre"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultMusicxml_GlassFormat extends scalaxb.XMLFormat[musicxml.Glass] with scalaxb.CanWriteChildNodes[musicxml.Glass] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Glass] = seq match {
      case node: scala.xml.Node => Right(musicxml.Glass(scalaxb.fromXML[musicxml.Glassu45value](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@smufl").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@smufl" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Glass, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@smufl", _) => __obj.smufl foreach { x => attr = scala.xml.Attribute(null, "smufl", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Glass, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultMusicxml_GroupingFormat extends scalaxb.ElemNameParser[musicxml.Grouping] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("grouping")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[musicxml.Grouping] =
      phrase(safeRep(scalaxb.ElemName(None, "feature")) ^^
      { case p1 =>
      musicxml.Grouping(p1 map { scalaxb.fromXML[musicxml.Feature](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Startu45stopu45single](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ },
        (node \ "@number").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } orElse Some(scalaxb.DataRecord(None, None, scalaxb.fromXML[String](scala.xml.Text("1"), scalaxb.ElemName(node) :: stack))) map { "@number" -> _ },
        (node \ "@member-of").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@member-of" -> _ },
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: musicxml.Grouping, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case ("@number", _) => if (__obj.number.toString != "1") attr = scala.xml.Attribute(null, "number", __obj.number.toString, attr)
        case ("@member-of", _) => __obj.memberu45of foreach { x => attr = scala.xml.Attribute(null, "member-of", x.toString, attr) }
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Grouping, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.feature flatMap { scalaxb.toXML[musicxml.Feature](_, None, Some("feature"), __scope, false) })
  }

  trait DefaultMusicxml_HarmonyFormat extends scalaxb.ElemNameParser[musicxml.Harmony] with Musicxml_Harmonyu45chordGroupFormat with Musicxml_EditorialGroupFormat with Musicxml_StaffGroupFormat {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("harmony")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[musicxml.Harmony] =
      phrase(safeRep(parseHarmonyu45chordGroup(node, scalaxb.ElemName(node) :: stack)) ~ 
      opt(scalaxb.ElemName(None, "frame")) ~ 
      opt(scalaxb.ElemName(None, "offset")) ~ 
      (parseEditorialGroup(node, scalaxb.ElemName(node) :: stack)) ~ 
      opt(parseStaffGroup(node, scalaxb.ElemName(node) :: stack)) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 =>
      musicxml.Harmony(p1,
        p2.headOption map { scalaxb.fromXML[musicxml.Frame](_, scalaxb.ElemName(node) :: stack) },
        p3.headOption map { scalaxb.fromXML[musicxml.Offset](_, scalaxb.ElemName(node) :: stack) },
        p4,
        p5,
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Harmonyu45type](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ },
        (node \ "@print-object").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Yesu45no](x, scalaxb.ElemName(node) :: stack)) } map { "@print-object" -> _ },
        (node \ "@print-frame").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Yesu45no](x, scalaxb.ElemName(node) :: stack)) } map { "@print-frame" -> _ },
        (node \ "@default-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-x" -> _ },
        (node \ "@default-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-y" -> _ },
        (node \ "@relative-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-x" -> _ },
        (node \ "@relative-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-y" -> _ },
        (node \ "@font-family").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-family" -> _ },
        (node \ "@font-style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45style](x, scalaxb.ElemName(node) :: stack)) } map { "@font-style" -> _ },
        (node \ "@font-size").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-size" -> _ },
        (node \ "@font-weight").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45weight](x, scalaxb.ElemName(node) :: stack)) } map { "@font-weight" -> _ },
        (node \ "@color").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@color" -> _ },
        (node \ "@placement").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Aboveu45below](x, scalaxb.ElemName(node) :: stack)) } map { "@placement" -> _ },
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: musicxml.Harmony, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => __obj.typeValue foreach { x => attr = scala.xml.Attribute(null, "type", x.toString, attr) }
        case ("@print-object", _) => __obj.printu45object foreach { x => attr = scala.xml.Attribute(null, "print-object", x.toString, attr) }
        case ("@print-frame", _) => __obj.printu45frame foreach { x => attr = scala.xml.Attribute(null, "print-frame", x.toString, attr) }
        case ("@default-x", _) => __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.bigDecimal.toPlainString, attr) }
        case ("@default-y", _) => __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.bigDecimal.toPlainString, attr) }
        case ("@relative-x", _) => __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.bigDecimal.toPlainString, attr) }
        case ("@relative-y", _) => __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.bigDecimal.toPlainString, attr) }
        case ("@font-family", _) => __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
        case ("@font-style", _) => __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
        case ("@font-size", _) => __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
        case ("@font-weight", _) => __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
        case ("@color", _) => __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
        case ("@placement", _) => __obj.placement foreach { x => attr = scala.xml.Attribute(null, "placement", x.toString, attr) }
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Harmony, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.harmonyu45chordSequence1 flatMap { scalaxb.toXML[musicxml.Harmonyu45chordSequence](_, None, Some("harmonyu45chordSequence1"), __scope, false) },
        __obj.frame map { scalaxb.toXML[musicxml.Frame](_, None, Some("frame"), __scope, false) } getOrElse {Nil},
        __obj.offset map { scalaxb.toXML[musicxml.Offset](_, None, Some("offset"), __scope, false) } getOrElse {Nil},
        scalaxb.toXML[musicxml.EditorialSequence](__obj.editorialSequence4, None, Some("editorialSequence4"), __scope, false),
        __obj.staffSequence5 map { scalaxb.toXML[musicxml.StaffSequence](_, None, Some("staffSequence5"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultMusicxml_Harpu45pedalsFormat extends scalaxb.ElemNameParser[musicxml.Harpu45pedals] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("harp-pedals")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[musicxml.Harpu45pedals] =
      phrase(safeRep(scalaxb.ElemName(None, "pedal-tuning")) ^^
      { case p1 =>
      musicxml.Harpu45pedals(p1 map { scalaxb.fromXML[musicxml.Pedalu45tuning](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@default-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-x" -> _ },
        (node \ "@default-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-y" -> _ },
        (node \ "@relative-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-x" -> _ },
        (node \ "@relative-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-y" -> _ },
        (node \ "@font-family").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-family" -> _ },
        (node \ "@font-style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45style](x, scalaxb.ElemName(node) :: stack)) } map { "@font-style" -> _ },
        (node \ "@font-size").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-size" -> _ },
        (node \ "@font-weight").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45weight](x, scalaxb.ElemName(node) :: stack)) } map { "@font-weight" -> _ },
        (node \ "@color").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@color" -> _ },
        (node \ "@halign").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Leftu45centeru45right](x, scalaxb.ElemName(node) :: stack)) } map { "@halign" -> _ },
        (node \ "@valign").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Valign](x, scalaxb.ElemName(node) :: stack)) } map { "@valign" -> _ },
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: musicxml.Harpu45pedals, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@default-x", _) => __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.bigDecimal.toPlainString, attr) }
        case ("@default-y", _) => __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.bigDecimal.toPlainString, attr) }
        case ("@relative-x", _) => __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.bigDecimal.toPlainString, attr) }
        case ("@relative-y", _) => __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.bigDecimal.toPlainString, attr) }
        case ("@font-family", _) => __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
        case ("@font-style", _) => __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
        case ("@font-size", _) => __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
        case ("@font-weight", _) => __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
        case ("@color", _) => __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
        case ("@halign", _) => __obj.halign foreach { x => attr = scala.xml.Attribute(null, "halign", x.toString, attr) }
        case ("@valign", _) => __obj.valign foreach { x => attr = scala.xml.Attribute(null, "valign", x.toString, attr) }
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Harpu45pedals, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.pedalu45tuning flatMap { scalaxb.toXML[musicxml.Pedalu45tuning](_, None, Some("pedal-tuning"), __scope, false) })
  }

  trait DefaultMusicxml_ImageFormat extends scalaxb.XMLFormat[musicxml.Image] with scalaxb.CanWriteChildNodes[musicxml.Image] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Image] = seq match {
      case node: scala.xml.Node => Right(musicxml.Image(scala.collection.immutable.ListMap(List(
        (node \ "@source").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[java.net.URI](x, scalaxb.ElemName(node) :: stack)) } map { "@source" -> _ },
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ },
        (node \ "@height").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@height" -> _ },
        (node \ "@width").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@width" -> _ },
        (node \ "@default-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-x" -> _ },
        (node \ "@default-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-y" -> _ },
        (node \ "@relative-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-x" -> _ },
        (node \ "@relative-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-y" -> _ },
        (node \ "@halign").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Leftu45centeru45right](x, scalaxb.ElemName(node) :: stack)) } map { "@halign" -> _ },
        (node \ "@valign").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Valignu45image](x, scalaxb.ElemName(node) :: stack)) } map { "@valign" -> _ },
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Image, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@source", _) => attr = scala.xml.Attribute(null, "source", __obj.source.toString, attr)
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case ("@height", _) => __obj.height foreach { x => attr = scala.xml.Attribute(null, "height", x.bigDecimal.toPlainString, attr) }
        case ("@width", _) => __obj.width foreach { x => attr = scala.xml.Attribute(null, "width", x.bigDecimal.toPlainString, attr) }
        case ("@default-x", _) => __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.bigDecimal.toPlainString, attr) }
        case ("@default-y", _) => __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.bigDecimal.toPlainString, attr) }
        case ("@relative-x", _) => __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.bigDecimal.toPlainString, attr) }
        case ("@relative-y", _) => __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.bigDecimal.toPlainString, attr) }
        case ("@halign", _) => __obj.halign foreach { x => attr = scala.xml.Attribute(null, "halign", x.toString, attr) }
        case ("@valign", _) => __obj.valign foreach { x => attr = scala.xml.Attribute(null, "valign", x.toString, attr) }
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Image, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil

  }

  trait DefaultMusicxml_InversionFormat extends scalaxb.XMLFormat[musicxml.Inversion] with scalaxb.CanWriteChildNodes[musicxml.Inversion] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Inversion] = seq match {
      case node: scala.xml.Node => Right(musicxml.Inversion(scalaxb.fromXML[BigInt](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@default-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-x" -> _ },
        (node \ "@default-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-y" -> _ },
        (node \ "@relative-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-x" -> _ },
        (node \ "@relative-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-y" -> _ },
        (node \ "@font-family").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-family" -> _ },
        (node \ "@font-style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45style](x, scalaxb.ElemName(node) :: stack)) } map { "@font-style" -> _ },
        (node \ "@font-size").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-size" -> _ },
        (node \ "@font-weight").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45weight](x, scalaxb.ElemName(node) :: stack)) } map { "@font-weight" -> _ },
        (node \ "@color").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@color" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Inversion, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@default-x", _) => __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.bigDecimal.toPlainString, attr) }
        case ("@default-y", _) => __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.bigDecimal.toPlainString, attr) }
        case ("@relative-x", _) => __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.bigDecimal.toPlainString, attr) }
        case ("@relative-y", _) => __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.bigDecimal.toPlainString, attr) }
        case ("@font-family", _) => __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
        case ("@font-style", _) => __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
        case ("@font-size", _) => __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
        case ("@font-weight", _) => __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
        case ("@color", _) => __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Inversion, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultMusicxml_KindFormat extends scalaxb.XMLFormat[musicxml.Kind] with scalaxb.CanWriteChildNodes[musicxml.Kind] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Kind] = seq match {
      case node: scala.xml.Node => Right(musicxml.Kind(scalaxb.fromXML[musicxml.Kindu45value](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@use-symbols").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Yesu45no](x, scalaxb.ElemName(node) :: stack)) } map { "@use-symbols" -> _ },
        (node \ "@text").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@text" -> _ },
        (node \ "@stack-degrees").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Yesu45no](x, scalaxb.ElemName(node) :: stack)) } map { "@stack-degrees" -> _ },
        (node \ "@parentheses-degrees").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Yesu45no](x, scalaxb.ElemName(node) :: stack)) } map { "@parentheses-degrees" -> _ },
        (node \ "@bracket-degrees").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Yesu45no](x, scalaxb.ElemName(node) :: stack)) } map { "@bracket-degrees" -> _ },
        (node \ "@default-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-x" -> _ },
        (node \ "@default-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-y" -> _ },
        (node \ "@relative-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-x" -> _ },
        (node \ "@relative-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-y" -> _ },
        (node \ "@font-family").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-family" -> _ },
        (node \ "@font-style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45style](x, scalaxb.ElemName(node) :: stack)) } map { "@font-style" -> _ },
        (node \ "@font-size").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-size" -> _ },
        (node \ "@font-weight").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45weight](x, scalaxb.ElemName(node) :: stack)) } map { "@font-weight" -> _ },
        (node \ "@color").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@color" -> _ },
        (node \ "@halign").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Leftu45centeru45right](x, scalaxb.ElemName(node) :: stack)) } map { "@halign" -> _ },
        (node \ "@valign").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Valign](x, scalaxb.ElemName(node) :: stack)) } map { "@valign" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Kind, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@use-symbols", _) => __obj.useu45symbols foreach { x => attr = scala.xml.Attribute(null, "use-symbols", x.toString, attr) }
        case ("@text", _) => __obj.text foreach { x => attr = scala.xml.Attribute(null, "text", x.toString, attr) }
        case ("@stack-degrees", _) => __obj.stacku45degrees foreach { x => attr = scala.xml.Attribute(null, "stack-degrees", x.toString, attr) }
        case ("@parentheses-degrees", _) => __obj.parenthesesu45degrees foreach { x => attr = scala.xml.Attribute(null, "parentheses-degrees", x.toString, attr) }
        case ("@bracket-degrees", _) => __obj.bracketu45degrees foreach { x => attr = scala.xml.Attribute(null, "bracket-degrees", x.toString, attr) }
        case ("@default-x", _) => __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.bigDecimal.toPlainString, attr) }
        case ("@default-y", _) => __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.bigDecimal.toPlainString, attr) }
        case ("@relative-x", _) => __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.bigDecimal.toPlainString, attr) }
        case ("@relative-y", _) => __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.bigDecimal.toPlainString, attr) }
        case ("@font-family", _) => __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
        case ("@font-style", _) => __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
        case ("@font-size", _) => __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
        case ("@font-weight", _) => __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
        case ("@color", _) => __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
        case ("@halign", _) => __obj.halign foreach { x => attr = scala.xml.Attribute(null, "halign", x.toString, attr) }
        case ("@valign", _) => __obj.valign foreach { x => attr = scala.xml.Attribute(null, "valign", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Kind, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultMusicxml_Measureu45numberingFormat extends scalaxb.XMLFormat[musicxml.Measureu45numbering] with scalaxb.CanWriteChildNodes[musicxml.Measureu45numbering] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Measureu45numbering] = seq match {
      case node: scala.xml.Node => Right(musicxml.Measureu45numbering(scalaxb.fromXML[musicxml.Measureu45numberingu45value](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@default-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-x" -> _ },
        (node \ "@default-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-y" -> _ },
        (node \ "@relative-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-x" -> _ },
        (node \ "@relative-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-y" -> _ },
        (node \ "@font-family").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-family" -> _ },
        (node \ "@font-style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45style](x, scalaxb.ElemName(node) :: stack)) } map { "@font-style" -> _ },
        (node \ "@font-size").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-size" -> _ },
        (node \ "@font-weight").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45weight](x, scalaxb.ElemName(node) :: stack)) } map { "@font-weight" -> _ },
        (node \ "@color").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@color" -> _ },
        (node \ "@halign").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Leftu45centeru45right](x, scalaxb.ElemName(node) :: stack)) } map { "@halign" -> _ },
        (node \ "@valign").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Valign](x, scalaxb.ElemName(node) :: stack)) } map { "@valign" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Measureu45numbering, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@default-x", _) => __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.bigDecimal.toPlainString, attr) }
        case ("@default-y", _) => __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.bigDecimal.toPlainString, attr) }
        case ("@relative-x", _) => __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.bigDecimal.toPlainString, attr) }
        case ("@relative-y", _) => __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.bigDecimal.toPlainString, attr) }
        case ("@font-family", _) => __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
        case ("@font-style", _) => __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
        case ("@font-size", _) => __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
        case ("@font-weight", _) => __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
        case ("@color", _) => __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
        case ("@halign", _) => __obj.halign foreach { x => attr = scala.xml.Attribute(null, "halign", x.toString, attr) }
        case ("@valign", _) => __obj.valign foreach { x => attr = scala.xml.Attribute(null, "valign", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Measureu45numbering, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultMusicxml_MetronomeFormat extends scalaxb.ElemNameParser[musicxml.Metronome] with Musicxml_Beatu45unitGroupFormat {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("metronome")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[musicxml.Metronome] =
      phrase(((((parseBeatu45unitGroup(node, scalaxb.ElemName(node) :: stack)) ~ 
      safeRep(scalaxb.ElemName(None, "beat-unit-tied")) ~ 
      (((scalaxb.ElemName(None, "per-minute")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Peru45minute](x, scalaxb.ElemName(node) :: stack)))) ||| 
      (((parseBeatu45unitGroup(node, scalaxb.ElemName(node) :: stack)) ~ 
      safeRep(scalaxb.ElemName(None, "beat-unit-tied"))) ^^ 
        { case p1 ~ p2 => scalaxb.DataRecord(musicxml.MetronomeSequence2(p1,
        p2 map { scalaxb.fromXML[musicxml.Beatu45unitu45tied](_, scalaxb.ElemName(node) :: stack) })) }))) ^^ 
        { case p1 ~ p2 ~ p3 => scalaxb.DataRecord(musicxml.MetronomeSequence1(p1,
        p2 map { scalaxb.fromXML[musicxml.Beatu45unitu45tied](_, scalaxb.ElemName(node) :: stack) },
        p3)) }) ||| 
      ((opt(scalaxb.ElemName(None, "metronome-arrows")) ~ 
      safeRep(scalaxb.ElemName(None, "metronome-note")) ~ 
      opt(((scalaxb.ElemName(None, "metronome-relation")) ~ 
      safeRep(scalaxb.ElemName(None, "metronome-note"))) ^^ 
        { case p1 ~ p2 => musicxml.MetronomeSequence4(scalaxb.fromXML[String](p1, scalaxb.ElemName(node) :: stack),
        p2 map { scalaxb.fromXML[musicxml.Metronomeu45note](_, scalaxb.ElemName(node) :: stack) }) })) ^^ 
        { case p1 ~ p2 ~ p3 => scalaxb.DataRecord(musicxml.MetronomeSequence3(p1.headOption map { scalaxb.fromXML[musicxml.Empty](_, scalaxb.ElemName(node) :: stack) },
        p2 map { scalaxb.fromXML[musicxml.Metronomeu45note](_, scalaxb.ElemName(node) :: stack) },
        p3)) })) ^^
      { case p1 =>
      musicxml.Metronome(p1,
        scala.collection.immutable.ListMap(List(
        (node \ "@default-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-x" -> _ },
        (node \ "@default-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-y" -> _ },
        (node \ "@relative-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-x" -> _ },
        (node \ "@relative-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-y" -> _ },
        (node \ "@font-family").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-family" -> _ },
        (node \ "@font-style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45style](x, scalaxb.ElemName(node) :: stack)) } map { "@font-style" -> _ },
        (node \ "@font-size").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-size" -> _ },
        (node \ "@font-weight").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45weight](x, scalaxb.ElemName(node) :: stack)) } map { "@font-weight" -> _ },
        (node \ "@color").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@color" -> _ },
        (node \ "@halign").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Leftu45centeru45right](x, scalaxb.ElemName(node) :: stack)) } map { "@halign" -> _ },
        (node \ "@valign").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Valign](x, scalaxb.ElemName(node) :: stack)) } map { "@valign" -> _ },
        (node \ "@justify").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Leftu45centeru45right](x, scalaxb.ElemName(node) :: stack)) } map { "@justify" -> _ },
        (node \ "@parentheses").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Yesu45no](x, scalaxb.ElemName(node) :: stack)) } map { "@parentheses" -> _ },
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: musicxml.Metronome, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@default-x", _) => __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.bigDecimal.toPlainString, attr) }
        case ("@default-y", _) => __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.bigDecimal.toPlainString, attr) }
        case ("@relative-x", _) => __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.bigDecimal.toPlainString, attr) }
        case ("@relative-y", _) => __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.bigDecimal.toPlainString, attr) }
        case ("@font-family", _) => __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
        case ("@font-style", _) => __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
        case ("@font-size", _) => __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
        case ("@font-weight", _) => __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
        case ("@color", _) => __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
        case ("@halign", _) => __obj.halign foreach { x => attr = scala.xml.Attribute(null, "halign", x.toString, attr) }
        case ("@valign", _) => __obj.valign foreach { x => attr = scala.xml.Attribute(null, "valign", x.toString, attr) }
        case ("@justify", _) => __obj.justify foreach { x => attr = scala.xml.Attribute(null, "justify", x.toString, attr) }
        case ("@parentheses", _) => __obj.parentheses foreach { x => attr = scala.xml.Attribute(null, "parentheses", x.toString, attr) }
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Metronome, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      ((Some(__obj.metronomeoption) map {x => scalaxb.toXML[scalaxb.DataRecord[musicxml.MetronomeOption]](x, x.namespace, x.key, __scope, false)}).get)
  }

  trait DefaultMusicxml_MetronomeSequence4Format extends scalaxb.XMLFormat[musicxml.MetronomeSequence4] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.MetronomeSequence4] = Left("don't call me.")
    
    def writes(__obj: musicxml.MetronomeSequence4, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(scalaxb.toXML[String](__obj.metronomeu45relation, None, Some("metronome-relation"), __scope, false),
        __obj.metronomeu45note flatMap { scalaxb.toXML[musicxml.Metronomeu45note](_, None, Some("metronome-note"), __scope, false) })


  }

  trait DefaultMusicxml_MetronomeSequence1Format extends scalaxb.XMLFormat[musicxml.MetronomeSequence1] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.MetronomeSequence1] = Left("don't call me.")
    
    def writes(__obj: musicxml.MetronomeSequence1, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(scalaxb.toXML[musicxml.Beatu45unitSequence](__obj.beatu45unitSequence1, None, Some("beatu45unitSequence1"), __scope, false),
        __obj.beatu45unitu45tied flatMap { scalaxb.toXML[musicxml.Beatu45unitu45tied](_, None, Some("beat-unit-tied"), __scope, false) },
        (Some(__obj.metronomeoption2) map {x => scalaxb.toXML[scalaxb.DataRecord[musicxml.MetronomeOption2]](x, x.namespace, x.key, __scope, false)}).get)


  }

  trait DefaultMusicxml_MetronomeSequence3Format extends scalaxb.XMLFormat[musicxml.MetronomeSequence3] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.MetronomeSequence3] = Left("don't call me.")
    
    def writes(__obj: musicxml.MetronomeSequence3, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(__obj.metronomeu45arrows map { scalaxb.toXML[musicxml.Empty](_, None, Some("metronome-arrows"), __scope, false) } getOrElse {Nil},
        __obj.metronomeu45note flatMap { scalaxb.toXML[musicxml.Metronomeu45note](_, None, Some("metronome-note"), __scope, false) },
        __obj.metronomesequence4 map { scalaxb.toXML[musicxml.MetronomeSequence4](_, None, Some("metronomesequence4"), __scope, false) } getOrElse {Nil})


  }

  trait DefaultMusicxml_MetronomeSequence2Format extends scalaxb.XMLFormat[musicxml.MetronomeSequence2] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.MetronomeSequence2] = Left("don't call me.")
    
    def writes(__obj: musicxml.MetronomeSequence2, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(scalaxb.toXML[musicxml.Beatu45unitSequence](__obj.beatu45unitSequence1, None, Some("beatu45unitSequence1"), __scope, false),
        __obj.beatu45unitu45tied flatMap { scalaxb.toXML[musicxml.Beatu45unitu45tied](_, None, Some("beat-unit-tied"), __scope, false) })


  }

  trait DefaultMusicxml_Metronomeu45beamFormat extends scalaxb.XMLFormat[musicxml.Metronomeu45beam] with scalaxb.CanWriteChildNodes[musicxml.Metronomeu45beam] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Metronomeu45beam] = seq match {
      case node: scala.xml.Node => Right(musicxml.Metronomeu45beam(scalaxb.fromXML[musicxml.Beamu45value](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@number").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigInt](x, scalaxb.ElemName(node) :: stack)) } orElse Some(scalaxb.DataRecord(None, None, scalaxb.fromXML[BigInt](scala.xml.Text("1"), scalaxb.ElemName(node) :: stack))) map { "@number" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Metronomeu45beam, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@number", _) => if (__obj.number.toString != "1") attr = scala.xml.Attribute(null, "number", __obj.number.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Metronomeu45beam, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultMusicxml_Metronomeu45noteFormat extends scalaxb.ElemNameParser[musicxml.Metronomeu45note] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("metronome-note")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[musicxml.Metronomeu45note] =
      phrase((scalaxb.ElemName(None, "metronome-type")) ~ 
      safeRep(scalaxb.ElemName(None, "metronome-dot")) ~ 
      safeRep(scalaxb.ElemName(None, "metronome-beam")) ~ 
      opt(scalaxb.ElemName(None, "metronome-tied")) ~ 
      opt(scalaxb.ElemName(None, "metronome-tuplet")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 =>
      musicxml.Metronomeu45note(scalaxb.fromXML[musicxml.Noteu45typeu45value](p1, scalaxb.ElemName(node) :: stack),
        p2 map { scalaxb.fromXML[musicxml.Empty](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[musicxml.Metronomeu45beam](_, scalaxb.ElemName(node) :: stack) },
        p4.headOption map { scalaxb.fromXML[musicxml.Metronomeu45tied](_, scalaxb.ElemName(node) :: stack) },
        p5.headOption map { scalaxb.fromXML[musicxml.Metronomeu45tuplet](_, scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: musicxml.Metronomeu45note, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(scalaxb.toXML[musicxml.Noteu45typeu45value](__obj.metronomeu45type, None, Some("metronome-type"), __scope, false),
        __obj.metronomeu45dot flatMap { scalaxb.toXML[musicxml.Empty](_, None, Some("metronome-dot"), __scope, false) },
        __obj.metronomeu45beam flatMap { scalaxb.toXML[musicxml.Metronomeu45beam](_, None, Some("metronome-beam"), __scope, false) },
        __obj.metronomeu45tied map { scalaxb.toXML[musicxml.Metronomeu45tied](_, None, Some("metronome-tied"), __scope, false) } getOrElse {Nil},
        __obj.metronomeu45tuplet map { scalaxb.toXML[musicxml.Metronomeu45tuplet](_, None, Some("metronome-tuplet"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultMusicxml_Metronomeu45tiedFormat extends scalaxb.XMLFormat[musicxml.Metronomeu45tied] with scalaxb.CanWriteChildNodes[musicxml.Metronomeu45tied] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Metronomeu45tied] = seq match {
      case node: scala.xml.Node => Right(musicxml.Metronomeu45tied(scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Startu45stop](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Metronomeu45tied, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Metronomeu45tied, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil

  }

  trait DefaultMusicxml_Metronomeu45tupletFormat extends scalaxb.ElemNameParser[musicxml.Metronomeu45tuplet] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("metronome-tuplet")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[musicxml.Metronomeu45tuplet] =
      phrase((scalaxb.ElemName(None, "actual-notes")) ~ 
      (scalaxb.ElemName(None, "normal-notes")) ~ 
      opt(((scalaxb.ElemName(None, "normal-type")) ~ 
      safeRep(scalaxb.ElemName(None, "normal-dot"))) ^^ 
        { case p1 ~ p2 => musicxml.Timeu45modificationableSequence1(scalaxb.fromXML[musicxml.Noteu45typeu45value](p1, scalaxb.ElemName(node) :: stack),
        p2 map { scalaxb.fromXML[musicxml.Empty](_, scalaxb.ElemName(node) :: stack) }) }) ^^
      { case p1 ~ p2 ~ p3 =>
      musicxml.Metronomeu45tuplet(scalaxb.fromXML[BigInt](p1, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[BigInt](p2, scalaxb.ElemName(node) :: stack),
        p3,
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Startu45stop](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ },
        (node \ "@bracket").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Yesu45no](x, scalaxb.ElemName(node) :: stack)) } map { "@bracket" -> _ },
        (node \ "@show-number").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Showu45tuplet](x, scalaxb.ElemName(node) :: stack)) } map { "@show-number" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: musicxml.Metronomeu45tuplet, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case ("@bracket", _) => __obj.bracket foreach { x => attr = scala.xml.Attribute(null, "bracket", x.toString, attr) }
        case ("@show-number", _) => __obj.showu45number foreach { x => attr = scala.xml.Attribute(null, "show-number", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Metronomeu45tuplet, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(scalaxb.toXML[BigInt](__obj.actualu45notes, None, Some("actual-notes"), __scope, false),
        scalaxb.toXML[BigInt](__obj.normalu45notes, None, Some("normal-notes"), __scope, false),
        __obj.timeu45modificationablesequence1 map { scalaxb.toXML[musicxml.Timeu45modificationableSequence1](_, None, Some("timeu45modificationablesequence1"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultMusicxml_Octaveu45shiftFormat extends scalaxb.XMLFormat[musicxml.Octaveu45shift] with scalaxb.CanWriteChildNodes[musicxml.Octaveu45shift] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Octaveu45shift] = seq match {
      case node: scala.xml.Node => Right(musicxml.Octaveu45shift(scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Upu45downu45stopu45continue](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ },
        (node \ "@number").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigInt](x, scalaxb.ElemName(node) :: stack)) } map { "@number" -> _ },
        (node \ "@size").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigInt](x, scalaxb.ElemName(node) :: stack)) } orElse Some(scalaxb.DataRecord(None, None, scalaxb.fromXML[BigInt](scala.xml.Text("8"), scalaxb.ElemName(node) :: stack))) map { "@size" -> _ },
        (node \ "@dash-length").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@dash-length" -> _ },
        (node \ "@space-length").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@space-length" -> _ },
        (node \ "@default-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-x" -> _ },
        (node \ "@default-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-y" -> _ },
        (node \ "@relative-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-x" -> _ },
        (node \ "@relative-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-y" -> _ },
        (node \ "@font-family").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-family" -> _ },
        (node \ "@font-style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45style](x, scalaxb.ElemName(node) :: stack)) } map { "@font-style" -> _ },
        (node \ "@font-size").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-size" -> _ },
        (node \ "@font-weight").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45weight](x, scalaxb.ElemName(node) :: stack)) } map { "@font-weight" -> _ },
        (node \ "@color").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@color" -> _ },
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Octaveu45shift, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case ("@number", _) => __obj.number foreach { x => attr = scala.xml.Attribute(null, "number", x.toString, attr) }
        case ("@size", _) => if (__obj.size.toString != "8") attr = scala.xml.Attribute(null, "size", __obj.size.toString, attr)
        case ("@dash-length", _) => __obj.dashu45length foreach { x => attr = scala.xml.Attribute(null, "dash-length", x.bigDecimal.toPlainString, attr) }
        case ("@space-length", _) => __obj.spaceu45length foreach { x => attr = scala.xml.Attribute(null, "space-length", x.bigDecimal.toPlainString, attr) }
        case ("@default-x", _) => __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.bigDecimal.toPlainString, attr) }
        case ("@default-y", _) => __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.bigDecimal.toPlainString, attr) }
        case ("@relative-x", _) => __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.bigDecimal.toPlainString, attr) }
        case ("@relative-y", _) => __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.bigDecimal.toPlainString, attr) }
        case ("@font-family", _) => __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
        case ("@font-style", _) => __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
        case ("@font-size", _) => __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
        case ("@font-weight", _) => __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
        case ("@color", _) => __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Octaveu45shift, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil

  }

  trait DefaultMusicxml_OffsetFormat extends scalaxb.XMLFormat[musicxml.Offset] with scalaxb.CanWriteChildNodes[musicxml.Offset] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Offset] = seq match {
      case node: scala.xml.Node => Right(musicxml.Offset(scalaxb.fromXML[BigDecimal](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@sound").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Yesu45no](x, scalaxb.ElemName(node) :: stack)) } map { "@sound" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Offset, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@sound", _) => __obj.sound foreach { x => attr = scala.xml.Attribute(null, "sound", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Offset, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultMusicxml_Otheru45directionFormat extends scalaxb.XMLFormat[musicxml.Otheru45direction] with scalaxb.CanWriteChildNodes[musicxml.Otheru45direction] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Otheru45direction] = seq match {
      case node: scala.xml.Node => Right(musicxml.Otheru45direction(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@print-object").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Yesu45no](x, scalaxb.ElemName(node) :: stack)) } map { "@print-object" -> _ },
        (node \ "@default-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-x" -> _ },
        (node \ "@default-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-y" -> _ },
        (node \ "@relative-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-x" -> _ },
        (node \ "@relative-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-y" -> _ },
        (node \ "@font-family").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-family" -> _ },
        (node \ "@font-style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45style](x, scalaxb.ElemName(node) :: stack)) } map { "@font-style" -> _ },
        (node \ "@font-size").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-size" -> _ },
        (node \ "@font-weight").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45weight](x, scalaxb.ElemName(node) :: stack)) } map { "@font-weight" -> _ },
        (node \ "@color").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@color" -> _ },
        (node \ "@halign").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Leftu45centeru45right](x, scalaxb.ElemName(node) :: stack)) } map { "@halign" -> _ },
        (node \ "@valign").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Valign](x, scalaxb.ElemName(node) :: stack)) } map { "@valign" -> _ },
        (node \ "@smufl").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@smufl" -> _ },
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Otheru45direction, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@print-object", _) => __obj.printu45object foreach { x => attr = scala.xml.Attribute(null, "print-object", x.toString, attr) }
        case ("@default-x", _) => __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.bigDecimal.toPlainString, attr) }
        case ("@default-y", _) => __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.bigDecimal.toPlainString, attr) }
        case ("@relative-x", _) => __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.bigDecimal.toPlainString, attr) }
        case ("@relative-y", _) => __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.bigDecimal.toPlainString, attr) }
        case ("@font-family", _) => __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
        case ("@font-style", _) => __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
        case ("@font-size", _) => __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
        case ("@font-weight", _) => __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
        case ("@color", _) => __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
        case ("@halign", _) => __obj.halign foreach { x => attr = scala.xml.Attribute(null, "halign", x.toString, attr) }
        case ("@valign", _) => __obj.valign foreach { x => attr = scala.xml.Attribute(null, "valign", x.toString, attr) }
        case ("@smufl", _) => __obj.smufl foreach { x => attr = scala.xml.Attribute(null, "smufl", x.toString, attr) }
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Otheru45direction, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultMusicxml_PedalFormat extends scalaxb.XMLFormat[musicxml.Pedal] with scalaxb.CanWriteChildNodes[musicxml.Pedal] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Pedal] = seq match {
      case node: scala.xml.Node => Right(musicxml.Pedal(scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Pedalu45type](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ },
        (node \ "@number").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigInt](x, scalaxb.ElemName(node) :: stack)) } map { "@number" -> _ },
        (node \ "@line").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Yesu45no](x, scalaxb.ElemName(node) :: stack)) } map { "@line" -> _ },
        (node \ "@sign").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Yesu45no](x, scalaxb.ElemName(node) :: stack)) } map { "@sign" -> _ },
        (node \ "@abbreviated").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Yesu45no](x, scalaxb.ElemName(node) :: stack)) } map { "@abbreviated" -> _ },
        (node \ "@default-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-x" -> _ },
        (node \ "@default-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-y" -> _ },
        (node \ "@relative-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-x" -> _ },
        (node \ "@relative-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-y" -> _ },
        (node \ "@font-family").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-family" -> _ },
        (node \ "@font-style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45style](x, scalaxb.ElemName(node) :: stack)) } map { "@font-style" -> _ },
        (node \ "@font-size").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-size" -> _ },
        (node \ "@font-weight").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45weight](x, scalaxb.ElemName(node) :: stack)) } map { "@font-weight" -> _ },
        (node \ "@color").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@color" -> _ },
        (node \ "@halign").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Leftu45centeru45right](x, scalaxb.ElemName(node) :: stack)) } map { "@halign" -> _ },
        (node \ "@valign").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Valign](x, scalaxb.ElemName(node) :: stack)) } map { "@valign" -> _ },
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Pedal, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case ("@number", _) => __obj.number foreach { x => attr = scala.xml.Attribute(null, "number", x.toString, attr) }
        case ("@line", _) => __obj.line foreach { x => attr = scala.xml.Attribute(null, "line", x.toString, attr) }
        case ("@sign", _) => __obj.sign foreach { x => attr = scala.xml.Attribute(null, "sign", x.toString, attr) }
        case ("@abbreviated", _) => __obj.abbreviated foreach { x => attr = scala.xml.Attribute(null, "abbreviated", x.toString, attr) }
        case ("@default-x", _) => __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.bigDecimal.toPlainString, attr) }
        case ("@default-y", _) => __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.bigDecimal.toPlainString, attr) }
        case ("@relative-x", _) => __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.bigDecimal.toPlainString, attr) }
        case ("@relative-y", _) => __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.bigDecimal.toPlainString, attr) }
        case ("@font-family", _) => __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
        case ("@font-style", _) => __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
        case ("@font-size", _) => __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
        case ("@font-weight", _) => __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
        case ("@color", _) => __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
        case ("@halign", _) => __obj.halign foreach { x => attr = scala.xml.Attribute(null, "halign", x.toString, attr) }
        case ("@valign", _) => __obj.valign foreach { x => attr = scala.xml.Attribute(null, "valign", x.toString, attr) }
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Pedal, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil

  }

  trait DefaultMusicxml_Pedalu45tuningFormat extends scalaxb.ElemNameParser[musicxml.Pedalu45tuning] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("pedal-tuning")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[musicxml.Pedalu45tuning] =
      phrase((scalaxb.ElemName(None, "pedal-step")) ~ 
      (scalaxb.ElemName(None, "pedal-alter")) ^^
      { case p1 ~ p2 =>
      musicxml.Pedalu45tuning(scalaxb.fromXML[musicxml.Step](p1, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[BigDecimal](p2, scalaxb.ElemName(node) :: stack)) })
    
    def writesChildNodes(__obj: musicxml.Pedalu45tuning, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(scalaxb.toXML[musicxml.Step](__obj.pedalu45step, None, Some("pedal-step"), __scope, false),
        scalaxb.toXML[BigDecimal](__obj.pedalu45alter, None, Some("pedal-alter"), __scope, false))

  }

  trait DefaultMusicxml_Peru45minuteFormat extends scalaxb.XMLFormat[musicxml.Peru45minute] with scalaxb.CanWriteChildNodes[musicxml.Peru45minute] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Peru45minute] = seq match {
      case node: scala.xml.Node => Right(musicxml.Peru45minute(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@font-family").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-family" -> _ },
        (node \ "@font-style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45style](x, scalaxb.ElemName(node) :: stack)) } map { "@font-style" -> _ },
        (node \ "@font-size").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-size" -> _ },
        (node \ "@font-weight").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45weight](x, scalaxb.ElemName(node) :: stack)) } map { "@font-weight" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Peru45minute, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@font-family", _) => __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
        case ("@font-style", _) => __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
        case ("@font-size", _) => __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
        case ("@font-weight", _) => __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Peru45minute, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultMusicxml_PercussionTypeFormat extends scalaxb.ElemNameParser[musicxml.PercussionType] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("percussion")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[musicxml.PercussionType] =
      phrase((((scalaxb.ElemName(None, "glass")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Glass](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "metal")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "wood")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "pitched")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Pitched](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "membrane")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "effect")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "timpani")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Empty](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "beater")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Beater](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "stick")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Stick](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "stick-location")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "other-percussion")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Otheru45text](x, scalaxb.ElemName(node) :: stack))))) ^^
      { case p1 =>
      musicxml.PercussionType(p1,
        scala.collection.immutable.ListMap(List(
        (node \ "@default-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-x" -> _ },
        (node \ "@default-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-y" -> _ },
        (node \ "@relative-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-x" -> _ },
        (node \ "@relative-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-y" -> _ },
        (node \ "@font-family").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-family" -> _ },
        (node \ "@font-style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45style](x, scalaxb.ElemName(node) :: stack)) } map { "@font-style" -> _ },
        (node \ "@font-size").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-size" -> _ },
        (node \ "@font-weight").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45weight](x, scalaxb.ElemName(node) :: stack)) } map { "@font-weight" -> _ },
        (node \ "@color").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@color" -> _ },
        (node \ "@halign").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Leftu45centeru45right](x, scalaxb.ElemName(node) :: stack)) } map { "@halign" -> _ },
        (node \ "@valign").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Valign](x, scalaxb.ElemName(node) :: stack)) } map { "@valign" -> _ },
        (node \ "@enclosure").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Enclosureu45shape](x, scalaxb.ElemName(node) :: stack)) } map { "@enclosure" -> _ },
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: musicxml.PercussionType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@default-x", _) => __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.bigDecimal.toPlainString, attr) }
        case ("@default-y", _) => __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.bigDecimal.toPlainString, attr) }
        case ("@relative-x", _) => __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.bigDecimal.toPlainString, attr) }
        case ("@relative-y", _) => __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.bigDecimal.toPlainString, attr) }
        case ("@font-family", _) => __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
        case ("@font-style", _) => __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
        case ("@font-size", _) => __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
        case ("@font-weight", _) => __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
        case ("@color", _) => __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
        case ("@halign", _) => __obj.halign foreach { x => attr = scala.xml.Attribute(null, "halign", x.toString, attr) }
        case ("@valign", _) => __obj.valign foreach { x => attr = scala.xml.Attribute(null, "valign", x.toString, attr) }
        case ("@enclosure", _) => __obj.enclosure foreach { x => attr = scala.xml.Attribute(null, "enclosure", x.toString, attr) }
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.PercussionType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      ((Some(__obj.percussiontypeoption) map {x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false)}).get)
  }

  trait DefaultMusicxml_PitchedFormat extends scalaxb.XMLFormat[musicxml.Pitched] with scalaxb.CanWriteChildNodes[musicxml.Pitched] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Pitched] = seq match {
      case node: scala.xml.Node => Right(musicxml.Pitched(scalaxb.fromXML[musicxml.Pitchedu45value](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@smufl").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@smufl" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Pitched, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@smufl", _) => __obj.smufl foreach { x => attr = scala.xml.Attribute(null, "smufl", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Pitched, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultMusicxml_Principalu45voiceFormat extends scalaxb.XMLFormat[musicxml.Principalu45voice] with scalaxb.CanWriteChildNodes[musicxml.Principalu45voice] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Principalu45voice] = seq match {
      case node: scala.xml.Node => Right(musicxml.Principalu45voice(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Startu45stop](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ },
        (node \ "@symbol").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Principalu45voiceu45symbol](x, scalaxb.ElemName(node) :: stack)) } map { "@symbol" -> _ },
        (node \ "@default-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-x" -> _ },
        (node \ "@default-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-y" -> _ },
        (node \ "@relative-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-x" -> _ },
        (node \ "@relative-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-y" -> _ },
        (node \ "@font-family").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-family" -> _ },
        (node \ "@font-style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45style](x, scalaxb.ElemName(node) :: stack)) } map { "@font-style" -> _ },
        (node \ "@font-size").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-size" -> _ },
        (node \ "@font-weight").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45weight](x, scalaxb.ElemName(node) :: stack)) } map { "@font-weight" -> _ },
        (node \ "@color").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@color" -> _ },
        (node \ "@halign").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Leftu45centeru45right](x, scalaxb.ElemName(node) :: stack)) } map { "@halign" -> _ },
        (node \ "@valign").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Valign](x, scalaxb.ElemName(node) :: stack)) } map { "@valign" -> _ },
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Principalu45voice, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case ("@symbol", _) => attr = scala.xml.Attribute(null, "symbol", __obj.symbol.toString, attr)
        case ("@default-x", _) => __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.bigDecimal.toPlainString, attr) }
        case ("@default-y", _) => __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.bigDecimal.toPlainString, attr) }
        case ("@relative-x", _) => __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.bigDecimal.toPlainString, attr) }
        case ("@relative-y", _) => __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.bigDecimal.toPlainString, attr) }
        case ("@font-family", _) => __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
        case ("@font-style", _) => __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
        case ("@font-size", _) => __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
        case ("@font-weight", _) => __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
        case ("@color", _) => __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
        case ("@halign", _) => __obj.halign foreach { x => attr = scala.xml.Attribute(null, "halign", x.toString, attr) }
        case ("@valign", _) => __obj.valign foreach { x => attr = scala.xml.Attribute(null, "valign", x.toString, attr) }
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Principalu45voice, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultMusicxml_PrintFormat extends scalaxb.ElemNameParser[musicxml.Print] with Musicxml_LayoutGroupFormat {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("print")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[musicxml.Print] =
      phrase((parseLayoutGroup(node, scalaxb.ElemName(node) :: stack)) ~ 
      opt(scalaxb.ElemName(None, "measure-layout")) ~ 
      opt(scalaxb.ElemName(None, "measure-numbering")) ~ 
      opt(scalaxb.ElemName(None, "part-name-display")) ~ 
      opt(scalaxb.ElemName(None, "part-abbreviation-display")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 =>
      musicxml.Print(p1,
        p2.headOption map { scalaxb.fromXML[musicxml.Measureu45layout](_, scalaxb.ElemName(node) :: stack) },
        p3.headOption map { scalaxb.fromXML[musicxml.Measureu45numbering](_, scalaxb.ElemName(node) :: stack) },
        p4.headOption map { scalaxb.fromXML[musicxml.Nameu45display](_, scalaxb.ElemName(node) :: stack) },
        p5.headOption map { scalaxb.fromXML[musicxml.Nameu45display](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@staff-spacing").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@staff-spacing" -> _ },
        (node \ "@new-system").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Yesu45no](x, scalaxb.ElemName(node) :: stack)) } map { "@new-system" -> _ },
        (node \ "@new-page").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Yesu45no](x, scalaxb.ElemName(node) :: stack)) } map { "@new-page" -> _ },
        (node \ "@blank-page").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigInt](x, scalaxb.ElemName(node) :: stack)) } map { "@blank-page" -> _ },
        (node \ "@page-number").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@page-number" -> _ },
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: musicxml.Print, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@staff-spacing", _) => __obj.staffu45spacing foreach { x => attr = scala.xml.Attribute(null, "staff-spacing", x.bigDecimal.toPlainString, attr) }
        case ("@new-system", _) => __obj.newu45system foreach { x => attr = scala.xml.Attribute(null, "new-system", x.toString, attr) }
        case ("@new-page", _) => __obj.newu45page foreach { x => attr = scala.xml.Attribute(null, "new-page", x.toString, attr) }
        case ("@blank-page", _) => __obj.blanku45page foreach { x => attr = scala.xml.Attribute(null, "blank-page", x.toString, attr) }
        case ("@page-number", _) => __obj.pageu45number foreach { x => attr = scala.xml.Attribute(null, "page-number", x.toString, attr) }
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Print, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(scalaxb.toXML[musicxml.LayoutSequence](__obj.layoutSequence1, None, Some("layoutSequence1"), __scope, false),
        __obj.measureu45layout map { scalaxb.toXML[musicxml.Measureu45layout](_, None, Some("measure-layout"), __scope, false) } getOrElse {Nil},
        __obj.measureu45numbering map { scalaxb.toXML[musicxml.Measureu45numbering](_, None, Some("measure-numbering"), __scope, false) } getOrElse {Nil},
        __obj.partu45nameu45display map { scalaxb.toXML[musicxml.Nameu45display](_, None, Some("part-name-display"), __scope, false) } getOrElse {Nil},
        __obj.partu45abbreviationu45display map { scalaxb.toXML[musicxml.Nameu45display](_, None, Some("part-abbreviation-display"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultMusicxml_RootFormat extends scalaxb.ElemNameParser[musicxml.Root] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("root")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[musicxml.Root] =
      phrase((scalaxb.ElemName(None, "root-step")) ~ 
      opt(scalaxb.ElemName(None, "root-alter")) ^^
      { case p1 ~ p2 =>
      musicxml.Root(scalaxb.fromXML[musicxml.Rootu45step](p1, scalaxb.ElemName(node) :: stack),
        p2.headOption map { scalaxb.fromXML[musicxml.Rootu45alter](_, scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: musicxml.Root, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(scalaxb.toXML[musicxml.Rootu45step](__obj.rootu45step, None, Some("root-step"), __scope, false),
        __obj.rootu45alter map { scalaxb.toXML[musicxml.Rootu45alter](_, None, Some("root-alter"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultMusicxml_Rootu45alterFormat extends scalaxb.XMLFormat[musicxml.Rootu45alter] with scalaxb.CanWriteChildNodes[musicxml.Rootu45alter] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Rootu45alter] = seq match {
      case node: scala.xml.Node => Right(musicxml.Rootu45alter(scalaxb.fromXML[BigDecimal](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@print-object").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Yesu45no](x, scalaxb.ElemName(node) :: stack)) } map { "@print-object" -> _ },
        (node \ "@default-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-x" -> _ },
        (node \ "@default-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-y" -> _ },
        (node \ "@relative-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-x" -> _ },
        (node \ "@relative-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-y" -> _ },
        (node \ "@font-family").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-family" -> _ },
        (node \ "@font-style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45style](x, scalaxb.ElemName(node) :: stack)) } map { "@font-style" -> _ },
        (node \ "@font-size").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-size" -> _ },
        (node \ "@font-weight").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45weight](x, scalaxb.ElemName(node) :: stack)) } map { "@font-weight" -> _ },
        (node \ "@color").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@color" -> _ },
        (node \ "@location").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Leftu45right](x, scalaxb.ElemName(node) :: stack)) } map { "@location" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Rootu45alter, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@print-object", _) => __obj.printu45object foreach { x => attr = scala.xml.Attribute(null, "print-object", x.toString, attr) }
        case ("@default-x", _) => __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.bigDecimal.toPlainString, attr) }
        case ("@default-y", _) => __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.bigDecimal.toPlainString, attr) }
        case ("@relative-x", _) => __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.bigDecimal.toPlainString, attr) }
        case ("@relative-y", _) => __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.bigDecimal.toPlainString, attr) }
        case ("@font-family", _) => __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
        case ("@font-style", _) => __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
        case ("@font-size", _) => __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
        case ("@font-weight", _) => __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
        case ("@color", _) => __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
        case ("@location", _) => __obj.location foreach { x => attr = scala.xml.Attribute(null, "location", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Rootu45alter, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultMusicxml_Rootu45stepFormat extends scalaxb.XMLFormat[musicxml.Rootu45step] with scalaxb.CanWriteChildNodes[musicxml.Rootu45step] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Rootu45step] = seq match {
      case node: scala.xml.Node => Right(musicxml.Rootu45step(scalaxb.fromXML[musicxml.Step](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@text").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@text" -> _ },
        (node \ "@default-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-x" -> _ },
        (node \ "@default-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-y" -> _ },
        (node \ "@relative-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-x" -> _ },
        (node \ "@relative-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-y" -> _ },
        (node \ "@font-family").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-family" -> _ },
        (node \ "@font-style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45style](x, scalaxb.ElemName(node) :: stack)) } map { "@font-style" -> _ },
        (node \ "@font-size").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-size" -> _ },
        (node \ "@font-weight").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45weight](x, scalaxb.ElemName(node) :: stack)) } map { "@font-weight" -> _ },
        (node \ "@color").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@color" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Rootu45step, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@text", _) => __obj.text foreach { x => attr = scala.xml.Attribute(null, "text", x.toString, attr) }
        case ("@default-x", _) => __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.bigDecimal.toPlainString, attr) }
        case ("@default-y", _) => __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.bigDecimal.toPlainString, attr) }
        case ("@relative-x", _) => __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.bigDecimal.toPlainString, attr) }
        case ("@relative-y", _) => __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.bigDecimal.toPlainString, attr) }
        case ("@font-family", _) => __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
        case ("@font-style", _) => __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
        case ("@font-size", _) => __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
        case ("@font-weight", _) => __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
        case ("@color", _) => __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Rootu45step, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultMusicxml_ScordaturaFormat extends scalaxb.ElemNameParser[musicxml.Scordatura] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("scordatura")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[musicxml.Scordatura] =
      phrase(safeRep(scalaxb.ElemName(None, "accord")) ^^
      { case p1 =>
      musicxml.Scordatura(p1 map { scalaxb.fromXML[musicxml.Accord](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: musicxml.Scordatura, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Scordatura, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.accord flatMap { scalaxb.toXML[musicxml.Accord](_, None, Some("accord"), __scope, false) })
  }

  trait DefaultMusicxml_SoundFormat extends scalaxb.ElemNameParser[musicxml.Sound] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("sound")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[musicxml.Sound] =
      phrase(safeRep((opt(scalaxb.ElemName(None, "midi-device")) ~ 
      opt(scalaxb.ElemName(None, "midi-instrument")) ~ 
      opt(scalaxb.ElemName(None, "play"))) ^^ 
        { case p1 ~ p2 ~ p3 => musicxml.SoundSequence1(p1.headOption map { scalaxb.fromXML[musicxml.Midiu45device](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[musicxml.Midiu45instrument](_, scalaxb.ElemName(node) :: stack) },
        p3.headOption map { scalaxb.fromXML[musicxml.Play](_, scalaxb.ElemName(node) :: stack) }) }) ~ 
      opt(scalaxb.ElemName(None, "offset")) ^^
      { case p1 ~ p2 =>
      musicxml.Sound(p1,
        p2.headOption map { scalaxb.fromXML[musicxml.Offset](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@tempo").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@tempo" -> _ },
        (node \ "@dynamics").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@dynamics" -> _ },
        (node \ "@dacapo").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Yesu45no](x, scalaxb.ElemName(node) :: stack)) } map { "@dacapo" -> _ },
        (node \ "@segno").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@segno" -> _ },
        (node \ "@dalsegno").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@dalsegno" -> _ },
        (node \ "@coda").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@coda" -> _ },
        (node \ "@tocoda").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@tocoda" -> _ },
        (node \ "@divisions").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@divisions" -> _ },
        (node \ "@forward-repeat").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Yesu45no](x, scalaxb.ElemName(node) :: stack)) } map { "@forward-repeat" -> _ },
        (node \ "@fine").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@fine" -> _ },
        (node \ "@time-only").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@time-only" -> _ },
        (node \ "@pizzicato").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Yesu45no](x, scalaxb.ElemName(node) :: stack)) } map { "@pizzicato" -> _ },
        (node \ "@pan").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@pan" -> _ },
        (node \ "@elevation").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@elevation" -> _ },
        (node \ "@damper-pedal").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@damper-pedal" -> _ },
        (node \ "@soft-pedal").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@soft-pedal" -> _ },
        (node \ "@sostenuto-pedal").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@sostenuto-pedal" -> _ },
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: musicxml.Sound, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@tempo", _) => __obj.tempo foreach { x => attr = scala.xml.Attribute(null, "tempo", x.bigDecimal.toPlainString, attr) }
        case ("@dynamics", _) => __obj.dynamics foreach { x => attr = scala.xml.Attribute(null, "dynamics", x.bigDecimal.toPlainString, attr) }
        case ("@dacapo", _) => __obj.dacapo foreach { x => attr = scala.xml.Attribute(null, "dacapo", x.toString, attr) }
        case ("@segno", _) => __obj.segno foreach { x => attr = scala.xml.Attribute(null, "segno", x.toString, attr) }
        case ("@dalsegno", _) => __obj.dalsegno foreach { x => attr = scala.xml.Attribute(null, "dalsegno", x.toString, attr) }
        case ("@coda", _) => __obj.coda foreach { x => attr = scala.xml.Attribute(null, "coda", x.toString, attr) }
        case ("@tocoda", _) => __obj.tocoda foreach { x => attr = scala.xml.Attribute(null, "tocoda", x.toString, attr) }
        case ("@divisions", _) => __obj.divisions foreach { x => attr = scala.xml.Attribute(null, "divisions", x.bigDecimal.toPlainString, attr) }
        case ("@forward-repeat", _) => __obj.forwardu45repeat foreach { x => attr = scala.xml.Attribute(null, "forward-repeat", x.toString, attr) }
        case ("@fine", _) => __obj.fine foreach { x => attr = scala.xml.Attribute(null, "fine", x.toString, attr) }
        case ("@time-only", _) => __obj.timeu45only foreach { x => attr = scala.xml.Attribute(null, "time-only", x.toString, attr) }
        case ("@pizzicato", _) => __obj.pizzicato foreach { x => attr = scala.xml.Attribute(null, "pizzicato", x.toString, attr) }
        case ("@pan", _) => __obj.pan foreach { x => attr = scala.xml.Attribute(null, "pan", x.bigDecimal.toPlainString, attr) }
        case ("@elevation", _) => __obj.elevation foreach { x => attr = scala.xml.Attribute(null, "elevation", x.bigDecimal.toPlainString, attr) }
        case ("@damper-pedal", _) => __obj.damperu45pedal foreach { x => attr = scala.xml.Attribute(null, "damper-pedal", x.toString, attr) }
        case ("@soft-pedal", _) => __obj.softu45pedal foreach { x => attr = scala.xml.Attribute(null, "soft-pedal", x.toString, attr) }
        case ("@sostenuto-pedal", _) => __obj.sostenutou45pedal foreach { x => attr = scala.xml.Attribute(null, "sostenuto-pedal", x.toString, attr) }
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Sound, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.soundsequence1 flatMap { scalaxb.toXML[musicxml.SoundSequence1](_, None, Some("soundsequence1"), __scope, false) },
        __obj.offset map { scalaxb.toXML[musicxml.Offset](_, None, Some("offset"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultMusicxml_SoundSequence1Format extends scalaxb.XMLFormat[musicxml.SoundSequence1] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.SoundSequence1] = Left("don't call me.")
    
    def writes(__obj: musicxml.SoundSequence1, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(__obj.midiu45device map { scalaxb.toXML[musicxml.Midiu45device](_, None, Some("midi-device"), __scope, false) } getOrElse {Nil},
        __obj.midiu45instrument map { scalaxb.toXML[musicxml.Midiu45instrument](_, None, Some("midi-instrument"), __scope, false) } getOrElse {Nil},
        __obj.play map { scalaxb.toXML[musicxml.Play](_, None, Some("play"), __scope, false) } getOrElse {Nil})


  }

  trait DefaultMusicxml_Staffu45divideFormat extends scalaxb.XMLFormat[musicxml.Staffu45divide] with scalaxb.CanWriteChildNodes[musicxml.Staffu45divide] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Staffu45divide] = seq match {
      case node: scala.xml.Node => Right(musicxml.Staffu45divide(scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Staffu45divideu45symbol](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ },
        (node \ "@default-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-x" -> _ },
        (node \ "@default-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-y" -> _ },
        (node \ "@relative-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-x" -> _ },
        (node \ "@relative-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-y" -> _ },
        (node \ "@font-family").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-family" -> _ },
        (node \ "@font-style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45style](x, scalaxb.ElemName(node) :: stack)) } map { "@font-style" -> _ },
        (node \ "@font-size").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-size" -> _ },
        (node \ "@font-weight").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45weight](x, scalaxb.ElemName(node) :: stack)) } map { "@font-weight" -> _ },
        (node \ "@color").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@color" -> _ },
        (node \ "@halign").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Leftu45centeru45right](x, scalaxb.ElemName(node) :: stack)) } map { "@halign" -> _ },
        (node \ "@valign").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Valign](x, scalaxb.ElemName(node) :: stack)) } map { "@valign" -> _ },
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Staffu45divide, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case ("@default-x", _) => __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.bigDecimal.toPlainString, attr) }
        case ("@default-y", _) => __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.bigDecimal.toPlainString, attr) }
        case ("@relative-x", _) => __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.bigDecimal.toPlainString, attr) }
        case ("@relative-y", _) => __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.bigDecimal.toPlainString, attr) }
        case ("@font-family", _) => __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
        case ("@font-style", _) => __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
        case ("@font-size", _) => __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
        case ("@font-weight", _) => __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
        case ("@color", _) => __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
        case ("@halign", _) => __obj.halign foreach { x => attr = scala.xml.Attribute(null, "halign", x.toString, attr) }
        case ("@valign", _) => __obj.valign foreach { x => attr = scala.xml.Attribute(null, "valign", x.toString, attr) }
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Staffu45divide, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil

  }

  trait DefaultMusicxml_StickFormat extends scalaxb.ElemNameParser[musicxml.Stick] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("stick")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[musicxml.Stick] =
      phrase((scalaxb.ElemName(None, "stick-type")) ~ 
      (scalaxb.ElemName(None, "stick-material")) ^^
      { case p1 ~ p2 =>
      musicxml.Stick(scalaxb.fromXML[musicxml.Sticku45type](p1, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[musicxml.Sticku45material](p2, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@tip").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Tipu45direction](x, scalaxb.ElemName(node) :: stack)) } map { "@tip" -> _ },
        (node \ "@parentheses").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Yesu45no](x, scalaxb.ElemName(node) :: stack)) } map { "@parentheses" -> _ },
        (node \ "@dashed-circle").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Yesu45no](x, scalaxb.ElemName(node) :: stack)) } map { "@dashed-circle" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: musicxml.Stick, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@tip", _) => __obj.tip foreach { x => attr = scala.xml.Attribute(null, "tip", x.toString, attr) }
        case ("@parentheses", _) => __obj.parentheses foreach { x => attr = scala.xml.Attribute(null, "parentheses", x.toString, attr) }
        case ("@dashed-circle", _) => __obj.dashedu45circle foreach { x => attr = scala.xml.Attribute(null, "dashed-circle", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Stick, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(scalaxb.toXML[musicxml.Sticku45type](__obj.sticku45type, None, Some("stick-type"), __scope, false),
        scalaxb.toXML[musicxml.Sticku45material](__obj.sticku45material, None, Some("stick-material"), __scope, false))

  }

  trait DefaultMusicxml_Stringu45muteFormat extends scalaxb.XMLFormat[musicxml.Stringu45mute] with scalaxb.CanWriteChildNodes[musicxml.Stringu45mute] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Stringu45mute] = seq match {
      case node: scala.xml.Node => Right(musicxml.Stringu45mute(scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Onu45off](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ },
        (node \ "@default-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-x" -> _ },
        (node \ "@default-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-y" -> _ },
        (node \ "@relative-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-x" -> _ },
        (node \ "@relative-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-y" -> _ },
        (node \ "@font-family").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-family" -> _ },
        (node \ "@font-style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45style](x, scalaxb.ElemName(node) :: stack)) } map { "@font-style" -> _ },
        (node \ "@font-size").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-size" -> _ },
        (node \ "@font-weight").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45weight](x, scalaxb.ElemName(node) :: stack)) } map { "@font-weight" -> _ },
        (node \ "@color").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@color" -> _ },
        (node \ "@halign").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Leftu45centeru45right](x, scalaxb.ElemName(node) :: stack)) } map { "@halign" -> _ },
        (node \ "@valign").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Valign](x, scalaxb.ElemName(node) :: stack)) } map { "@valign" -> _ },
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Stringu45mute, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case ("@default-x", _) => __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.bigDecimal.toPlainString, attr) }
        case ("@default-y", _) => __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.bigDecimal.toPlainString, attr) }
        case ("@relative-x", _) => __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.bigDecimal.toPlainString, attr) }
        case ("@relative-y", _) => __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.bigDecimal.toPlainString, attr) }
        case ("@font-family", _) => __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
        case ("@font-style", _) => __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
        case ("@font-size", _) => __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
        case ("@font-weight", _) => __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
        case ("@color", _) => __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
        case ("@halign", _) => __obj.halign foreach { x => attr = scala.xml.Attribute(null, "halign", x.toString, attr) }
        case ("@valign", _) => __obj.valign foreach { x => attr = scala.xml.Attribute(null, "valign", x.toString, attr) }
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Stringu45mute, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil

  }

  trait DefaultMusicxml_WedgeFormat extends scalaxb.XMLFormat[musicxml.Wedge] with scalaxb.CanWriteChildNodes[musicxml.Wedge] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Wedge] = seq match {
      case node: scala.xml.Node => Right(musicxml.Wedge(scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Wedgeu45type](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ },
        (node \ "@number").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigInt](x, scalaxb.ElemName(node) :: stack)) } map { "@number" -> _ },
        (node \ "@spread").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@spread" -> _ },
        (node \ "@niente").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Yesu45no](x, scalaxb.ElemName(node) :: stack)) } map { "@niente" -> _ },
        (node \ "@line-type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Lineu45type](x, scalaxb.ElemName(node) :: stack)) } map { "@line-type" -> _ },
        (node \ "@dash-length").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@dash-length" -> _ },
        (node \ "@space-length").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@space-length" -> _ },
        (node \ "@default-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-x" -> _ },
        (node \ "@default-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-y" -> _ },
        (node \ "@relative-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-x" -> _ },
        (node \ "@relative-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-y" -> _ },
        (node \ "@color").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@color" -> _ },
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Wedge, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case ("@number", _) => __obj.number foreach { x => attr = scala.xml.Attribute(null, "number", x.toString, attr) }
        case ("@spread", _) => __obj.spread foreach { x => attr = scala.xml.Attribute(null, "spread", x.bigDecimal.toPlainString, attr) }
        case ("@niente", _) => __obj.niente foreach { x => attr = scala.xml.Attribute(null, "niente", x.toString, attr) }
        case ("@line-type", _) => __obj.lineu45type foreach { x => attr = scala.xml.Attribute(null, "line-type", x.toString, attr) }
        case ("@dash-length", _) => __obj.dashu45length foreach { x => attr = scala.xml.Attribute(null, "dash-length", x.bigDecimal.toPlainString, attr) }
        case ("@space-length", _) => __obj.spaceu45length foreach { x => attr = scala.xml.Attribute(null, "space-length", x.bigDecimal.toPlainString, attr) }
        case ("@default-x", _) => __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.bigDecimal.toPlainString, attr) }
        case ("@default-y", _) => __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.bigDecimal.toPlainString, attr) }
        case ("@relative-x", _) => __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.bigDecimal.toPlainString, attr) }
        case ("@relative-y", _) => __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.bigDecimal.toPlainString, attr) }
        case ("@color", _) => __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Wedge, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil

  }

  trait DefaultMusicxml_EncodingFormat extends scalaxb.ElemNameParser[musicxml.Encoding] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("encoding")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[musicxml.Encoding] =
      phrase(safeRep(((scalaxb.ElemName(None, "encoding-date")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[javax.xml.datatype.XMLGregorianCalendar](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "encoder")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Typedu45text](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "software")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "encoding-description")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "supports")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Supports](x, scalaxb.ElemName(node) :: stack))))) ^^
      { case p1 =>
      musicxml.Encoding(p1) })
    
    def writesChildNodes(__obj: musicxml.Encoding, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.encodingoption flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) })
  }

  trait DefaultMusicxml_IdentificationFormat extends scalaxb.ElemNameParser[musicxml.Identification] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("identification")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[musicxml.Identification] =
      phrase(safeRep(scalaxb.ElemName(None, "creator")) ~ 
      safeRep(scalaxb.ElemName(None, "rights")) ~ 
      opt(scalaxb.ElemName(None, "encoding")) ~ 
      opt(scalaxb.ElemName(None, "source")) ~ 
      safeRep(scalaxb.ElemName(None, "relation")) ~ 
      opt(scalaxb.ElemName(None, "miscellaneous")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 =>
      musicxml.Identification(p1 map { scalaxb.fromXML[musicxml.Typedu45text](_, scalaxb.ElemName(node) :: stack) },
        p2 map { scalaxb.fromXML[musicxml.Typedu45text](_, scalaxb.ElemName(node) :: stack) },
        p3.headOption map { scalaxb.fromXML[musicxml.Encoding](_, scalaxb.ElemName(node) :: stack) },
        p4.headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        p5 map { scalaxb.fromXML[musicxml.Typedu45text](_, scalaxb.ElemName(node) :: stack) },
        p6.headOption map { scalaxb.fromXML[musicxml.Miscellaneous](_, scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: musicxml.Identification, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.creator flatMap { scalaxb.toXML[musicxml.Typedu45text](_, None, Some("creator"), __scope, false) },
        __obj.rights flatMap { scalaxb.toXML[musicxml.Typedu45text](_, None, Some("rights"), __scope, false) },
        __obj.encoding map { scalaxb.toXML[musicxml.Encoding](_, None, Some("encoding"), __scope, false) } getOrElse {Nil},
        __obj.source map { scalaxb.toXML[String](_, None, Some("source"), __scope, false) } getOrElse {Nil},
        __obj.relation flatMap { scalaxb.toXML[musicxml.Typedu45text](_, None, Some("relation"), __scope, false) },
        __obj.miscellaneous map { scalaxb.toXML[musicxml.Miscellaneous](_, None, Some("miscellaneous"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultMusicxml_MiscellaneousFormat extends scalaxb.ElemNameParser[musicxml.Miscellaneous] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("miscellaneous")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[musicxml.Miscellaneous] =
      phrase(safeRep(scalaxb.ElemName(None, "miscellaneous-field")) ^^
      { case p1 =>
      musicxml.Miscellaneous(p1 map { scalaxb.fromXML[musicxml.Miscellaneousu45field](_, scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: musicxml.Miscellaneous, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.miscellaneousu45field flatMap { scalaxb.toXML[musicxml.Miscellaneousu45field](_, None, Some("miscellaneous-field"), __scope, false) })
  }

  trait DefaultMusicxml_Miscellaneousu45fieldFormat extends scalaxb.XMLFormat[musicxml.Miscellaneousu45field] with scalaxb.CanWriteChildNodes[musicxml.Miscellaneousu45field] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Miscellaneousu45field] = seq match {
      case node: scala.xml.Node => Right(musicxml.Miscellaneousu45field(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@name").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@name" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Miscellaneousu45field, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@name", _) => attr = scala.xml.Attribute(null, "name", __obj.name.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Miscellaneousu45field, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultMusicxml_SupportsFormat extends scalaxb.XMLFormat[musicxml.Supports] with scalaxb.CanWriteChildNodes[musicxml.Supports] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Supports] = seq match {
      case node: scala.xml.Node => Right(musicxml.Supports(scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Yesu45no](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ },
        (node \ "@element").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@element" -> _ },
        (node \ "@attribute").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@attribute" -> _ },
        (node \ "@value").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@value" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Supports, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case ("@element", _) => attr = scala.xml.Attribute(null, "element", __obj.element.toString, attr)
        case ("@attribute", _) => __obj.attribute foreach { x => attr = scala.xml.Attribute(null, "attribute", x.toString, attr) }
        case ("@value", _) => __obj.valueAttribute foreach { x => attr = scala.xml.Attribute(null, "value", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Supports, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil

  }

  trait DefaultMusicxml_AppearanceFormat extends scalaxb.ElemNameParser[musicxml.Appearance] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("appearance")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[musicxml.Appearance] =
      phrase(safeRep(scalaxb.ElemName(None, "line-width")) ~ 
      safeRep(scalaxb.ElemName(None, "note-size")) ~ 
      safeRep(scalaxb.ElemName(None, "distance")) ~ 
      safeRep(scalaxb.ElemName(None, "glyph")) ~ 
      safeRep(scalaxb.ElemName(None, "other-appearance")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 =>
      musicxml.Appearance(p1 map { scalaxb.fromXML[musicxml.Lineu45width](_, scalaxb.ElemName(node) :: stack) },
        p2 map { scalaxb.fromXML[musicxml.Noteu45size](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[musicxml.Distance](_, scalaxb.ElemName(node) :: stack) },
        p4 map { scalaxb.fromXML[musicxml.Glyph](_, scalaxb.ElemName(node) :: stack) },
        p5 map { scalaxb.fromXML[musicxml.Otheru45appearance](_, scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: musicxml.Appearance, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.lineu45width flatMap { scalaxb.toXML[musicxml.Lineu45width](_, None, Some("line-width"), __scope, false) },
        __obj.noteu45size flatMap { scalaxb.toXML[musicxml.Noteu45size](_, None, Some("note-size"), __scope, false) },
        __obj.distance flatMap { scalaxb.toXML[musicxml.Distance](_, None, Some("distance"), __scope, false) },
        __obj.glyph flatMap { scalaxb.toXML[musicxml.Glyph](_, None, Some("glyph"), __scope, false) },
        __obj.otheru45appearance flatMap { scalaxb.toXML[musicxml.Otheru45appearance](_, None, Some("other-appearance"), __scope, false) })

  }

  trait DefaultMusicxml_DistanceFormat extends scalaxb.XMLFormat[musicxml.Distance] with scalaxb.CanWriteChildNodes[musicxml.Distance] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Distance] = seq match {
      case node: scala.xml.Node => Right(musicxml.Distance(scalaxb.fromXML[BigDecimal](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Distance, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Distance, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultMusicxml_GlyphFormat extends scalaxb.XMLFormat[musicxml.Glyph] with scalaxb.CanWriteChildNodes[musicxml.Glyph] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Glyph] = seq match {
      case node: scala.xml.Node => Right(musicxml.Glyph(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Glyph, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Glyph, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultMusicxml_Lineu45widthFormat extends scalaxb.XMLFormat[musicxml.Lineu45width] with scalaxb.CanWriteChildNodes[musicxml.Lineu45width] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Lineu45width] = seq match {
      case node: scala.xml.Node => Right(musicxml.Lineu45width(scalaxb.fromXML[BigDecimal](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Lineu45width, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Lineu45width, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultMusicxml_Measureu45layoutFormat extends scalaxb.ElemNameParser[musicxml.Measureu45layout] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("measure-layout")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[musicxml.Measureu45layout] =
      phrase(opt(scalaxb.ElemName(None, "measure-distance")) ^^
      { case p1 =>
      musicxml.Measureu45layout(p1.headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: musicxml.Measureu45layout, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.measureu45distance map { scalaxb.toXML[BigDecimal](_, None, Some("measure-distance"), __scope, false) } getOrElse {Nil})
  }

  trait DefaultMusicxml_Noteu45sizeFormat extends scalaxb.XMLFormat[musicxml.Noteu45size] with scalaxb.CanWriteChildNodes[musicxml.Noteu45size] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Noteu45size] = seq match {
      case node: scala.xml.Node => Right(musicxml.Noteu45size(scalaxb.fromXML[BigDecimal](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Noteu45sizeu45type](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Noteu45size, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Noteu45size, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultMusicxml_Otheru45appearanceFormat extends scalaxb.XMLFormat[musicxml.Otheru45appearance] with scalaxb.CanWriteChildNodes[musicxml.Otheru45appearance] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Otheru45appearance] = seq match {
      case node: scala.xml.Node => Right(musicxml.Otheru45appearance(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Otheru45appearance, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Otheru45appearance, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultMusicxml_Pageu45layoutFormat extends scalaxb.ElemNameParser[musicxml.Pageu45layout] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("page-layout")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[musicxml.Pageu45layout] =
      phrase(opt(((scalaxb.ElemName(None, "page-height")) ~ 
      (scalaxb.ElemName(None, "page-width"))) ^^ 
        { case p1 ~ p2 => musicxml.Pageu45layoutSequence1(scalaxb.fromXML[BigDecimal](p1, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[BigDecimal](p2, scalaxb.ElemName(node) :: stack)) }) ~ 
      safeRep(scalaxb.ElemName(None, "page-margins")) ^^
      { case p1 ~ p2 =>
      musicxml.Pageu45layout(p1,
        p2 map { scalaxb.fromXML[musicxml.Pageu45margins](_, scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: musicxml.Pageu45layout, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.pageu45layoutsequence1 map { scalaxb.toXML[musicxml.Pageu45layoutSequence1](_, None, Some("pageu45layoutsequence1"), __scope, false) } getOrElse {Nil},
        __obj.pageu45margins flatMap { scalaxb.toXML[musicxml.Pageu45margins](_, None, Some("page-margins"), __scope, false) })

  }

  trait DefaultMusicxml_Pageu45layoutSequence1Format extends scalaxb.XMLFormat[musicxml.Pageu45layoutSequence1] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Pageu45layoutSequence1] = Left("don't call me.")
    
    def writes(__obj: musicxml.Pageu45layoutSequence1, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(scalaxb.toXML[BigDecimal](__obj.pageu45height, None, Some("page-height"), __scope, false),
        scalaxb.toXML[BigDecimal](__obj.pageu45width, None, Some("page-width"), __scope, false))


  }

  trait DefaultMusicxml_Pageu45marginsFormat extends scalaxb.ElemNameParser[musicxml.Pageu45margins] with Musicxml_Allu45marginsGroupFormat {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("page-margins")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[musicxml.Pageu45margins] =
      phrase((parseAllu45marginsGroup(node, scalaxb.ElemName(node) :: stack)) ^^
      { case p1 =>
      musicxml.Pageu45margins(p1,
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Marginu45type](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: musicxml.Pageu45margins, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => __obj.typeValue foreach { x => attr = scala.xml.Attribute(null, "type", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Pageu45margins, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (scalaxb.toXML[musicxml.Allu45marginsSequence](__obj.allu45marginsSequence1, None, Some("allu45marginsSequence1"), __scope, false))
  }

  trait DefaultMusicxml_ScalingFormat extends scalaxb.ElemNameParser[musicxml.Scaling] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("scaling")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[musicxml.Scaling] =
      phrase((scalaxb.ElemName(None, "millimeters")) ~ 
      (scalaxb.ElemName(None, "tenths")) ^^
      { case p1 ~ p2 =>
      musicxml.Scaling(scalaxb.fromXML[BigDecimal](p1, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[BigDecimal](p2, scalaxb.ElemName(node) :: stack)) })
    
    def writesChildNodes(__obj: musicxml.Scaling, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(scalaxb.toXML[BigDecimal](__obj.millimeters, None, Some("millimeters"), __scope, false),
        scalaxb.toXML[BigDecimal](__obj.tenths, None, Some("tenths"), __scope, false))

  }

  trait DefaultMusicxml_Staffu45layoutFormat extends scalaxb.ElemNameParser[musicxml.Staffu45layout] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("staff-layout")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[musicxml.Staffu45layout] =
      phrase(opt(scalaxb.ElemName(None, "staff-distance")) ^^
      { case p1 =>
      musicxml.Staffu45layout(p1.headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@number").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigInt](x, scalaxb.ElemName(node) :: stack)) } map { "@number" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: musicxml.Staffu45layout, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@number", _) => __obj.number foreach { x => attr = scala.xml.Attribute(null, "number", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Staffu45layout, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.staffu45distance map { scalaxb.toXML[BigDecimal](_, None, Some("staff-distance"), __scope, false) } getOrElse {Nil})
  }

  trait DefaultMusicxml_Systemu45dividersFormat extends scalaxb.ElemNameParser[musicxml.Systemu45dividers] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("system-dividers")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[musicxml.Systemu45dividers] =
      phrase((scalaxb.ElemName(None, "left-divider")) ~ 
      (scalaxb.ElemName(None, "right-divider")) ^^
      { case p1 ~ p2 =>
      musicxml.Systemu45dividers(scalaxb.fromXML[musicxml.Emptyu45printu45objectu45styleu45align](p1, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[musicxml.Emptyu45printu45objectu45styleu45align](p2, scalaxb.ElemName(node) :: stack)) })
    
    def writesChildNodes(__obj: musicxml.Systemu45dividers, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(scalaxb.toXML[musicxml.Emptyu45printu45objectu45styleu45align](__obj.leftu45divider, None, Some("left-divider"), __scope, false),
        scalaxb.toXML[musicxml.Emptyu45printu45objectu45styleu45align](__obj.rightu45divider, None, Some("right-divider"), __scope, false))

  }

  trait DefaultMusicxml_Systemu45layoutFormat extends scalaxb.ElemNameParser[musicxml.Systemu45layout] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("system-layout")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[musicxml.Systemu45layout] =
      phrase(opt(scalaxb.ElemName(None, "system-margins")) ~ 
      opt(scalaxb.ElemName(None, "system-distance")) ~ 
      opt(scalaxb.ElemName(None, "top-system-distance")) ~ 
      opt(scalaxb.ElemName(None, "system-dividers")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      musicxml.Systemu45layout(p1.headOption map { scalaxb.fromXML[musicxml.Systemu45margins](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        p3.headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        p4.headOption map { scalaxb.fromXML[musicxml.Systemu45dividers](_, scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: musicxml.Systemu45layout, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.systemu45margins map { scalaxb.toXML[musicxml.Systemu45margins](_, None, Some("system-margins"), __scope, false) } getOrElse {Nil},
        __obj.systemu45distance map { scalaxb.toXML[BigDecimal](_, None, Some("system-distance"), __scope, false) } getOrElse {Nil},
        __obj.topu45systemu45distance map { scalaxb.toXML[BigDecimal](_, None, Some("top-system-distance"), __scope, false) } getOrElse {Nil},
        __obj.systemu45dividers map { scalaxb.toXML[musicxml.Systemu45dividers](_, None, Some("system-dividers"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultMusicxml_Systemu45marginsFormat extends scalaxb.ElemNameParser[musicxml.Systemu45margins] with Musicxml_Leftu45rightu45marginsGroupFormat {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("system-margins")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[musicxml.Systemu45margins] =
      phrase((parseLeftu45rightu45marginsGroup(node, scalaxb.ElemName(node) :: stack)) ^^
      { case p1 =>
      musicxml.Systemu45margins(p1) })
    
    def writesChildNodes(__obj: musicxml.Systemu45margins, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (scalaxb.toXML[musicxml.Leftu45rightu45marginsSequence](__obj.leftu45rightu45marginsSequence1, None, Some("leftu45rightu45marginsSequence1"), __scope, false))
  }

  trait DefaultMusicxml_BookmarkFormat extends scalaxb.XMLFormat[musicxml.Bookmark] with scalaxb.CanWriteChildNodes[musicxml.Bookmark] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Bookmark] = seq match {
      case node: scala.xml.Node => Right(musicxml.Bookmark(scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@name").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@name" -> _ },
        (node \ "@element").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@element" -> _ },
        (node \ "@position").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigInt](x, scalaxb.ElemName(node) :: stack)) } map { "@position" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Bookmark, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => attr = scala.xml.Attribute(null, "id", __obj.id.toString, attr)
        case ("@name", _) => __obj.name foreach { x => attr = scala.xml.Attribute(null, "name", x.toString, attr) }
        case ("@element", _) => __obj.element foreach { x => attr = scala.xml.Attribute(null, "element", x.toString, attr) }
        case ("@position", _) => __obj.position foreach { x => attr = scala.xml.Attribute(null, "position", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Bookmark, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil

  }

  trait DefaultMusicxml_LinkFormat extends scalaxb.XMLFormat[musicxml.Link] with scalaxb.CanWriteChildNodes[musicxml.Link] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Link] = seq match {
      case node: scala.xml.Node => Right(musicxml.Link(scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/1999/xlink}href").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[java.net.URI](x, scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/1999/xlink}href" -> _ },
        Some(scalaxb.DataRecord(None, None, scalaxb.fromXML[musicxml.Type](scala.xml.Text("simple"), scalaxb.ElemName(node) :: stack))) map { "@{http://www.w3.org/1999/xlink}type" -> _ },
        (node \ "@{http://www.w3.org/1999/xlink}role").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/1999/xlink}role" -> _ },
        (node \ "@{http://www.w3.org/1999/xlink}title").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/1999/xlink}title" -> _ },
        (node \ "@{http://www.w3.org/1999/xlink}show").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Show](x, scalaxb.ElemName(node) :: stack)) } orElse Some(scalaxb.DataRecord(None, None, scalaxb.fromXML[musicxml.Show](scala.xml.Text("replace"), scalaxb.ElemName(node) :: stack))) map { "@{http://www.w3.org/1999/xlink}show" -> _ },
        (node \ "@{http://www.w3.org/1999/xlink}actuate").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Actuate](x, scalaxb.ElemName(node) :: stack)) } orElse Some(scalaxb.DataRecord(None, None, scalaxb.fromXML[musicxml.Actuate](scala.xml.Text("onRequest"), scalaxb.ElemName(node) :: stack))) map { "@{http://www.w3.org/1999/xlink}actuate" -> _ },
        (node \ "@name").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@name" -> _ },
        (node \ "@element").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@element" -> _ },
        (node \ "@position").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigInt](x, scalaxb.ElemName(node) :: stack)) } map { "@position" -> _ },
        (node \ "@default-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-x" -> _ },
        (node \ "@default-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-y" -> _ },
        (node \ "@relative-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-x" -> _ },
        (node \ "@relative-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-y" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Link, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/1999/xlink}href", _) => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/1999/xlink"), "href", __obj.xlinkhref.toString, attr)
        case ("@{http://www.w3.org/1999/xlink}type", _) => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/1999/xlink"), "type", __obj.xlinktype.toString, attr)
        case ("@{http://www.w3.org/1999/xlink}role", _) => __obj.xlinkrole foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/1999/xlink"), "role", x.toString, attr) }
        case ("@{http://www.w3.org/1999/xlink}title", _) => __obj.xlinktitle foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/1999/xlink"), "title", x.toString, attr) }
        case ("@{http://www.w3.org/1999/xlink}show", _) => if (__obj.xlinkshow.toString != "replace") attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/1999/xlink"), "show", __obj.xlinkshow.toString, attr)
        case ("@{http://www.w3.org/1999/xlink}actuate", _) => if (__obj.xlinkactuate.toString != "onRequest") attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/1999/xlink"), "actuate", __obj.xlinkactuate.toString, attr)
        case ("@name", _) => __obj.name foreach { x => attr = scala.xml.Attribute(null, "name", x.toString, attr) }
        case ("@element", _) => __obj.element foreach { x => attr = scala.xml.Attribute(null, "element", x.toString, attr) }
        case ("@position", _) => __obj.position foreach { x => attr = scala.xml.Attribute(null, "position", x.toString, attr) }
        case ("@default-x", _) => __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.bigDecimal.toPlainString, attr) }
        case ("@default-y", _) => __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.bigDecimal.toPlainString, attr) }
        case ("@relative-x", _) => __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.bigDecimal.toPlainString, attr) }
        case ("@relative-y", _) => __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.bigDecimal.toPlainString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Link, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil

  }

  trait DefaultMusicxml_AccidentalFormat extends scalaxb.XMLFormat[musicxml.Accidental] with scalaxb.CanWriteChildNodes[musicxml.Accidental] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Accidental] = seq match {
      case node: scala.xml.Node => Right(musicxml.Accidental(scalaxb.fromXML[musicxml.Accidentalu45value](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@cautionary").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Yesu45no](x, scalaxb.ElemName(node) :: stack)) } map { "@cautionary" -> _ },
        (node \ "@editorial").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Yesu45no](x, scalaxb.ElemName(node) :: stack)) } map { "@editorial" -> _ },
        (node \ "@parentheses").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Yesu45no](x, scalaxb.ElemName(node) :: stack)) } map { "@parentheses" -> _ },
        (node \ "@bracket").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Yesu45no](x, scalaxb.ElemName(node) :: stack)) } map { "@bracket" -> _ },
        (node \ "@size").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Symbolu45size](x, scalaxb.ElemName(node) :: stack)) } map { "@size" -> _ },
        (node \ "@default-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-x" -> _ },
        (node \ "@default-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-y" -> _ },
        (node \ "@relative-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-x" -> _ },
        (node \ "@relative-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-y" -> _ },
        (node \ "@font-family").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-family" -> _ },
        (node \ "@font-style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45style](x, scalaxb.ElemName(node) :: stack)) } map { "@font-style" -> _ },
        (node \ "@font-size").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-size" -> _ },
        (node \ "@font-weight").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45weight](x, scalaxb.ElemName(node) :: stack)) } map { "@font-weight" -> _ },
        (node \ "@color").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@color" -> _ },
        (node \ "@smufl").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@smufl" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Accidental, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@cautionary", _) => __obj.cautionary foreach { x => attr = scala.xml.Attribute(null, "cautionary", x.toString, attr) }
        case ("@editorial", _) => __obj.editorial foreach { x => attr = scala.xml.Attribute(null, "editorial", x.toString, attr) }
        case ("@parentheses", _) => __obj.parentheses foreach { x => attr = scala.xml.Attribute(null, "parentheses", x.toString, attr) }
        case ("@bracket", _) => __obj.bracket foreach { x => attr = scala.xml.Attribute(null, "bracket", x.toString, attr) }
        case ("@size", _) => __obj.size foreach { x => attr = scala.xml.Attribute(null, "size", x.toString, attr) }
        case ("@default-x", _) => __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.bigDecimal.toPlainString, attr) }
        case ("@default-y", _) => __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.bigDecimal.toPlainString, attr) }
        case ("@relative-x", _) => __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.bigDecimal.toPlainString, attr) }
        case ("@relative-y", _) => __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.bigDecimal.toPlainString, attr) }
        case ("@font-family", _) => __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
        case ("@font-style", _) => __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
        case ("@font-size", _) => __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
        case ("@font-weight", _) => __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
        case ("@color", _) => __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
        case ("@smufl", _) => __obj.smufl foreach { x => attr = scala.xml.Attribute(null, "smufl", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Accidental, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultMusicxml_Accidentalu45markFormat extends scalaxb.XMLFormat[musicxml.Accidentalu45mark] with scalaxb.CanWriteChildNodes[musicxml.Accidentalu45mark] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Accidentalu45mark] = seq match {
      case node: scala.xml.Node => Right(musicxml.Accidentalu45mark(scalaxb.fromXML[musicxml.Accidentalu45value](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@parentheses").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Yesu45no](x, scalaxb.ElemName(node) :: stack)) } map { "@parentheses" -> _ },
        (node \ "@bracket").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Yesu45no](x, scalaxb.ElemName(node) :: stack)) } map { "@bracket" -> _ },
        (node \ "@size").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Symbolu45size](x, scalaxb.ElemName(node) :: stack)) } map { "@size" -> _ },
        (node \ "@default-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-x" -> _ },
        (node \ "@default-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-y" -> _ },
        (node \ "@relative-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-x" -> _ },
        (node \ "@relative-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-y" -> _ },
        (node \ "@font-family").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-family" -> _ },
        (node \ "@font-style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45style](x, scalaxb.ElemName(node) :: stack)) } map { "@font-style" -> _ },
        (node \ "@font-size").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-size" -> _ },
        (node \ "@font-weight").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45weight](x, scalaxb.ElemName(node) :: stack)) } map { "@font-weight" -> _ },
        (node \ "@color").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@color" -> _ },
        (node \ "@placement").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Aboveu45below](x, scalaxb.ElemName(node) :: stack)) } map { "@placement" -> _ },
        (node \ "@smufl").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@smufl" -> _ },
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Accidentalu45mark, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@parentheses", _) => __obj.parentheses foreach { x => attr = scala.xml.Attribute(null, "parentheses", x.toString, attr) }
        case ("@bracket", _) => __obj.bracket foreach { x => attr = scala.xml.Attribute(null, "bracket", x.toString, attr) }
        case ("@size", _) => __obj.size foreach { x => attr = scala.xml.Attribute(null, "size", x.toString, attr) }
        case ("@default-x", _) => __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.bigDecimal.toPlainString, attr) }
        case ("@default-y", _) => __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.bigDecimal.toPlainString, attr) }
        case ("@relative-x", _) => __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.bigDecimal.toPlainString, attr) }
        case ("@relative-y", _) => __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.bigDecimal.toPlainString, attr) }
        case ("@font-family", _) => __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
        case ("@font-style", _) => __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
        case ("@font-size", _) => __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
        case ("@font-weight", _) => __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
        case ("@color", _) => __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
        case ("@placement", _) => __obj.placement foreach { x => attr = scala.xml.Attribute(null, "placement", x.toString, attr) }
        case ("@smufl", _) => __obj.smufl foreach { x => attr = scala.xml.Attribute(null, "smufl", x.toString, attr) }
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Accidentalu45mark, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultMusicxml_ArpeggiateFormat extends scalaxb.XMLFormat[musicxml.Arpeggiate] with scalaxb.CanWriteChildNodes[musicxml.Arpeggiate] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Arpeggiate] = seq match {
      case node: scala.xml.Node => Right(musicxml.Arpeggiate(scala.collection.immutable.ListMap(List(
        (node \ "@number").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigInt](x, scalaxb.ElemName(node) :: stack)) } map { "@number" -> _ },
        (node \ "@direction").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Upu45down](x, scalaxb.ElemName(node) :: stack)) } map { "@direction" -> _ },
        (node \ "@default-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-x" -> _ },
        (node \ "@default-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-y" -> _ },
        (node \ "@relative-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-x" -> _ },
        (node \ "@relative-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-y" -> _ },
        (node \ "@placement").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Aboveu45below](x, scalaxb.ElemName(node) :: stack)) } map { "@placement" -> _ },
        (node \ "@color").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@color" -> _ },
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Arpeggiate, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@number", _) => __obj.number foreach { x => attr = scala.xml.Attribute(null, "number", x.toString, attr) }
        case ("@direction", _) => __obj.direction foreach { x => attr = scala.xml.Attribute(null, "direction", x.toString, attr) }
        case ("@default-x", _) => __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.bigDecimal.toPlainString, attr) }
        case ("@default-y", _) => __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.bigDecimal.toPlainString, attr) }
        case ("@relative-x", _) => __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.bigDecimal.toPlainString, attr) }
        case ("@relative-y", _) => __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.bigDecimal.toPlainString, attr) }
        case ("@placement", _) => __obj.placement foreach { x => attr = scala.xml.Attribute(null, "placement", x.toString, attr) }
        case ("@color", _) => __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Arpeggiate, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil

  }

  trait DefaultMusicxml_ArticulationsFormat extends scalaxb.ElemNameParser[musicxml.Articulations] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("articulations")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[musicxml.Articulations] =
      phrase(safeRep(((scalaxb.ElemName(None, "accent")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Emptyu45placementable](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "strong-accent")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Strongu45accent](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "staccato")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Emptyu45placementable](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "tenuto")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Emptyu45placementable](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "detached-legato")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Emptyu45placementable](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "staccatissimo")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Emptyu45placementable](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "spiccato")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Emptyu45placementable](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "scoop")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Emptyu45line](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "plop")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Emptyu45line](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "doit")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Emptyu45line](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "falloff")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Emptyu45line](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "breath-mark")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Breathu45mark](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "caesura")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Caesura](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "stress")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Emptyu45placementable](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "unstress")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Emptyu45placementable](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "soft-accent")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Emptyu45placementable](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "other-articulation")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Otheru45placementu45text](x, scalaxb.ElemName(node) :: stack))))) ^^
      { case p1 =>
      musicxml.Articulations(p1,
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: musicxml.Articulations, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Articulations, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.articulationsoption flatMap { x => scalaxb.toXML[scalaxb.DataRecord[musicxml.ArticulationsOption]](x, x.namespace, x.key, __scope, false) })
  }

  trait DefaultMusicxml_ArrowTypeFormat extends scalaxb.ElemNameParser[musicxml.ArrowType] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("arrow")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[musicxml.ArrowType] =
      phrase(((((scalaxb.ElemName(None, "arrow-direction")) ~ 
      opt(scalaxb.ElemName(None, "arrow-style")) ~ 
      opt(scalaxb.ElemName(None, "arrowhead"))) ^^ 
        { case p1 ~ p2 ~ p3 => scalaxb.DataRecord(musicxml.ArrowTypeSequence1(scalaxb.fromXML[musicxml.Arrowu45direction](p1, scalaxb.ElemName(node) :: stack),
        p2.headOption map { scalaxb.fromXML[musicxml.Arrowu45style](_, scalaxb.ElemName(node) :: stack) },
        p3.headOption map { scalaxb.fromXML[musicxml.Empty](_, scalaxb.ElemName(node) :: stack) })) }) ||| 
      ((scalaxb.ElemName(None, "circular-arrow")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack))))) ^^
      { case p1 =>
      musicxml.ArrowType(p1,
        scala.collection.immutable.ListMap(List(
        (node \ "@default-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-x" -> _ },
        (node \ "@default-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-y" -> _ },
        (node \ "@relative-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-x" -> _ },
        (node \ "@relative-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-y" -> _ },
        (node \ "@font-family").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-family" -> _ },
        (node \ "@font-style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45style](x, scalaxb.ElemName(node) :: stack)) } map { "@font-style" -> _ },
        (node \ "@font-size").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-size" -> _ },
        (node \ "@font-weight").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45weight](x, scalaxb.ElemName(node) :: stack)) } map { "@font-weight" -> _ },
        (node \ "@color").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@color" -> _ },
        (node \ "@placement").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Aboveu45below](x, scalaxb.ElemName(node) :: stack)) } map { "@placement" -> _ },
        (node \ "@smufl").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@smufl" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: musicxml.ArrowType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@default-x", _) => __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.bigDecimal.toPlainString, attr) }
        case ("@default-y", _) => __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.bigDecimal.toPlainString, attr) }
        case ("@relative-x", _) => __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.bigDecimal.toPlainString, attr) }
        case ("@relative-y", _) => __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.bigDecimal.toPlainString, attr) }
        case ("@font-family", _) => __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
        case ("@font-style", _) => __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
        case ("@font-size", _) => __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
        case ("@font-weight", _) => __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
        case ("@color", _) => __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
        case ("@placement", _) => __obj.placement foreach { x => attr = scala.xml.Attribute(null, "placement", x.toString, attr) }
        case ("@smufl", _) => __obj.smufl foreach { x => attr = scala.xml.Attribute(null, "smufl", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.ArrowType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      ((Some(__obj.arrowtypeoption) map {x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false)}).get)
  }

  trait DefaultMusicxml_ArrowTypeSequence1Format extends scalaxb.XMLFormat[musicxml.ArrowTypeSequence1] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.ArrowTypeSequence1] = Left("don't call me.")
    
    def writes(__obj: musicxml.ArrowTypeSequence1, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(scalaxb.toXML[musicxml.Arrowu45direction](__obj.arrowu45direction, None, Some("arrow-direction"), __scope, false),
        __obj.arrowu45style map { scalaxb.toXML[musicxml.Arrowu45style](_, None, Some("arrow-style"), __scope, false) } getOrElse {Nil},
        __obj.arrowhead map { scalaxb.toXML[musicxml.Empty](_, None, Some("arrowhead"), __scope, false) } getOrElse {Nil})


  }

  trait DefaultMusicxml_BackupFormat extends scalaxb.ElemNameParser[musicxml.Backup] with Musicxml_DurationGroupFormat with Musicxml_EditorialGroupFormat {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("backup")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[musicxml.Backup] =
      phrase((parseDurationGroup(node, scalaxb.ElemName(node) :: stack)) ~ 
      (parseEditorialGroup(node, scalaxb.ElemName(node) :: stack)) ^^
      { case p1 ~ p2 =>
      musicxml.Backup(p1,
        p2) })
    
    def writesChildNodes(__obj: musicxml.Backup, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(scalaxb.toXML[musicxml.DurationSequence](__obj.durationSequence1, None, Some("durationSequence1"), __scope, false),
        scalaxb.toXML[musicxml.EditorialSequence](__obj.editorialSequence2, None, Some("editorialSequence2"), __scope, false))

  }

  trait DefaultMusicxml_BeamFormat extends scalaxb.XMLFormat[musicxml.Beam] with scalaxb.CanWriteChildNodes[musicxml.Beam] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Beam] = seq match {
      case node: scala.xml.Node => Right(musicxml.Beam(scalaxb.fromXML[musicxml.Beamu45value](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@number").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigInt](x, scalaxb.ElemName(node) :: stack)) } orElse Some(scalaxb.DataRecord(None, None, scalaxb.fromXML[BigInt](scala.xml.Text("1"), scalaxb.ElemName(node) :: stack))) map { "@number" -> _ },
        (node \ "@repeater").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Yesu45no](x, scalaxb.ElemName(node) :: stack)) } map { "@repeater" -> _ },
        (node \ "@fan").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fan](x, scalaxb.ElemName(node) :: stack)) } map { "@fan" -> _ },
        (node \ "@color").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@color" -> _ },
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Beam, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@number", _) => if (__obj.number.toString != "1") attr = scala.xml.Attribute(null, "number", __obj.number.toString, attr)
        case ("@repeater", _) => __obj.repeater foreach { x => attr = scala.xml.Attribute(null, "repeater", x.toString, attr) }
        case ("@fan", _) => __obj.fan foreach { x => attr = scala.xml.Attribute(null, "fan", x.toString, attr) }
        case ("@color", _) => __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Beam, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultMusicxml_BendFormat extends scalaxb.ElemNameParser[musicxml.Bend] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("bend")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[musicxml.Bend] =
      phrase((scalaxb.ElemName(None, "bend-alter")) ~ 
      opt(((scalaxb.ElemName(None, "pre-bend")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Empty](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "release")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Empty](x, scalaxb.ElemName(node) :: stack))))) ~ 
      opt(scalaxb.ElemName(None, "with-bar")) ^^
      { case p1 ~ p2 ~ p3 =>
      musicxml.Bend(scalaxb.fromXML[BigDecimal](p1, scalaxb.ElemName(node) :: stack),
        p2,
        p3.headOption map { scalaxb.fromXML[musicxml.Placementu45text](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@default-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-x" -> _ },
        (node \ "@default-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-y" -> _ },
        (node \ "@relative-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-x" -> _ },
        (node \ "@relative-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-y" -> _ },
        (node \ "@font-family").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-family" -> _ },
        (node \ "@font-style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45style](x, scalaxb.ElemName(node) :: stack)) } map { "@font-style" -> _ },
        (node \ "@font-size").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-size" -> _ },
        (node \ "@font-weight").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45weight](x, scalaxb.ElemName(node) :: stack)) } map { "@font-weight" -> _ },
        (node \ "@color").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@color" -> _ },
        (node \ "@accelerate").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Yesu45no](x, scalaxb.ElemName(node) :: stack)) } map { "@accelerate" -> _ },
        (node \ "@beats").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@beats" -> _ },
        (node \ "@first-beat").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@first-beat" -> _ },
        (node \ "@last-beat").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@last-beat" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: musicxml.Bend, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@default-x", _) => __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.bigDecimal.toPlainString, attr) }
        case ("@default-y", _) => __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.bigDecimal.toPlainString, attr) }
        case ("@relative-x", _) => __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.bigDecimal.toPlainString, attr) }
        case ("@relative-y", _) => __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.bigDecimal.toPlainString, attr) }
        case ("@font-family", _) => __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
        case ("@font-style", _) => __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
        case ("@font-size", _) => __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
        case ("@font-weight", _) => __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
        case ("@color", _) => __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
        case ("@accelerate", _) => __obj.accelerate foreach { x => attr = scala.xml.Attribute(null, "accelerate", x.toString, attr) }
        case ("@beats", _) => __obj.beats foreach { x => attr = scala.xml.Attribute(null, "beats", x.bigDecimal.toPlainString, attr) }
        case ("@first-beat", _) => __obj.firstu45beat foreach { x => attr = scala.xml.Attribute(null, "first-beat", x.bigDecimal.toPlainString, attr) }
        case ("@last-beat", _) => __obj.lastu45beat foreach { x => attr = scala.xml.Attribute(null, "last-beat", x.bigDecimal.toPlainString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Bend, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(scalaxb.toXML[BigDecimal](__obj.bendu45alter, None, Some("bend-alter"), __scope, false),
        __obj.bendoption map { x => scalaxb.toXML[scalaxb.DataRecord[musicxml.BendOption]](x, x.namespace, x.key, __scope, false) } getOrElse {Nil},
        __obj.withu45bar map { scalaxb.toXML[musicxml.Placementu45text](_, None, Some("with-bar"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultMusicxml_Breathu45markFormat extends scalaxb.XMLFormat[musicxml.Breathu45mark] with scalaxb.CanWriteChildNodes[musicxml.Breathu45mark] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Breathu45mark] = seq match {
      case node: scala.xml.Node => Right(musicxml.Breathu45mark(scalaxb.fromXML[musicxml.Breathu45marku45value](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@default-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-x" -> _ },
        (node \ "@default-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-y" -> _ },
        (node \ "@relative-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-x" -> _ },
        (node \ "@relative-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-y" -> _ },
        (node \ "@font-family").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-family" -> _ },
        (node \ "@font-style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45style](x, scalaxb.ElemName(node) :: stack)) } map { "@font-style" -> _ },
        (node \ "@font-size").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-size" -> _ },
        (node \ "@font-weight").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45weight](x, scalaxb.ElemName(node) :: stack)) } map { "@font-weight" -> _ },
        (node \ "@color").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@color" -> _ },
        (node \ "@placement").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Aboveu45below](x, scalaxb.ElemName(node) :: stack)) } map { "@placement" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Breathu45mark, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@default-x", _) => __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.bigDecimal.toPlainString, attr) }
        case ("@default-y", _) => __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.bigDecimal.toPlainString, attr) }
        case ("@relative-x", _) => __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.bigDecimal.toPlainString, attr) }
        case ("@relative-y", _) => __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.bigDecimal.toPlainString, attr) }
        case ("@font-family", _) => __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
        case ("@font-style", _) => __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
        case ("@font-size", _) => __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
        case ("@font-weight", _) => __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
        case ("@color", _) => __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
        case ("@placement", _) => __obj.placement foreach { x => attr = scala.xml.Attribute(null, "placement", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Breathu45mark, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultMusicxml_CaesuraFormat extends scalaxb.XMLFormat[musicxml.Caesura] with scalaxb.CanWriteChildNodes[musicxml.Caesura] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Caesura] = seq match {
      case node: scala.xml.Node => Right(musicxml.Caesura(scalaxb.fromXML[musicxml.Caesurau45value](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@default-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-x" -> _ },
        (node \ "@default-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-y" -> _ },
        (node \ "@relative-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-x" -> _ },
        (node \ "@relative-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-y" -> _ },
        (node \ "@font-family").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-family" -> _ },
        (node \ "@font-style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45style](x, scalaxb.ElemName(node) :: stack)) } map { "@font-style" -> _ },
        (node \ "@font-size").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-size" -> _ },
        (node \ "@font-weight").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45weight](x, scalaxb.ElemName(node) :: stack)) } map { "@font-weight" -> _ },
        (node \ "@color").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@color" -> _ },
        (node \ "@placement").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Aboveu45below](x, scalaxb.ElemName(node) :: stack)) } map { "@placement" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Caesura, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@default-x", _) => __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.bigDecimal.toPlainString, attr) }
        case ("@default-y", _) => __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.bigDecimal.toPlainString, attr) }
        case ("@relative-x", _) => __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.bigDecimal.toPlainString, attr) }
        case ("@relative-y", _) => __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.bigDecimal.toPlainString, attr) }
        case ("@font-family", _) => __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
        case ("@font-style", _) => __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
        case ("@font-size", _) => __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
        case ("@font-weight", _) => __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
        case ("@color", _) => __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
        case ("@placement", _) => __obj.placement foreach { x => attr = scala.xml.Attribute(null, "placement", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Caesura, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultMusicxml_ElisionFormat extends scalaxb.XMLFormat[musicxml.Elision] with scalaxb.CanWriteChildNodes[musicxml.Elision] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Elision] = seq match {
      case node: scala.xml.Node => Right(musicxml.Elision(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@font-family").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-family" -> _ },
        (node \ "@font-style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45style](x, scalaxb.ElemName(node) :: stack)) } map { "@font-style" -> _ },
        (node \ "@font-size").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-size" -> _ },
        (node \ "@font-weight").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45weight](x, scalaxb.ElemName(node) :: stack)) } map { "@font-weight" -> _ },
        (node \ "@color").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@color" -> _ },
        (node \ "@smufl").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@smufl" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Elision, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@font-family", _) => __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
        case ("@font-style", _) => __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
        case ("@font-size", _) => __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
        case ("@font-weight", _) => __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
        case ("@color", _) => __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
        case ("@smufl", _) => __obj.smufl foreach { x => attr = scala.xml.Attribute(null, "smufl", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Elision, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultMusicxml_Emptyu45lineFormat extends scalaxb.XMLFormat[musicxml.Emptyu45line] with scalaxb.CanWriteChildNodes[musicxml.Emptyu45line] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Emptyu45line] = seq match {
      case node: scala.xml.Node => Right(musicxml.Emptyu45line(scala.collection.immutable.ListMap(List(
        (node \ "@line-shape").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Lineu45shape](x, scalaxb.ElemName(node) :: stack)) } map { "@line-shape" -> _ },
        (node \ "@line-type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Lineu45type](x, scalaxb.ElemName(node) :: stack)) } map { "@line-type" -> _ },
        (node \ "@line-length").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Lineu45length](x, scalaxb.ElemName(node) :: stack)) } map { "@line-length" -> _ },
        (node \ "@dash-length").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@dash-length" -> _ },
        (node \ "@space-length").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@space-length" -> _ },
        (node \ "@default-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-x" -> _ },
        (node \ "@default-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-y" -> _ },
        (node \ "@relative-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-x" -> _ },
        (node \ "@relative-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-y" -> _ },
        (node \ "@font-family").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-family" -> _ },
        (node \ "@font-style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45style](x, scalaxb.ElemName(node) :: stack)) } map { "@font-style" -> _ },
        (node \ "@font-size").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-size" -> _ },
        (node \ "@font-weight").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45weight](x, scalaxb.ElemName(node) :: stack)) } map { "@font-weight" -> _ },
        (node \ "@color").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@color" -> _ },
        (node \ "@placement").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Aboveu45below](x, scalaxb.ElemName(node) :: stack)) } map { "@placement" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Emptyu45line, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@line-shape", _) => __obj.lineu45shape foreach { x => attr = scala.xml.Attribute(null, "line-shape", x.toString, attr) }
        case ("@line-type", _) => __obj.lineu45type foreach { x => attr = scala.xml.Attribute(null, "line-type", x.toString, attr) }
        case ("@line-length", _) => __obj.lineu45length foreach { x => attr = scala.xml.Attribute(null, "line-length", x.toString, attr) }
        case ("@dash-length", _) => __obj.dashu45length foreach { x => attr = scala.xml.Attribute(null, "dash-length", x.bigDecimal.toPlainString, attr) }
        case ("@space-length", _) => __obj.spaceu45length foreach { x => attr = scala.xml.Attribute(null, "space-length", x.bigDecimal.toPlainString, attr) }
        case ("@default-x", _) => __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.bigDecimal.toPlainString, attr) }
        case ("@default-y", _) => __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.bigDecimal.toPlainString, attr) }
        case ("@relative-x", _) => __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.bigDecimal.toPlainString, attr) }
        case ("@relative-y", _) => __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.bigDecimal.toPlainString, attr) }
        case ("@font-family", _) => __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
        case ("@font-style", _) => __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
        case ("@font-size", _) => __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
        case ("@font-weight", _) => __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
        case ("@color", _) => __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
        case ("@placement", _) => __obj.placement foreach { x => attr = scala.xml.Attribute(null, "placement", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Emptyu45line, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil

  }

  trait DefaultMusicxml_ExtendFormat extends scalaxb.XMLFormat[musicxml.Extend] with scalaxb.CanWriteChildNodes[musicxml.Extend] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Extend] = seq match {
      case node: scala.xml.Node => Right(musicxml.Extend(scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Startu45stopu45continue](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ },
        (node \ "@default-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-x" -> _ },
        (node \ "@default-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-y" -> _ },
        (node \ "@relative-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-x" -> _ },
        (node \ "@relative-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-y" -> _ },
        (node \ "@color").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@color" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Extend, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => __obj.typeValue foreach { x => attr = scala.xml.Attribute(null, "type", x.toString, attr) }
        case ("@default-x", _) => __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.bigDecimal.toPlainString, attr) }
        case ("@default-y", _) => __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.bigDecimal.toPlainString, attr) }
        case ("@relative-x", _) => __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.bigDecimal.toPlainString, attr) }
        case ("@relative-y", _) => __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.bigDecimal.toPlainString, attr) }
        case ("@color", _) => __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Extend, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil

  }

  trait DefaultMusicxml_FigureFormat extends scalaxb.ElemNameParser[musicxml.Figure] with Musicxml_EditorialGroupFormat {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("figure")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[musicxml.Figure] =
      phrase(opt(scalaxb.ElemName(None, "prefix")) ~ 
      opt(scalaxb.ElemName(None, "figure-number")) ~ 
      opt(scalaxb.ElemName(None, "suffix")) ~ 
      opt(scalaxb.ElemName(None, "extend")) ~ 
      (parseEditorialGroup(node, scalaxb.ElemName(node) :: stack)) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 =>
      musicxml.Figure(p1.headOption map { scalaxb.fromXML[musicxml.Styleu45text](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[musicxml.Styleu45text](_, scalaxb.ElemName(node) :: stack) },
        p3.headOption map { scalaxb.fromXML[musicxml.Styleu45text](_, scalaxb.ElemName(node) :: stack) },
        p4.headOption map { scalaxb.fromXML[musicxml.Extend](_, scalaxb.ElemName(node) :: stack) },
        p5) })
    
    def writesChildNodes(__obj: musicxml.Figure, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.prefix map { scalaxb.toXML[musicxml.Styleu45text](_, None, Some("prefix"), __scope, false) } getOrElse {Nil},
        __obj.figureu45number map { scalaxb.toXML[musicxml.Styleu45text](_, None, Some("figure-number"), __scope, false) } getOrElse {Nil},
        __obj.suffix map { scalaxb.toXML[musicxml.Styleu45text](_, None, Some("suffix"), __scope, false) } getOrElse {Nil},
        __obj.extend map { scalaxb.toXML[musicxml.Extend](_, None, Some("extend"), __scope, false) } getOrElse {Nil},
        scalaxb.toXML[musicxml.EditorialSequence](__obj.editorialSequence5, None, Some("editorialSequence5"), __scope, false))

  }

  trait DefaultMusicxml_Figuredu45bassFormat extends scalaxb.ElemNameParser[musicxml.Figuredu45bass] with Musicxml_DurationGroupFormat with Musicxml_EditorialGroupFormat {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("figured-bass")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[musicxml.Figuredu45bass] =
      phrase(safeRep(scalaxb.ElemName(None, "figure")) ~ 
      opt(parseDurationGroup(node, scalaxb.ElemName(node) :: stack)) ~ 
      (parseEditorialGroup(node, scalaxb.ElemName(node) :: stack)) ^^
      { case p1 ~ p2 ~ p3 =>
      musicxml.Figuredu45bass(p1 map { scalaxb.fromXML[musicxml.Figure](_, scalaxb.ElemName(node) :: stack) },
        p2,
        p3,
        scala.collection.immutable.ListMap(List(
        (node \ "@default-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-x" -> _ },
        (node \ "@default-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-y" -> _ },
        (node \ "@relative-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-x" -> _ },
        (node \ "@relative-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-y" -> _ },
        (node \ "@font-family").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-family" -> _ },
        (node \ "@font-style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45style](x, scalaxb.ElemName(node) :: stack)) } map { "@font-style" -> _ },
        (node \ "@font-size").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-size" -> _ },
        (node \ "@font-weight").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45weight](x, scalaxb.ElemName(node) :: stack)) } map { "@font-weight" -> _ },
        (node \ "@color").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@color" -> _ },
        (node \ "@print-object").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Yesu45no](x, scalaxb.ElemName(node) :: stack)) } map { "@print-object" -> _ },
        (node \ "@print-dot").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Yesu45no](x, scalaxb.ElemName(node) :: stack)) } map { "@print-dot" -> _ },
        (node \ "@print-spacing").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Yesu45no](x, scalaxb.ElemName(node) :: stack)) } map { "@print-spacing" -> _ },
        (node \ "@print-lyric").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Yesu45no](x, scalaxb.ElemName(node) :: stack)) } map { "@print-lyric" -> _ },
        (node \ "@parentheses").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Yesu45no](x, scalaxb.ElemName(node) :: stack)) } map { "@parentheses" -> _ },
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: musicxml.Figuredu45bass, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@default-x", _) => __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.bigDecimal.toPlainString, attr) }
        case ("@default-y", _) => __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.bigDecimal.toPlainString, attr) }
        case ("@relative-x", _) => __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.bigDecimal.toPlainString, attr) }
        case ("@relative-y", _) => __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.bigDecimal.toPlainString, attr) }
        case ("@font-family", _) => __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
        case ("@font-style", _) => __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
        case ("@font-size", _) => __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
        case ("@font-weight", _) => __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
        case ("@color", _) => __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
        case ("@print-object", _) => __obj.printu45object foreach { x => attr = scala.xml.Attribute(null, "print-object", x.toString, attr) }
        case ("@print-dot", _) => __obj.printu45dot foreach { x => attr = scala.xml.Attribute(null, "print-dot", x.toString, attr) }
        case ("@print-spacing", _) => __obj.printu45spacing foreach { x => attr = scala.xml.Attribute(null, "print-spacing", x.toString, attr) }
        case ("@print-lyric", _) => __obj.printu45lyric foreach { x => attr = scala.xml.Attribute(null, "print-lyric", x.toString, attr) }
        case ("@parentheses", _) => __obj.parentheses foreach { x => attr = scala.xml.Attribute(null, "parentheses", x.toString, attr) }
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Figuredu45bass, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.figure flatMap { scalaxb.toXML[musicxml.Figure](_, None, Some("figure"), __scope, false) },
        __obj.durationSequence2 map { scalaxb.toXML[musicxml.DurationSequence](_, None, Some("durationSequence2"), __scope, false) } getOrElse {Nil},
        scalaxb.toXML[musicxml.EditorialSequence](__obj.editorialSequence3, None, Some("editorialSequence3"), __scope, false))

  }

  trait DefaultMusicxml_ForwardFormat extends scalaxb.ElemNameParser[musicxml.Forward] with Musicxml_DurationGroupFormat with Musicxml_Editorialu45voiceGroupFormat with Musicxml_StaffGroupFormat {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("forward")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[musicxml.Forward] =
      phrase((parseDurationGroup(node, scalaxb.ElemName(node) :: stack)) ~ 
      (parseEditorialu45voiceGroup(node, scalaxb.ElemName(node) :: stack)) ~ 
      opt(parseStaffGroup(node, scalaxb.ElemName(node) :: stack)) ^^
      { case p1 ~ p2 ~ p3 =>
      musicxml.Forward(p1,
        p2,
        p3) })
    
    def writesChildNodes(__obj: musicxml.Forward, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(scalaxb.toXML[musicxml.DurationSequence](__obj.durationSequence1, None, Some("durationSequence1"), __scope, false),
        scalaxb.toXML[musicxml.Editorialu45voiceSequence](__obj.editorialu45voiceSequence2, None, Some("editorialu45voiceSequence2"), __scope, false),
        __obj.staffSequence3 map { scalaxb.toXML[musicxml.StaffSequence](_, None, Some("staffSequence3"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultMusicxml_GlissandoFormat extends scalaxb.XMLFormat[musicxml.Glissando] with scalaxb.CanWriteChildNodes[musicxml.Glissando] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Glissando] = seq match {
      case node: scala.xml.Node => Right(musicxml.Glissando(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Startu45stop](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ },
        (node \ "@number").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigInt](x, scalaxb.ElemName(node) :: stack)) } orElse Some(scalaxb.DataRecord(None, None, scalaxb.fromXML[BigInt](scala.xml.Text("1"), scalaxb.ElemName(node) :: stack))) map { "@number" -> _ },
        (node \ "@line-type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Lineu45type](x, scalaxb.ElemName(node) :: stack)) } map { "@line-type" -> _ },
        (node \ "@dash-length").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@dash-length" -> _ },
        (node \ "@space-length").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@space-length" -> _ },
        (node \ "@default-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-x" -> _ },
        (node \ "@default-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-y" -> _ },
        (node \ "@relative-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-x" -> _ },
        (node \ "@relative-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-y" -> _ },
        (node \ "@font-family").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-family" -> _ },
        (node \ "@font-style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45style](x, scalaxb.ElemName(node) :: stack)) } map { "@font-style" -> _ },
        (node \ "@font-size").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-size" -> _ },
        (node \ "@font-weight").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45weight](x, scalaxb.ElemName(node) :: stack)) } map { "@font-weight" -> _ },
        (node \ "@color").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@color" -> _ },
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Glissando, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case ("@number", _) => if (__obj.number.toString != "1") attr = scala.xml.Attribute(null, "number", __obj.number.toString, attr)
        case ("@line-type", _) => __obj.lineu45type foreach { x => attr = scala.xml.Attribute(null, "line-type", x.toString, attr) }
        case ("@dash-length", _) => __obj.dashu45length foreach { x => attr = scala.xml.Attribute(null, "dash-length", x.bigDecimal.toPlainString, attr) }
        case ("@space-length", _) => __obj.spaceu45length foreach { x => attr = scala.xml.Attribute(null, "space-length", x.bigDecimal.toPlainString, attr) }
        case ("@default-x", _) => __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.bigDecimal.toPlainString, attr) }
        case ("@default-y", _) => __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.bigDecimal.toPlainString, attr) }
        case ("@relative-x", _) => __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.bigDecimal.toPlainString, attr) }
        case ("@relative-y", _) => __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.bigDecimal.toPlainString, attr) }
        case ("@font-family", _) => __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
        case ("@font-style", _) => __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
        case ("@font-size", _) => __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
        case ("@font-weight", _) => __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
        case ("@color", _) => __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Glissando, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultMusicxml_GraceFormat extends scalaxb.XMLFormat[musicxml.Grace] with scalaxb.CanWriteChildNodes[musicxml.Grace] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Grace] = seq match {
      case node: scala.xml.Node => Right(musicxml.Grace(scala.collection.immutable.ListMap(List(
        (node \ "@steal-time-previous").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@steal-time-previous" -> _ },
        (node \ "@steal-time-following").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@steal-time-following" -> _ },
        (node \ "@make-time").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@make-time" -> _ },
        (node \ "@slash").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Yesu45no](x, scalaxb.ElemName(node) :: stack)) } map { "@slash" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Grace, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@steal-time-previous", _) => __obj.stealu45timeu45previous foreach { x => attr = scala.xml.Attribute(null, "steal-time-previous", x.bigDecimal.toPlainString, attr) }
        case ("@steal-time-following", _) => __obj.stealu45timeu45following foreach { x => attr = scala.xml.Attribute(null, "steal-time-following", x.bigDecimal.toPlainString, attr) }
        case ("@make-time", _) => __obj.makeu45time foreach { x => attr = scala.xml.Attribute(null, "make-time", x.bigDecimal.toPlainString, attr) }
        case ("@slash", _) => __obj.slash foreach { x => attr = scala.xml.Attribute(null, "slash", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Grace, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil

  }

  trait DefaultMusicxml_Hammeru45onu45pullu45offFormat extends scalaxb.XMLFormat[musicxml.Hammeru45onu45pullu45off] with scalaxb.CanWriteChildNodes[musicxml.Hammeru45onu45pullu45off] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Hammeru45onu45pullu45off] = seq match {
      case node: scala.xml.Node => Right(musicxml.Hammeru45onu45pullu45off(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Startu45stop](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ },
        (node \ "@number").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigInt](x, scalaxb.ElemName(node) :: stack)) } orElse Some(scalaxb.DataRecord(None, None, scalaxb.fromXML[BigInt](scala.xml.Text("1"), scalaxb.ElemName(node) :: stack))) map { "@number" -> _ },
        (node \ "@default-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-x" -> _ },
        (node \ "@default-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-y" -> _ },
        (node \ "@relative-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-x" -> _ },
        (node \ "@relative-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-y" -> _ },
        (node \ "@font-family").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-family" -> _ },
        (node \ "@font-style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45style](x, scalaxb.ElemName(node) :: stack)) } map { "@font-style" -> _ },
        (node \ "@font-size").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-size" -> _ },
        (node \ "@font-weight").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45weight](x, scalaxb.ElemName(node) :: stack)) } map { "@font-weight" -> _ },
        (node \ "@color").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@color" -> _ },
        (node \ "@placement").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Aboveu45below](x, scalaxb.ElemName(node) :: stack)) } map { "@placement" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Hammeru45onu45pullu45off, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case ("@number", _) => if (__obj.number.toString != "1") attr = scala.xml.Attribute(null, "number", __obj.number.toString, attr)
        case ("@default-x", _) => __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.bigDecimal.toPlainString, attr) }
        case ("@default-y", _) => __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.bigDecimal.toPlainString, attr) }
        case ("@relative-x", _) => __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.bigDecimal.toPlainString, attr) }
        case ("@relative-y", _) => __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.bigDecimal.toPlainString, attr) }
        case ("@font-family", _) => __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
        case ("@font-style", _) => __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
        case ("@font-size", _) => __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
        case ("@font-weight", _) => __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
        case ("@color", _) => __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
        case ("@placement", _) => __obj.placement foreach { x => attr = scala.xml.Attribute(null, "placement", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Hammeru45onu45pullu45off, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultMusicxml_HandbellFormat extends scalaxb.XMLFormat[musicxml.Handbell] with scalaxb.CanWriteChildNodes[musicxml.Handbell] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Handbell] = seq match {
      case node: scala.xml.Node => Right(musicxml.Handbell(scalaxb.fromXML[musicxml.Handbellu45value](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@default-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-x" -> _ },
        (node \ "@default-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-y" -> _ },
        (node \ "@relative-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-x" -> _ },
        (node \ "@relative-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-y" -> _ },
        (node \ "@font-family").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-family" -> _ },
        (node \ "@font-style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45style](x, scalaxb.ElemName(node) :: stack)) } map { "@font-style" -> _ },
        (node \ "@font-size").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-size" -> _ },
        (node \ "@font-weight").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45weight](x, scalaxb.ElemName(node) :: stack)) } map { "@font-weight" -> _ },
        (node \ "@color").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@color" -> _ },
        (node \ "@placement").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Aboveu45below](x, scalaxb.ElemName(node) :: stack)) } map { "@placement" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Handbell, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@default-x", _) => __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.bigDecimal.toPlainString, attr) }
        case ("@default-y", _) => __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.bigDecimal.toPlainString, attr) }
        case ("@relative-x", _) => __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.bigDecimal.toPlainString, attr) }
        case ("@relative-y", _) => __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.bigDecimal.toPlainString, attr) }
        case ("@font-family", _) => __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
        case ("@font-style", _) => __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
        case ("@font-size", _) => __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
        case ("@font-weight", _) => __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
        case ("@color", _) => __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
        case ("@placement", _) => __obj.placement foreach { x => attr = scala.xml.Attribute(null, "placement", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Handbell, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultMusicxml_Harmonu45closedFormat extends scalaxb.XMLFormat[musicxml.Harmonu45closed] with scalaxb.CanWriteChildNodes[musicxml.Harmonu45closed] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Harmonu45closed] = seq match {
      case node: scala.xml.Node => Right(musicxml.Harmonu45closed(scalaxb.fromXML[musicxml.Harmonu45closedu45value](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@location").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Harmonu45closedu45location](x, scalaxb.ElemName(node) :: stack)) } map { "@location" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Harmonu45closed, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@location", _) => __obj.location foreach { x => attr = scala.xml.Attribute(null, "location", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Harmonu45closed, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultMusicxml_Harmonu45muteFormat extends scalaxb.ElemNameParser[musicxml.Harmonu45mute] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("harmon-mute")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[musicxml.Harmonu45mute] =
      phrase((scalaxb.ElemName(None, "harmon-closed")) ^^
      { case p1 =>
      musicxml.Harmonu45mute(scalaxb.fromXML[musicxml.Harmonu45closed](p1, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@default-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-x" -> _ },
        (node \ "@default-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-y" -> _ },
        (node \ "@relative-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-x" -> _ },
        (node \ "@relative-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-y" -> _ },
        (node \ "@font-family").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-family" -> _ },
        (node \ "@font-style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45style](x, scalaxb.ElemName(node) :: stack)) } map { "@font-style" -> _ },
        (node \ "@font-size").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-size" -> _ },
        (node \ "@font-weight").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45weight](x, scalaxb.ElemName(node) :: stack)) } map { "@font-weight" -> _ },
        (node \ "@color").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@color" -> _ },
        (node \ "@placement").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Aboveu45below](x, scalaxb.ElemName(node) :: stack)) } map { "@placement" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: musicxml.Harmonu45mute, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@default-x", _) => __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.bigDecimal.toPlainString, attr) }
        case ("@default-y", _) => __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.bigDecimal.toPlainString, attr) }
        case ("@relative-x", _) => __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.bigDecimal.toPlainString, attr) }
        case ("@relative-y", _) => __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.bigDecimal.toPlainString, attr) }
        case ("@font-family", _) => __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
        case ("@font-style", _) => __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
        case ("@font-size", _) => __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
        case ("@font-weight", _) => __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
        case ("@color", _) => __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
        case ("@placement", _) => __obj.placement foreach { x => attr = scala.xml.Attribute(null, "placement", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Harmonu45mute, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (scalaxb.toXML[musicxml.Harmonu45closed](__obj.harmonu45closed, None, Some("harmon-closed"), __scope, false))
  }

  trait DefaultMusicxml_HarmonicFormat extends scalaxb.ElemNameParser[musicxml.Harmonic] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("harmonic")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[musicxml.Harmonic] =
      phrase(opt(((scalaxb.ElemName(None, "natural")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Empty](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "artificial")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Empty](x, scalaxb.ElemName(node) :: stack))))) ~ 
      opt(((scalaxb.ElemName(None, "base-pitch")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Empty](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "touching-pitch")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Empty](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "sounding-pitch")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Empty](x, scalaxb.ElemName(node) :: stack))))) ^^
      { case p1 ~ p2 =>
      musicxml.Harmonic(p1,
        p2,
        scala.collection.immutable.ListMap(List(
        (node \ "@print-object").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Yesu45no](x, scalaxb.ElemName(node) :: stack)) } map { "@print-object" -> _ },
        (node \ "@default-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-x" -> _ },
        (node \ "@default-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-y" -> _ },
        (node \ "@relative-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-x" -> _ },
        (node \ "@relative-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-y" -> _ },
        (node \ "@font-family").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-family" -> _ },
        (node \ "@font-style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45style](x, scalaxb.ElemName(node) :: stack)) } map { "@font-style" -> _ },
        (node \ "@font-size").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-size" -> _ },
        (node \ "@font-weight").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45weight](x, scalaxb.ElemName(node) :: stack)) } map { "@font-weight" -> _ },
        (node \ "@color").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@color" -> _ },
        (node \ "@placement").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Aboveu45below](x, scalaxb.ElemName(node) :: stack)) } map { "@placement" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: musicxml.Harmonic, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@print-object", _) => __obj.printu45object foreach { x => attr = scala.xml.Attribute(null, "print-object", x.toString, attr) }
        case ("@default-x", _) => __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.bigDecimal.toPlainString, attr) }
        case ("@default-y", _) => __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.bigDecimal.toPlainString, attr) }
        case ("@relative-x", _) => __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.bigDecimal.toPlainString, attr) }
        case ("@relative-y", _) => __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.bigDecimal.toPlainString, attr) }
        case ("@font-family", _) => __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
        case ("@font-style", _) => __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
        case ("@font-size", _) => __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
        case ("@font-weight", _) => __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
        case ("@color", _) => __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
        case ("@placement", _) => __obj.placement foreach { x => attr = scala.xml.Attribute(null, "placement", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Harmonic, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.harmonicoption map { x => scalaxb.toXML[scalaxb.DataRecord[musicxml.HarmonicOption]](x, x.namespace, x.key, __scope, false) } getOrElse {Nil},
        __obj.harmonicoption2 map { x => scalaxb.toXML[scalaxb.DataRecord[musicxml.HarmonicOption2]](x, x.namespace, x.key, __scope, false) } getOrElse {Nil})

  }

  trait DefaultMusicxml_Heelu45toeFormat extends scalaxb.XMLFormat[musicxml.Heelu45toe] with scalaxb.CanWriteChildNodes[musicxml.Heelu45toe] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Heelu45toe] = seq match {
      case node: scala.xml.Node => Right(musicxml.Heelu45toe(scala.collection.immutable.ListMap(List(
        (node \ "@default-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-x" -> _ },
        (node \ "@default-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-y" -> _ },
        (node \ "@relative-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-x" -> _ },
        (node \ "@relative-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-y" -> _ },
        (node \ "@font-family").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-family" -> _ },
        (node \ "@font-style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45style](x, scalaxb.ElemName(node) :: stack)) } map { "@font-style" -> _ },
        (node \ "@font-size").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-size" -> _ },
        (node \ "@font-weight").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45weight](x, scalaxb.ElemName(node) :: stack)) } map { "@font-weight" -> _ },
        (node \ "@color").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@color" -> _ },
        (node \ "@placement").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Aboveu45below](x, scalaxb.ElemName(node) :: stack)) } map { "@placement" -> _ },
        (node \ "@substitution").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Yesu45no](x, scalaxb.ElemName(node) :: stack)) } map { "@substitution" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Heelu45toe, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@default-x", _) => __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.bigDecimal.toPlainString, attr) }
        case ("@default-y", _) => __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.bigDecimal.toPlainString, attr) }
        case ("@relative-x", _) => __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.bigDecimal.toPlainString, attr) }
        case ("@relative-y", _) => __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.bigDecimal.toPlainString, attr) }
        case ("@font-family", _) => __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
        case ("@font-style", _) => __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
        case ("@font-size", _) => __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
        case ("@font-weight", _) => __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
        case ("@color", _) => __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
        case ("@placement", _) => __obj.placement foreach { x => attr = scala.xml.Attribute(null, "placement", x.toString, attr) }
        case ("@substitution", _) => __obj.substitution foreach { x => attr = scala.xml.Attribute(null, "substitution", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Heelu45toe, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil

  }

  trait DefaultMusicxml_HoleFormat extends scalaxb.ElemNameParser[musicxml.Hole] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("hole")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[musicxml.Hole] =
      phrase(opt(scalaxb.ElemName(None, "hole-type")) ~ 
      (scalaxb.ElemName(None, "hole-closed")) ~ 
      opt(scalaxb.ElemName(None, "hole-shape")) ^^
      { case p1 ~ p2 ~ p3 =>
      musicxml.Hole(p1.headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[musicxml.Holeu45closed](p2, scalaxb.ElemName(node) :: stack),
        p3.headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@default-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-x" -> _ },
        (node \ "@default-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-y" -> _ },
        (node \ "@relative-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-x" -> _ },
        (node \ "@relative-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-y" -> _ },
        (node \ "@font-family").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-family" -> _ },
        (node \ "@font-style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45style](x, scalaxb.ElemName(node) :: stack)) } map { "@font-style" -> _ },
        (node \ "@font-size").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-size" -> _ },
        (node \ "@font-weight").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45weight](x, scalaxb.ElemName(node) :: stack)) } map { "@font-weight" -> _ },
        (node \ "@color").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@color" -> _ },
        (node \ "@placement").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Aboveu45below](x, scalaxb.ElemName(node) :: stack)) } map { "@placement" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: musicxml.Hole, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@default-x", _) => __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.bigDecimal.toPlainString, attr) }
        case ("@default-y", _) => __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.bigDecimal.toPlainString, attr) }
        case ("@relative-x", _) => __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.bigDecimal.toPlainString, attr) }
        case ("@relative-y", _) => __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.bigDecimal.toPlainString, attr) }
        case ("@font-family", _) => __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
        case ("@font-style", _) => __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
        case ("@font-size", _) => __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
        case ("@font-weight", _) => __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
        case ("@color", _) => __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
        case ("@placement", _) => __obj.placement foreach { x => attr = scala.xml.Attribute(null, "placement", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Hole, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.holeu45type map { scalaxb.toXML[String](_, None, Some("hole-type"), __scope, false) } getOrElse {Nil},
        scalaxb.toXML[musicxml.Holeu45closed](__obj.holeu45closed, None, Some("hole-closed"), __scope, false),
        __obj.holeu45shape map { scalaxb.toXML[String](_, None, Some("hole-shape"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultMusicxml_Holeu45closedFormat extends scalaxb.XMLFormat[musicxml.Holeu45closed] with scalaxb.CanWriteChildNodes[musicxml.Holeu45closed] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Holeu45closed] = seq match {
      case node: scala.xml.Node => Right(musicxml.Holeu45closed(scalaxb.fromXML[musicxml.Holeu45closedu45value](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@location").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Holeu45closedu45location](x, scalaxb.ElemName(node) :: stack)) } map { "@location" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Holeu45closed, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@location", _) => __obj.location foreach { x => attr = scala.xml.Attribute(null, "location", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Holeu45closed, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultMusicxml_InstrumentFormat extends scalaxb.XMLFormat[musicxml.Instrument] with scalaxb.CanWriteChildNodes[musicxml.Instrument] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Instrument] = seq match {
      case node: scala.xml.Node => Right(musicxml.Instrument(scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Instrument, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => attr = scala.xml.Attribute(null, "id", __obj.id.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Instrument, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil

  }

  trait DefaultMusicxml_LyricFormat extends scalaxb.ElemNameParser[musicxml.Lyric] with Musicxml_EditorialGroupFormat {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("lyric")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[musicxml.Lyric] =
      phrase((((opt(scalaxb.ElemName(None, "syllabic")) ~ 
      (scalaxb.ElemName(None, "text")) ~ 
      safeRep((opt(((scalaxb.ElemName(None, "elision")) ~ 
      opt(scalaxb.ElemName(None, "syllabic"))) ^^ 
        { case p1 ~ p2 => musicxml.LyricSequence3(scalaxb.fromXML[musicxml.Elision](p1, scalaxb.ElemName(node) :: stack),
        p2.headOption map { scalaxb.fromXML[musicxml.Syllabic](_, scalaxb.ElemName(node) :: stack) }) }) ~ 
      (scalaxb.ElemName(None, "text"))) ^^ 
        { case p1 ~ p2 => musicxml.LyricSequence2(p1,
        scalaxb.fromXML[musicxml.Textu45elementu45data](p2, scalaxb.ElemName(node) :: stack)) }) ~ 
      opt(scalaxb.ElemName(None, "extend"))) ^^ 
        { case p1 ~ p2 ~ p3 ~ p4 => scalaxb.DataRecord(musicxml.LyricSequence1(p1.headOption map { scalaxb.fromXML[musicxml.Syllabic](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[musicxml.Textu45elementu45data](p2, scalaxb.ElemName(node) :: stack),
        p3,
        p4.headOption map { scalaxb.fromXML[musicxml.Extend](_, scalaxb.ElemName(node) :: stack) })) }) ||| 
      ((scalaxb.ElemName(None, "extend")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Extend](x, scalaxb.ElemName(node) :: stack)))) ||| 
      ((scalaxb.ElemName(None, "laughing")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Empty](x, scalaxb.ElemName(node) :: stack)))) ||| 
      ((scalaxb.ElemName(None, "humming")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Empty](x, scalaxb.ElemName(node) :: stack))))) ~ 
      opt(scalaxb.ElemName(None, "end-line")) ~ 
      opt(scalaxb.ElemName(None, "end-paragraph")) ~ 
      (parseEditorialGroup(node, scalaxb.ElemName(node) :: stack)) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      musicxml.Lyric(p1,
        p2.headOption map { scalaxb.fromXML[musicxml.Empty](_, scalaxb.ElemName(node) :: stack) },
        p3.headOption map { scalaxb.fromXML[musicxml.Empty](_, scalaxb.ElemName(node) :: stack) },
        p4,
        scala.collection.immutable.ListMap(List(
        (node \ "@number").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@number" -> _ },
        (node \ "@name").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@name" -> _ },
        (node \ "@justify").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Leftu45centeru45right](x, scalaxb.ElemName(node) :: stack)) } map { "@justify" -> _ },
        (node \ "@default-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-x" -> _ },
        (node \ "@default-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-y" -> _ },
        (node \ "@relative-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-x" -> _ },
        (node \ "@relative-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-y" -> _ },
        (node \ "@placement").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Aboveu45below](x, scalaxb.ElemName(node) :: stack)) } map { "@placement" -> _ },
        (node \ "@color").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@color" -> _ },
        (node \ "@print-object").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Yesu45no](x, scalaxb.ElemName(node) :: stack)) } map { "@print-object" -> _ },
        (node \ "@time-only").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@time-only" -> _ },
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: musicxml.Lyric, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@number", _) => __obj.number foreach { x => attr = scala.xml.Attribute(null, "number", x.toString, attr) }
        case ("@name", _) => __obj.name foreach { x => attr = scala.xml.Attribute(null, "name", x.toString, attr) }
        case ("@justify", _) => __obj.justify foreach { x => attr = scala.xml.Attribute(null, "justify", x.toString, attr) }
        case ("@default-x", _) => __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.bigDecimal.toPlainString, attr) }
        case ("@default-y", _) => __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.bigDecimal.toPlainString, attr) }
        case ("@relative-x", _) => __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.bigDecimal.toPlainString, attr) }
        case ("@relative-y", _) => __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.bigDecimal.toPlainString, attr) }
        case ("@placement", _) => __obj.placement foreach { x => attr = scala.xml.Attribute(null, "placement", x.toString, attr) }
        case ("@color", _) => __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
        case ("@print-object", _) => __obj.printu45object foreach { x => attr = scala.xml.Attribute(null, "print-object", x.toString, attr) }
        case ("@time-only", _) => __obj.timeu45only foreach { x => attr = scala.xml.Attribute(null, "time-only", x.toString, attr) }
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Lyric, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat((Some(__obj.lyricoption) map {x => scalaxb.toXML[scalaxb.DataRecord[musicxml.LyricOption]](x, x.namespace, x.key, __scope, false)}).get,
        __obj.endu45line map { scalaxb.toXML[musicxml.Empty](_, None, Some("end-line"), __scope, false) } getOrElse {Nil},
        __obj.endu45paragraph map { scalaxb.toXML[musicxml.Empty](_, None, Some("end-paragraph"), __scope, false) } getOrElse {Nil},
        scalaxb.toXML[musicxml.EditorialSequence](__obj.editorialSequence4, None, Some("editorialSequence4"), __scope, false))

  }

  trait DefaultMusicxml_LyricSequence3Format extends scalaxb.XMLFormat[musicxml.LyricSequence3] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.LyricSequence3] = Left("don't call me.")
    
    def writes(__obj: musicxml.LyricSequence3, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(scalaxb.toXML[musicxml.Elision](__obj.elision, None, Some("elision"), __scope, false),
        __obj.syllabic map { scalaxb.toXML[musicxml.Syllabic](_, None, Some("syllabic"), __scope, false) } getOrElse {Nil})


  }

  trait DefaultMusicxml_LyricSequence2Format extends scalaxb.XMLFormat[musicxml.LyricSequence2] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.LyricSequence2] = Left("don't call me.")
    
    def writes(__obj: musicxml.LyricSequence2, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(__obj.lyricsequence3 map { scalaxb.toXML[musicxml.LyricSequence3](_, None, Some("lyricsequence3"), __scope, false) } getOrElse {Nil},
        scalaxb.toXML[musicxml.Textu45elementu45data](__obj.text, None, Some("text"), __scope, false))


  }

  trait DefaultMusicxml_LyricSequence1Format extends scalaxb.XMLFormat[musicxml.LyricSequence1] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.LyricSequence1] = Left("don't call me.")
    
    def writes(__obj: musicxml.LyricSequence1, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(__obj.syllabic map { scalaxb.toXML[musicxml.Syllabic](_, None, Some("syllabic"), __scope, false) } getOrElse {Nil},
        scalaxb.toXML[musicxml.Textu45elementu45data](__obj.text, None, Some("text"), __scope, false),
        __obj.lyricsequence2 flatMap { scalaxb.toXML[musicxml.LyricSequence2](_, None, Some("lyricsequence2"), __scope, false) },
        __obj.extend map { scalaxb.toXML[musicxml.Extend](_, None, Some("extend"), __scope, false) } getOrElse {Nil})


  }

  trait DefaultMusicxml_MordentFormat extends scalaxb.XMLFormat[musicxml.Mordent] with scalaxb.CanWriteChildNodes[musicxml.Mordent] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Mordent] = seq match {
      case node: scala.xml.Node => Right(musicxml.Mordent(scala.collection.immutable.ListMap(List(
        (node \ "@default-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-x" -> _ },
        (node \ "@default-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-y" -> _ },
        (node \ "@relative-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-x" -> _ },
        (node \ "@relative-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-y" -> _ },
        (node \ "@font-family").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-family" -> _ },
        (node \ "@font-style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45style](x, scalaxb.ElemName(node) :: stack)) } map { "@font-style" -> _ },
        (node \ "@font-size").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-size" -> _ },
        (node \ "@font-weight").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45weight](x, scalaxb.ElemName(node) :: stack)) } map { "@font-weight" -> _ },
        (node \ "@color").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@color" -> _ },
        (node \ "@placement").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Aboveu45below](x, scalaxb.ElemName(node) :: stack)) } map { "@placement" -> _ },
        (node \ "@start-note").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Startu45note](x, scalaxb.ElemName(node) :: stack)) } map { "@start-note" -> _ },
        (node \ "@trill-step").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Trillu45step](x, scalaxb.ElemName(node) :: stack)) } map { "@trill-step" -> _ },
        (node \ "@two-note-turn").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Twou45noteu45turn](x, scalaxb.ElemName(node) :: stack)) } map { "@two-note-turn" -> _ },
        (node \ "@accelerate").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Yesu45no](x, scalaxb.ElemName(node) :: stack)) } map { "@accelerate" -> _ },
        (node \ "@beats").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@beats" -> _ },
        (node \ "@second-beat").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@second-beat" -> _ },
        (node \ "@last-beat").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@last-beat" -> _ },
        (node \ "@long").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Yesu45no](x, scalaxb.ElemName(node) :: stack)) } map { "@long" -> _ },
        (node \ "@approach").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Aboveu45below](x, scalaxb.ElemName(node) :: stack)) } map { "@approach" -> _ },
        (node \ "@departure").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Aboveu45below](x, scalaxb.ElemName(node) :: stack)) } map { "@departure" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Mordent, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@default-x", _) => __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.bigDecimal.toPlainString, attr) }
        case ("@default-y", _) => __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.bigDecimal.toPlainString, attr) }
        case ("@relative-x", _) => __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.bigDecimal.toPlainString, attr) }
        case ("@relative-y", _) => __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.bigDecimal.toPlainString, attr) }
        case ("@font-family", _) => __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
        case ("@font-style", _) => __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
        case ("@font-size", _) => __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
        case ("@font-weight", _) => __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
        case ("@color", _) => __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
        case ("@placement", _) => __obj.placement foreach { x => attr = scala.xml.Attribute(null, "placement", x.toString, attr) }
        case ("@start-note", _) => __obj.startu45note foreach { x => attr = scala.xml.Attribute(null, "start-note", x.toString, attr) }
        case ("@trill-step", _) => __obj.trillu45step foreach { x => attr = scala.xml.Attribute(null, "trill-step", x.toString, attr) }
        case ("@two-note-turn", _) => __obj.twou45noteu45turn foreach { x => attr = scala.xml.Attribute(null, "two-note-turn", x.toString, attr) }
        case ("@accelerate", _) => __obj.accelerate foreach { x => attr = scala.xml.Attribute(null, "accelerate", x.toString, attr) }
        case ("@beats", _) => __obj.beats foreach { x => attr = scala.xml.Attribute(null, "beats", x.bigDecimal.toPlainString, attr) }
        case ("@second-beat", _) => __obj.secondu45beat foreach { x => attr = scala.xml.Attribute(null, "second-beat", x.bigDecimal.toPlainString, attr) }
        case ("@last-beat", _) => __obj.lastu45beat foreach { x => attr = scala.xml.Attribute(null, "last-beat", x.bigDecimal.toPlainString, attr) }
        case ("@long", _) => __obj.long foreach { x => attr = scala.xml.Attribute(null, "long", x.toString, attr) }
        case ("@approach", _) => __obj.approach foreach { x => attr = scala.xml.Attribute(null, "approach", x.toString, attr) }
        case ("@departure", _) => __obj.departure foreach { x => attr = scala.xml.Attribute(null, "departure", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Mordent, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil

  }

  trait DefaultMusicxml_Nonu45arpeggiateFormat extends scalaxb.XMLFormat[musicxml.Nonu45arpeggiate] with scalaxb.CanWriteChildNodes[musicxml.Nonu45arpeggiate] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Nonu45arpeggiate] = seq match {
      case node: scala.xml.Node => Right(musicxml.Nonu45arpeggiate(scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Topu45bottom](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ },
        (node \ "@number").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigInt](x, scalaxb.ElemName(node) :: stack)) } map { "@number" -> _ },
        (node \ "@default-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-x" -> _ },
        (node \ "@default-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-y" -> _ },
        (node \ "@relative-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-x" -> _ },
        (node \ "@relative-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-y" -> _ },
        (node \ "@placement").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Aboveu45below](x, scalaxb.ElemName(node) :: stack)) } map { "@placement" -> _ },
        (node \ "@color").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@color" -> _ },
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Nonu45arpeggiate, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case ("@number", _) => __obj.number foreach { x => attr = scala.xml.Attribute(null, "number", x.toString, attr) }
        case ("@default-x", _) => __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.bigDecimal.toPlainString, attr) }
        case ("@default-y", _) => __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.bigDecimal.toPlainString, attr) }
        case ("@relative-x", _) => __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.bigDecimal.toPlainString, attr) }
        case ("@relative-y", _) => __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.bigDecimal.toPlainString, attr) }
        case ("@placement", _) => __obj.placement foreach { x => attr = scala.xml.Attribute(null, "placement", x.toString, attr) }
        case ("@color", _) => __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Nonu45arpeggiate, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil

  }

  trait DefaultMusicxml_NotationsFormat extends scalaxb.ElemNameParser[musicxml.Notations] with Musicxml_EditorialGroupFormat {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("notations")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[musicxml.Notations] =
      phrase((parseEditorialGroup(node, scalaxb.ElemName(node) :: stack)) ~ 
      safeRep(((scalaxb.ElemName(None, "tied")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Tied](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "slur")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Slur](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "tuplet")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Tuplet](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "glissando")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Glissando](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "slide")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Slide](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "ornaments")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Ornaments](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "technical")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Technical](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "articulations")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Articulations](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "dynamics")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Dynamics](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "fermata")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Fermata](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "arpeggiate")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Arpeggiate](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "non-arpeggiate")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Nonu45arpeggiate](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "accidental-mark")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Accidentalu45mark](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "other-notation")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Otheru45notation](x, scalaxb.ElemName(node) :: stack))))) ^^
      { case p1 ~ p2 =>
      musicxml.Notations(p1,
        p2,
        scala.collection.immutable.ListMap(List(
        (node \ "@print-object").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Yesu45no](x, scalaxb.ElemName(node) :: stack)) } map { "@print-object" -> _ },
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: musicxml.Notations, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@print-object", _) => __obj.printu45object foreach { x => attr = scala.xml.Attribute(null, "print-object", x.toString, attr) }
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Notations, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(scalaxb.toXML[musicxml.EditorialSequence](__obj.editorialSequence1, None, Some("editorialSequence1"), __scope, false),
        __obj.notationsoption flatMap { x => scalaxb.toXML[scalaxb.DataRecord[musicxml.NotationsOption]](x, x.namespace, x.key, __scope, false) })

  }

  trait DefaultMusicxml_NoteFormat extends scalaxb.ElemNameParser[musicxml.Note] with Musicxml_Fullu45noteGroupFormat with Musicxml_DurationGroupFormat with Musicxml_Editorialu45voiceGroupFormat with Musicxml_StaffGroupFormat {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("note")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[musicxml.Note] =
      phrase(((((scalaxb.ElemName(None, "grace")) ~ 
      ((((parseFullu45noteGroup(node, scalaxb.ElemName(node) :: stack)) ~ 
      safeRep(scalaxb.ElemName(None, "tie"))) ^^ 
        { case p1 ~ p2 => scalaxb.DataRecord(musicxml.NoteSequence2(p1,
        p2 map { scalaxb.fromXML[musicxml.Tie](_, scalaxb.ElemName(node) :: stack) })) }) ||| 
      (((scalaxb.ElemName(None, "cue")) ~ 
      (parseFullu45noteGroup(node, scalaxb.ElemName(node) :: stack))) ^^ 
        { case p1 ~ p2 => scalaxb.DataRecord(musicxml.NoteSequence3(scalaxb.fromXML[musicxml.Empty](p1, scalaxb.ElemName(node) :: stack),
        p2)) }))) ^^ 
        { case p1 ~ p2 => scalaxb.DataRecord(musicxml.NoteSequence1(scalaxb.fromXML[musicxml.Grace](p1, scalaxb.ElemName(node) :: stack),
        p2)) }) ||| 
      (((scalaxb.ElemName(None, "cue")) ~ 
      (parseFullu45noteGroup(node, scalaxb.ElemName(node) :: stack)) ~ 
      (parseDurationGroup(node, scalaxb.ElemName(node) :: stack))) ^^ 
        { case p1 ~ p2 ~ p3 => scalaxb.DataRecord(musicxml.NoteSequence4(scalaxb.fromXML[musicxml.Empty](p1, scalaxb.ElemName(node) :: stack),
        p2,
        p3)) }) ||| 
      (((parseFullu45noteGroup(node, scalaxb.ElemName(node) :: stack)) ~ 
      (parseDurationGroup(node, scalaxb.ElemName(node) :: stack)) ~ 
      safeRep(scalaxb.ElemName(None, "tie"))) ^^ 
        { case p1 ~ p2 ~ p3 => scalaxb.DataRecord(musicxml.NoteSequence5(p1,
        p2,
        p3 map { scalaxb.fromXML[musicxml.Tie](_, scalaxb.ElemName(node) :: stack) })) })) ~ 
      opt(scalaxb.ElemName(None, "instrument")) ~ 
      (parseEditorialu45voiceGroup(node, scalaxb.ElemName(node) :: stack)) ~ 
      opt(scalaxb.ElemName(None, "type")) ~ 
      safeRep(scalaxb.ElemName(None, "dot")) ~ 
      opt(scalaxb.ElemName(None, "accidental")) ~ 
      opt(scalaxb.ElemName(None, "time-modification")) ~ 
      opt(scalaxb.ElemName(None, "stem")) ~ 
      opt(scalaxb.ElemName(None, "notehead")) ~ 
      opt(scalaxb.ElemName(None, "notehead-text")) ~ 
      opt(parseStaffGroup(node, scalaxb.ElemName(node) :: stack)) ~ 
      safeRep(scalaxb.ElemName(None, "beam")) ~ 
      safeRep(scalaxb.ElemName(None, "notations")) ~ 
      safeRep(scalaxb.ElemName(None, "lyric")) ~ 
      opt(scalaxb.ElemName(None, "play")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 ~ p9 ~ p10 ~ p11 ~ p12 ~ p13 ~ p14 ~ p15 =>
      musicxml.Note(p1,
        p2.headOption map { scalaxb.fromXML[musicxml.Instrument](_, scalaxb.ElemName(node) :: stack) },
        p3,
        p4.headOption map { scalaxb.fromXML[musicxml.Noteu45type](_, scalaxb.ElemName(node) :: stack) },
        p5 map { scalaxb.fromXML[musicxml.Emptyu45placementable](_, scalaxb.ElemName(node) :: stack) },
        p6.headOption map { scalaxb.fromXML[musicxml.Accidental](_, scalaxb.ElemName(node) :: stack) },
        p7.headOption map { scalaxb.fromXML[musicxml.Timeu45modificationable](_, scalaxb.ElemName(node) :: stack) },
        p8.headOption map { scalaxb.fromXML[musicxml.Stem](_, scalaxb.ElemName(node) :: stack) },
        p9.headOption map { scalaxb.fromXML[musicxml.Notehead](_, scalaxb.ElemName(node) :: stack) },
        p10.headOption map { scalaxb.fromXML[musicxml.Noteheadu45text](_, scalaxb.ElemName(node) :: stack) },
        p11,
        p12 map { scalaxb.fromXML[musicxml.Beam](_, scalaxb.ElemName(node) :: stack) },
        p13 map { scalaxb.fromXML[musicxml.Notations](_, scalaxb.ElemName(node) :: stack) },
        p14 map { scalaxb.fromXML[musicxml.Lyric](_, scalaxb.ElemName(node) :: stack) },
        p15.headOption map { scalaxb.fromXML[musicxml.Play](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@default-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-x" -> _ },
        (node \ "@default-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-y" -> _ },
        (node \ "@relative-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-x" -> _ },
        (node \ "@relative-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-y" -> _ },
        (node \ "@font-family").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-family" -> _ },
        (node \ "@font-style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45style](x, scalaxb.ElemName(node) :: stack)) } map { "@font-style" -> _ },
        (node \ "@font-size").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-size" -> _ },
        (node \ "@font-weight").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45weight](x, scalaxb.ElemName(node) :: stack)) } map { "@font-weight" -> _ },
        (node \ "@color").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@color" -> _ },
        (node \ "@print-object").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Yesu45no](x, scalaxb.ElemName(node) :: stack)) } map { "@print-object" -> _ },
        (node \ "@print-dot").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Yesu45no](x, scalaxb.ElemName(node) :: stack)) } map { "@print-dot" -> _ },
        (node \ "@print-spacing").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Yesu45no](x, scalaxb.ElemName(node) :: stack)) } map { "@print-spacing" -> _ },
        (node \ "@print-lyric").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Yesu45no](x, scalaxb.ElemName(node) :: stack)) } map { "@print-lyric" -> _ },
        (node \ "@print-leger").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Yesu45no](x, scalaxb.ElemName(node) :: stack)) } map { "@print-leger" -> _ },
        (node \ "@dynamics").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@dynamics" -> _ },
        (node \ "@end-dynamics").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@end-dynamics" -> _ },
        (node \ "@attack").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@attack" -> _ },
        (node \ "@release").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@release" -> _ },
        (node \ "@time-only").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@time-only" -> _ },
        (node \ "@pizzicato").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Yesu45no](x, scalaxb.ElemName(node) :: stack)) } map { "@pizzicato" -> _ },
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: musicxml.Note, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@default-x", _) => __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.bigDecimal.toPlainString, attr) }
        case ("@default-y", _) => __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.bigDecimal.toPlainString, attr) }
        case ("@relative-x", _) => __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.bigDecimal.toPlainString, attr) }
        case ("@relative-y", _) => __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.bigDecimal.toPlainString, attr) }
        case ("@font-family", _) => __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
        case ("@font-style", _) => __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
        case ("@font-size", _) => __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
        case ("@font-weight", _) => __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
        case ("@color", _) => __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
        case ("@print-object", _) => __obj.printu45object foreach { x => attr = scala.xml.Attribute(null, "print-object", x.toString, attr) }
        case ("@print-dot", _) => __obj.printu45dot foreach { x => attr = scala.xml.Attribute(null, "print-dot", x.toString, attr) }
        case ("@print-spacing", _) => __obj.printu45spacing foreach { x => attr = scala.xml.Attribute(null, "print-spacing", x.toString, attr) }
        case ("@print-lyric", _) => __obj.printu45lyric foreach { x => attr = scala.xml.Attribute(null, "print-lyric", x.toString, attr) }
        case ("@print-leger", _) => __obj.printu45leger foreach { x => attr = scala.xml.Attribute(null, "print-leger", x.toString, attr) }
        case ("@dynamics", _) => __obj.dynamics foreach { x => attr = scala.xml.Attribute(null, "dynamics", x.bigDecimal.toPlainString, attr) }
        case ("@end-dynamics", _) => __obj.endu45dynamics foreach { x => attr = scala.xml.Attribute(null, "end-dynamics", x.bigDecimal.toPlainString, attr) }
        case ("@attack", _) => __obj.attack foreach { x => attr = scala.xml.Attribute(null, "attack", x.bigDecimal.toPlainString, attr) }
        case ("@release", _) => __obj.release foreach { x => attr = scala.xml.Attribute(null, "release", x.bigDecimal.toPlainString, attr) }
        case ("@time-only", _) => __obj.timeu45only foreach { x => attr = scala.xml.Attribute(null, "time-only", x.toString, attr) }
        case ("@pizzicato", _) => __obj.pizzicato foreach { x => attr = scala.xml.Attribute(null, "pizzicato", x.toString, attr) }
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Note, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat((Some(__obj.noteoption) map {x => scalaxb.toXML[scalaxb.DataRecord[musicxml.NoteOption]](x, x.namespace, x.key, __scope, false)}).get,
        __obj.instrument map { scalaxb.toXML[musicxml.Instrument](_, None, Some("instrument"), __scope, false) } getOrElse {Nil},
        scalaxb.toXML[musicxml.Editorialu45voiceSequence](__obj.editorialu45voiceSequence3, None, Some("editorialu45voiceSequence3"), __scope, false),
        __obj.typeValue map { scalaxb.toXML[musicxml.Noteu45type](_, None, Some("type"), __scope, false) } getOrElse {Nil},
        __obj.dot flatMap { scalaxb.toXML[musicxml.Emptyu45placementable](_, None, Some("dot"), __scope, false) },
        __obj.accidental map { scalaxb.toXML[musicxml.Accidental](_, None, Some("accidental"), __scope, false) } getOrElse {Nil},
        __obj.timeu45modification map { scalaxb.toXML[musicxml.Timeu45modificationable](_, None, Some("time-modification"), __scope, false) } getOrElse {Nil},
        __obj.stem map { scalaxb.toXML[musicxml.Stem](_, None, Some("stem"), __scope, false) } getOrElse {Nil},
        __obj.notehead map { scalaxb.toXML[musicxml.Notehead](_, None, Some("notehead"), __scope, false) } getOrElse {Nil},
        __obj.noteheadu45text map { scalaxb.toXML[musicxml.Noteheadu45text](_, None, Some("notehead-text"), __scope, false) } getOrElse {Nil},
        __obj.staffSequence11 map { scalaxb.toXML[musicxml.StaffSequence](_, None, Some("staffSequence11"), __scope, false) } getOrElse {Nil},
        __obj.beam flatMap { scalaxb.toXML[musicxml.Beam](_, None, Some("beam"), __scope, false) },
        __obj.notations flatMap { scalaxb.toXML[musicxml.Notations](_, None, Some("notations"), __scope, false) },
        __obj.lyric flatMap { scalaxb.toXML[musicxml.Lyric](_, None, Some("lyric"), __scope, false) },
        __obj.play map { scalaxb.toXML[musicxml.Play](_, None, Some("play"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultMusicxml_NoteSequence5Format extends scalaxb.XMLFormat[musicxml.NoteSequence5] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.NoteSequence5] = Left("don't call me.")
    
    def writes(__obj: musicxml.NoteSequence5, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(scalaxb.toXML[musicxml.Fullu45noteSequence](__obj.fullu45noteSequence1, None, Some("fullu45noteSequence1"), __scope, false),
        scalaxb.toXML[musicxml.DurationSequence](__obj.durationSequence2, None, Some("durationSequence2"), __scope, false),
        __obj.tie flatMap { scalaxb.toXML[musicxml.Tie](_, None, Some("tie"), __scope, false) })


  }

  trait DefaultMusicxml_NoteSequence1Format extends scalaxb.XMLFormat[musicxml.NoteSequence1] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.NoteSequence1] = Left("don't call me.")
    
    def writes(__obj: musicxml.NoteSequence1, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(scalaxb.toXML[musicxml.Grace](__obj.grace, None, Some("grace"), __scope, false),
        (Some(__obj.noteoption2) map {x => scalaxb.toXML[scalaxb.DataRecord[musicxml.NoteOption2]](x, x.namespace, x.key, __scope, false)}).get)


  }

  trait DefaultMusicxml_NoteSequence4Format extends scalaxb.XMLFormat[musicxml.NoteSequence4] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.NoteSequence4] = Left("don't call me.")
    
    def writes(__obj: musicxml.NoteSequence4, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(scalaxb.toXML[musicxml.Empty](__obj.cue, None, Some("cue"), __scope, false),
        scalaxb.toXML[musicxml.Fullu45noteSequence](__obj.fullu45noteSequence2, None, Some("fullu45noteSequence2"), __scope, false),
        scalaxb.toXML[musicxml.DurationSequence](__obj.durationSequence3, None, Some("durationSequence3"), __scope, false))


  }

  trait DefaultMusicxml_NoteSequence2Format extends scalaxb.XMLFormat[musicxml.NoteSequence2] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.NoteSequence2] = Left("don't call me.")
    
    def writes(__obj: musicxml.NoteSequence2, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(scalaxb.toXML[musicxml.Fullu45noteSequence](__obj.fullu45noteSequence1, None, Some("fullu45noteSequence1"), __scope, false),
        __obj.tie flatMap { scalaxb.toXML[musicxml.Tie](_, None, Some("tie"), __scope, false) })


  }

  trait DefaultMusicxml_NoteSequence3Format extends scalaxb.XMLFormat[musicxml.NoteSequence3] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.NoteSequence3] = Left("don't call me.")
    
    def writes(__obj: musicxml.NoteSequence3, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(scalaxb.toXML[musicxml.Empty](__obj.cue, None, Some("cue"), __scope, false),
        scalaxb.toXML[musicxml.Fullu45noteSequence](__obj.fullu45noteSequence2, None, Some("fullu45noteSequence2"), __scope, false))


  }

  trait DefaultMusicxml_Noteu45typeFormat extends scalaxb.XMLFormat[musicxml.Noteu45type] with scalaxb.CanWriteChildNodes[musicxml.Noteu45type] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Noteu45type] = seq match {
      case node: scala.xml.Node => Right(musicxml.Noteu45type(scalaxb.fromXML[musicxml.Noteu45typeu45value](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@size").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Symbolu45size](x, scalaxb.ElemName(node) :: stack)) } map { "@size" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Noteu45type, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@size", _) => __obj.size foreach { x => attr = scala.xml.Attribute(null, "size", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Noteu45type, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultMusicxml_NoteheadFormat extends scalaxb.XMLFormat[musicxml.Notehead] with scalaxb.CanWriteChildNodes[musicxml.Notehead] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Notehead] = seq match {
      case node: scala.xml.Node => Right(musicxml.Notehead(scalaxb.fromXML[musicxml.Noteheadu45value](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@filled").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Yesu45no](x, scalaxb.ElemName(node) :: stack)) } map { "@filled" -> _ },
        (node \ "@parentheses").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Yesu45no](x, scalaxb.ElemName(node) :: stack)) } map { "@parentheses" -> _ },
        (node \ "@font-family").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-family" -> _ },
        (node \ "@font-style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45style](x, scalaxb.ElemName(node) :: stack)) } map { "@font-style" -> _ },
        (node \ "@font-size").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-size" -> _ },
        (node \ "@font-weight").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45weight](x, scalaxb.ElemName(node) :: stack)) } map { "@font-weight" -> _ },
        (node \ "@color").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@color" -> _ },
        (node \ "@smufl").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@smufl" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Notehead, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@filled", _) => __obj.filled foreach { x => attr = scala.xml.Attribute(null, "filled", x.toString, attr) }
        case ("@parentheses", _) => __obj.parentheses foreach { x => attr = scala.xml.Attribute(null, "parentheses", x.toString, attr) }
        case ("@font-family", _) => __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
        case ("@font-style", _) => __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
        case ("@font-size", _) => __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
        case ("@font-weight", _) => __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
        case ("@color", _) => __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
        case ("@smufl", _) => __obj.smufl foreach { x => attr = scala.xml.Attribute(null, "smufl", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Notehead, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultMusicxml_Noteheadu45textFormat extends scalaxb.ElemNameParser[musicxml.Noteheadu45text] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("notehead-text")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[musicxml.Noteheadu45text] =
      phrase(safeRep(((scalaxb.ElemName(None, "display-text")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Formattedu45text](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "accidental-text")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Accidentalu45text](x, scalaxb.ElemName(node) :: stack))))) ^^
      { case p1 =>
      musicxml.Noteheadu45text(p1) })
    
    def writesChildNodes(__obj: musicxml.Noteheadu45text, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.noteheadu45textoption flatMap { x => scalaxb.toXML[scalaxb.DataRecord[musicxml.Noteheadu45textOption]](x, x.namespace, x.key, __scope, false) })
  }

  trait DefaultMusicxml_OrnamentsFormat extends scalaxb.ElemNameParser[musicxml.Ornaments] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("ornaments")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[musicxml.Ornaments] =
      phrase(safeRep(((((scalaxb.ElemName(None, "trill-mark")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Emptyu45trillu45soundable](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "turn")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Horizontalu45turn](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "delayed-turn")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Horizontalu45turn](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "inverted-turn")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Horizontalu45turn](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "delayed-inverted-turn")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Horizontalu45turn](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "vertical-turn")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Emptyu45trillu45soundable](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "inverted-vertical-turn")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Emptyu45trillu45soundable](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "shake")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Emptyu45trillu45soundable](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "wavy-line")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Wavyu45line](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "mordent")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Mordent](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "inverted-mordent")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Mordent](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "schleifer")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Emptyu45placementable](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "tremolo")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Tremolo](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "haydn")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Emptyu45trillu45soundable](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "other-ornament")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Otheru45placementu45text](x, scalaxb.ElemName(node) :: stack))))) ~ 
      safeRep(scalaxb.ElemName(None, "accidental-mark"))) ^^ 
        { case p1 ~ p2 => musicxml.OrnamentsSequence1(p1,
        p2 map { scalaxb.fromXML[musicxml.Accidentalu45mark](_, scalaxb.ElemName(node) :: stack) }) }) ^^
      { case p1 =>
      musicxml.Ornaments(p1,
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: musicxml.Ornaments, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Ornaments, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.ornamentssequence1 flatMap { scalaxb.toXML[musicxml.OrnamentsSequence1](_, None, Some("ornamentssequence1"), __scope, false) })
  }

  trait DefaultMusicxml_OrnamentsSequence1Format extends scalaxb.XMLFormat[musicxml.OrnamentsSequence1] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.OrnamentsSequence1] = Left("don't call me.")
    
    def writes(__obj: musicxml.OrnamentsSequence1, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat((Some(__obj.ornamentsoption) map {x => scalaxb.toXML[scalaxb.DataRecord[musicxml.OrnamentsOption]](x, x.namespace, x.key, __scope, false)}).get,
        __obj.accidentalu45mark flatMap { scalaxb.toXML[musicxml.Accidentalu45mark](_, None, Some("accidental-mark"), __scope, false) })


  }

  trait DefaultMusicxml_Otheru45notationFormat extends scalaxb.XMLFormat[musicxml.Otheru45notation] with scalaxb.CanWriteChildNodes[musicxml.Otheru45notation] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Otheru45notation] = seq match {
      case node: scala.xml.Node => Right(musicxml.Otheru45notation(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Startu45stopu45single](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ },
        (node \ "@number").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigInt](x, scalaxb.ElemName(node) :: stack)) } orElse Some(scalaxb.DataRecord(None, None, scalaxb.fromXML[BigInt](scala.xml.Text("1"), scalaxb.ElemName(node) :: stack))) map { "@number" -> _ },
        (node \ "@print-object").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Yesu45no](x, scalaxb.ElemName(node) :: stack)) } map { "@print-object" -> _ },
        (node \ "@default-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-x" -> _ },
        (node \ "@default-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-y" -> _ },
        (node \ "@relative-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-x" -> _ },
        (node \ "@relative-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-y" -> _ },
        (node \ "@font-family").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-family" -> _ },
        (node \ "@font-style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45style](x, scalaxb.ElemName(node) :: stack)) } map { "@font-style" -> _ },
        (node \ "@font-size").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-size" -> _ },
        (node \ "@font-weight").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45weight](x, scalaxb.ElemName(node) :: stack)) } map { "@font-weight" -> _ },
        (node \ "@color").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@color" -> _ },
        (node \ "@placement").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Aboveu45below](x, scalaxb.ElemName(node) :: stack)) } map { "@placement" -> _ },
        (node \ "@smufl").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@smufl" -> _ },
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Otheru45notation, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case ("@number", _) => if (__obj.number.toString != "1") attr = scala.xml.Attribute(null, "number", __obj.number.toString, attr)
        case ("@print-object", _) => __obj.printu45object foreach { x => attr = scala.xml.Attribute(null, "print-object", x.toString, attr) }
        case ("@default-x", _) => __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.bigDecimal.toPlainString, attr) }
        case ("@default-y", _) => __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.bigDecimal.toPlainString, attr) }
        case ("@relative-x", _) => __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.bigDecimal.toPlainString, attr) }
        case ("@relative-y", _) => __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.bigDecimal.toPlainString, attr) }
        case ("@font-family", _) => __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
        case ("@font-style", _) => __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
        case ("@font-size", _) => __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
        case ("@font-weight", _) => __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
        case ("@color", _) => __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
        case ("@placement", _) => __obj.placement foreach { x => attr = scala.xml.Attribute(null, "placement", x.toString, attr) }
        case ("@smufl", _) => __obj.smufl foreach { x => attr = scala.xml.Attribute(null, "smufl", x.toString, attr) }
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Otheru45notation, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultMusicxml_Otheru45placementu45textFormat extends scalaxb.XMLFormat[musicxml.Otheru45placementu45text] with scalaxb.CanWriteChildNodes[musicxml.Otheru45placementu45text] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Otheru45placementu45text] = seq match {
      case node: scala.xml.Node => Right(musicxml.Otheru45placementu45text(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@default-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-x" -> _ },
        (node \ "@default-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-y" -> _ },
        (node \ "@relative-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-x" -> _ },
        (node \ "@relative-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-y" -> _ },
        (node \ "@font-family").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-family" -> _ },
        (node \ "@font-style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45style](x, scalaxb.ElemName(node) :: stack)) } map { "@font-style" -> _ },
        (node \ "@font-size").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-size" -> _ },
        (node \ "@font-weight").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45weight](x, scalaxb.ElemName(node) :: stack)) } map { "@font-weight" -> _ },
        (node \ "@color").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@color" -> _ },
        (node \ "@placement").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Aboveu45below](x, scalaxb.ElemName(node) :: stack)) } map { "@placement" -> _ },
        (node \ "@smufl").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@smufl" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Otheru45placementu45text, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@default-x", _) => __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.bigDecimal.toPlainString, attr) }
        case ("@default-y", _) => __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.bigDecimal.toPlainString, attr) }
        case ("@relative-x", _) => __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.bigDecimal.toPlainString, attr) }
        case ("@relative-y", _) => __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.bigDecimal.toPlainString, attr) }
        case ("@font-family", _) => __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
        case ("@font-style", _) => __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
        case ("@font-size", _) => __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
        case ("@font-weight", _) => __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
        case ("@color", _) => __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
        case ("@placement", _) => __obj.placement foreach { x => attr = scala.xml.Attribute(null, "placement", x.toString, attr) }
        case ("@smufl", _) => __obj.smufl foreach { x => attr = scala.xml.Attribute(null, "smufl", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Otheru45placementu45text, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultMusicxml_Otheru45textFormat extends scalaxb.XMLFormat[musicxml.Otheru45text] with scalaxb.CanWriteChildNodes[musicxml.Otheru45text] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Otheru45text] = seq match {
      case node: scala.xml.Node => Right(musicxml.Otheru45text(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@smufl").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@smufl" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Otheru45text, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@smufl", _) => __obj.smufl foreach { x => attr = scala.xml.Attribute(null, "smufl", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Otheru45text, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultMusicxml_PitchFormat extends scalaxb.ElemNameParser[musicxml.Pitch] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("pitch")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[musicxml.Pitch] =
      phrase((scalaxb.ElemName(None, "step")) ~ 
      opt(scalaxb.ElemName(None, "alter")) ~ 
      (scalaxb.ElemName(None, "octave")) ^^
      { case p1 ~ p2 ~ p3 =>
      musicxml.Pitch(scalaxb.fromXML[musicxml.Step](p1, scalaxb.ElemName(node) :: stack),
        p2.headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[BigInt](p3, scalaxb.ElemName(node) :: stack)) })
    
    def writesChildNodes(__obj: musicxml.Pitch, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(scalaxb.toXML[musicxml.Step](__obj.step, None, Some("step"), __scope, false),
        __obj.alter map { scalaxb.toXML[BigDecimal](_, None, Some("alter"), __scope, false) } getOrElse {Nil},
        scalaxb.toXML[BigInt](__obj.octave, None, Some("octave"), __scope, false))

  }

  trait DefaultMusicxml_Placementu45textFormat extends scalaxb.XMLFormat[musicxml.Placementu45text] with scalaxb.CanWriteChildNodes[musicxml.Placementu45text] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Placementu45text] = seq match {
      case node: scala.xml.Node => Right(musicxml.Placementu45text(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@default-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-x" -> _ },
        (node \ "@default-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-y" -> _ },
        (node \ "@relative-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-x" -> _ },
        (node \ "@relative-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-y" -> _ },
        (node \ "@font-family").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-family" -> _ },
        (node \ "@font-style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45style](x, scalaxb.ElemName(node) :: stack)) } map { "@font-style" -> _ },
        (node \ "@font-size").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-size" -> _ },
        (node \ "@font-weight").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45weight](x, scalaxb.ElemName(node) :: stack)) } map { "@font-weight" -> _ },
        (node \ "@color").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@color" -> _ },
        (node \ "@placement").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Aboveu45below](x, scalaxb.ElemName(node) :: stack)) } map { "@placement" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Placementu45text, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@default-x", _) => __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.bigDecimal.toPlainString, attr) }
        case ("@default-y", _) => __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.bigDecimal.toPlainString, attr) }
        case ("@relative-x", _) => __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.bigDecimal.toPlainString, attr) }
        case ("@relative-y", _) => __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.bigDecimal.toPlainString, attr) }
        case ("@font-family", _) => __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
        case ("@font-style", _) => __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
        case ("@font-size", _) => __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
        case ("@font-weight", _) => __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
        case ("@color", _) => __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
        case ("@placement", _) => __obj.placement foreach { x => attr = scala.xml.Attribute(null, "placement", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Placementu45text, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultMusicxml_RestFormat extends scalaxb.ElemNameParser[musicxml.Rest] with Musicxml_Displayu45stepu45octaveGroupFormat {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("rest")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[musicxml.Rest] =
      phrase(opt(parseDisplayu45stepu45octaveGroup(node, scalaxb.ElemName(node) :: stack)) ^^
      { case p1 =>
      musicxml.Rest(p1,
        scala.collection.immutable.ListMap(List(
        (node \ "@measure").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Yesu45no](x, scalaxb.ElemName(node) :: stack)) } map { "@measure" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: musicxml.Rest, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@measure", _) => __obj.measure foreach { x => attr = scala.xml.Attribute(null, "measure", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Rest, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.displayu45stepu45octaveSequence1 map { scalaxb.toXML[musicxml.Displayu45stepu45octaveSequence](_, None, Some("displayu45stepu45octaveSequence1"), __scope, false) } getOrElse {Nil})
  }

  trait DefaultMusicxml_SlideFormat extends scalaxb.XMLFormat[musicxml.Slide] with scalaxb.CanWriteChildNodes[musicxml.Slide] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Slide] = seq match {
      case node: scala.xml.Node => Right(musicxml.Slide(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Startu45stop](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ },
        (node \ "@number").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigInt](x, scalaxb.ElemName(node) :: stack)) } orElse Some(scalaxb.DataRecord(None, None, scalaxb.fromXML[BigInt](scala.xml.Text("1"), scalaxb.ElemName(node) :: stack))) map { "@number" -> _ },
        (node \ "@line-type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Lineu45type](x, scalaxb.ElemName(node) :: stack)) } map { "@line-type" -> _ },
        (node \ "@dash-length").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@dash-length" -> _ },
        (node \ "@space-length").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@space-length" -> _ },
        (node \ "@default-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-x" -> _ },
        (node \ "@default-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-y" -> _ },
        (node \ "@relative-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-x" -> _ },
        (node \ "@relative-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-y" -> _ },
        (node \ "@font-family").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-family" -> _ },
        (node \ "@font-style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45style](x, scalaxb.ElemName(node) :: stack)) } map { "@font-style" -> _ },
        (node \ "@font-size").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-size" -> _ },
        (node \ "@font-weight").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45weight](x, scalaxb.ElemName(node) :: stack)) } map { "@font-weight" -> _ },
        (node \ "@color").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@color" -> _ },
        (node \ "@accelerate").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Yesu45no](x, scalaxb.ElemName(node) :: stack)) } map { "@accelerate" -> _ },
        (node \ "@beats").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@beats" -> _ },
        (node \ "@first-beat").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@first-beat" -> _ },
        (node \ "@last-beat").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@last-beat" -> _ },
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Slide, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case ("@number", _) => if (__obj.number.toString != "1") attr = scala.xml.Attribute(null, "number", __obj.number.toString, attr)
        case ("@line-type", _) => __obj.lineu45type foreach { x => attr = scala.xml.Attribute(null, "line-type", x.toString, attr) }
        case ("@dash-length", _) => __obj.dashu45length foreach { x => attr = scala.xml.Attribute(null, "dash-length", x.bigDecimal.toPlainString, attr) }
        case ("@space-length", _) => __obj.spaceu45length foreach { x => attr = scala.xml.Attribute(null, "space-length", x.bigDecimal.toPlainString, attr) }
        case ("@default-x", _) => __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.bigDecimal.toPlainString, attr) }
        case ("@default-y", _) => __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.bigDecimal.toPlainString, attr) }
        case ("@relative-x", _) => __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.bigDecimal.toPlainString, attr) }
        case ("@relative-y", _) => __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.bigDecimal.toPlainString, attr) }
        case ("@font-family", _) => __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
        case ("@font-style", _) => __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
        case ("@font-size", _) => __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
        case ("@font-weight", _) => __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
        case ("@color", _) => __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
        case ("@accelerate", _) => __obj.accelerate foreach { x => attr = scala.xml.Attribute(null, "accelerate", x.toString, attr) }
        case ("@beats", _) => __obj.beats foreach { x => attr = scala.xml.Attribute(null, "beats", x.bigDecimal.toPlainString, attr) }
        case ("@first-beat", _) => __obj.firstu45beat foreach { x => attr = scala.xml.Attribute(null, "first-beat", x.bigDecimal.toPlainString, attr) }
        case ("@last-beat", _) => __obj.lastu45beat foreach { x => attr = scala.xml.Attribute(null, "last-beat", x.bigDecimal.toPlainString, attr) }
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Slide, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultMusicxml_SlurFormat extends scalaxb.XMLFormat[musicxml.Slur] with scalaxb.CanWriteChildNodes[musicxml.Slur] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Slur] = seq match {
      case node: scala.xml.Node => Right(musicxml.Slur(scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Startu45stopu45continue](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ },
        (node \ "@number").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigInt](x, scalaxb.ElemName(node) :: stack)) } orElse Some(scalaxb.DataRecord(None, None, scalaxb.fromXML[BigInt](scala.xml.Text("1"), scalaxb.ElemName(node) :: stack))) map { "@number" -> _ },
        (node \ "@line-type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Lineu45type](x, scalaxb.ElemName(node) :: stack)) } map { "@line-type" -> _ },
        (node \ "@dash-length").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@dash-length" -> _ },
        (node \ "@space-length").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@space-length" -> _ },
        (node \ "@default-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-x" -> _ },
        (node \ "@default-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-y" -> _ },
        (node \ "@relative-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-x" -> _ },
        (node \ "@relative-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-y" -> _ },
        (node \ "@placement").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Aboveu45below](x, scalaxb.ElemName(node) :: stack)) } map { "@placement" -> _ },
        (node \ "@orientation").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Overu45under](x, scalaxb.ElemName(node) :: stack)) } map { "@orientation" -> _ },
        (node \ "@bezier-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@bezier-x" -> _ },
        (node \ "@bezier-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@bezier-y" -> _ },
        (node \ "@bezier-x2").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@bezier-x2" -> _ },
        (node \ "@bezier-y2").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@bezier-y2" -> _ },
        (node \ "@bezier-offset").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@bezier-offset" -> _ },
        (node \ "@bezier-offset2").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@bezier-offset2" -> _ },
        (node \ "@color").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@color" -> _ },
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Slur, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case ("@number", _) => if (__obj.number.toString != "1") attr = scala.xml.Attribute(null, "number", __obj.number.toString, attr)
        case ("@line-type", _) => __obj.lineu45type foreach { x => attr = scala.xml.Attribute(null, "line-type", x.toString, attr) }
        case ("@dash-length", _) => __obj.dashu45length foreach { x => attr = scala.xml.Attribute(null, "dash-length", x.bigDecimal.toPlainString, attr) }
        case ("@space-length", _) => __obj.spaceu45length foreach { x => attr = scala.xml.Attribute(null, "space-length", x.bigDecimal.toPlainString, attr) }
        case ("@default-x", _) => __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.bigDecimal.toPlainString, attr) }
        case ("@default-y", _) => __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.bigDecimal.toPlainString, attr) }
        case ("@relative-x", _) => __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.bigDecimal.toPlainString, attr) }
        case ("@relative-y", _) => __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.bigDecimal.toPlainString, attr) }
        case ("@placement", _) => __obj.placement foreach { x => attr = scala.xml.Attribute(null, "placement", x.toString, attr) }
        case ("@orientation", _) => __obj.orientation foreach { x => attr = scala.xml.Attribute(null, "orientation", x.toString, attr) }
        case ("@bezier-x", _) => __obj.bezieru45x foreach { x => attr = scala.xml.Attribute(null, "bezier-x", x.bigDecimal.toPlainString, attr) }
        case ("@bezier-y", _) => __obj.bezieru45y foreach { x => attr = scala.xml.Attribute(null, "bezier-y", x.bigDecimal.toPlainString, attr) }
        case ("@bezier-x2", _) => __obj.bezieru45x2 foreach { x => attr = scala.xml.Attribute(null, "bezier-x2", x.bigDecimal.toPlainString, attr) }
        case ("@bezier-y2", _) => __obj.bezieru45y2 foreach { x => attr = scala.xml.Attribute(null, "bezier-y2", x.bigDecimal.toPlainString, attr) }
        case ("@bezier-offset", _) => __obj.bezieru45offset foreach { x => attr = scala.xml.Attribute(null, "bezier-offset", x.bigDecimal.toPlainString, attr) }
        case ("@bezier-offset2", _) => __obj.bezieru45offset2 foreach { x => attr = scala.xml.Attribute(null, "bezier-offset2", x.bigDecimal.toPlainString, attr) }
        case ("@color", _) => __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Slur, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil

  }

  trait DefaultMusicxml_StemFormat extends scalaxb.XMLFormat[musicxml.Stem] with scalaxb.CanWriteChildNodes[musicxml.Stem] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Stem] = seq match {
      case node: scala.xml.Node => Right(musicxml.Stem(scalaxb.fromXML[musicxml.Stemu45value](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@default-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-x" -> _ },
        (node \ "@default-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-y" -> _ },
        (node \ "@relative-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-x" -> _ },
        (node \ "@relative-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-y" -> _ },
        (node \ "@color").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@color" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Stem, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@default-x", _) => __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.bigDecimal.toPlainString, attr) }
        case ("@default-y", _) => __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.bigDecimal.toPlainString, attr) }
        case ("@relative-x", _) => __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.bigDecimal.toPlainString, attr) }
        case ("@relative-y", _) => __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.bigDecimal.toPlainString, attr) }
        case ("@color", _) => __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Stem, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultMusicxml_Strongu45accentFormat extends scalaxb.XMLFormat[musicxml.Strongu45accent] with scalaxb.CanWriteChildNodes[musicxml.Strongu45accent] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Strongu45accent] = seq match {
      case node: scala.xml.Node => Right(musicxml.Strongu45accent(scala.collection.immutable.ListMap(List(
        (node \ "@default-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-x" -> _ },
        (node \ "@default-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-y" -> _ },
        (node \ "@relative-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-x" -> _ },
        (node \ "@relative-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-y" -> _ },
        (node \ "@font-family").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-family" -> _ },
        (node \ "@font-style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45style](x, scalaxb.ElemName(node) :: stack)) } map { "@font-style" -> _ },
        (node \ "@font-size").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-size" -> _ },
        (node \ "@font-weight").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45weight](x, scalaxb.ElemName(node) :: stack)) } map { "@font-weight" -> _ },
        (node \ "@color").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@color" -> _ },
        (node \ "@placement").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Aboveu45below](x, scalaxb.ElemName(node) :: stack)) } map { "@placement" -> _ },
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Upu45down](x, scalaxb.ElemName(node) :: stack)) } orElse Some(scalaxb.DataRecord(None, None, scalaxb.fromXML[musicxml.Upu45down](scala.xml.Text("up"), scalaxb.ElemName(node) :: stack))) map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Strongu45accent, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@default-x", _) => __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.bigDecimal.toPlainString, attr) }
        case ("@default-y", _) => __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.bigDecimal.toPlainString, attr) }
        case ("@relative-x", _) => __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.bigDecimal.toPlainString, attr) }
        case ("@relative-y", _) => __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.bigDecimal.toPlainString, attr) }
        case ("@font-family", _) => __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
        case ("@font-style", _) => __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
        case ("@font-size", _) => __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
        case ("@font-weight", _) => __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
        case ("@color", _) => __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
        case ("@placement", _) => __obj.placement foreach { x => attr = scala.xml.Attribute(null, "placement", x.toString, attr) }
        case ("@type", _) => if (__obj.typeValue.toString != "up") attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Strongu45accent, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil

  }

  trait DefaultMusicxml_Styleu45textFormat extends scalaxb.XMLFormat[musicxml.Styleu45text] with scalaxb.CanWriteChildNodes[musicxml.Styleu45text] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Styleu45text] = seq match {
      case node: scala.xml.Node => Right(musicxml.Styleu45text(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@default-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-x" -> _ },
        (node \ "@default-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-y" -> _ },
        (node \ "@relative-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-x" -> _ },
        (node \ "@relative-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-y" -> _ },
        (node \ "@font-family").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-family" -> _ },
        (node \ "@font-style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45style](x, scalaxb.ElemName(node) :: stack)) } map { "@font-style" -> _ },
        (node \ "@font-size").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-size" -> _ },
        (node \ "@font-weight").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45weight](x, scalaxb.ElemName(node) :: stack)) } map { "@font-weight" -> _ },
        (node \ "@color").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@color" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Styleu45text, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@default-x", _) => __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.bigDecimal.toPlainString, attr) }
        case ("@default-y", _) => __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.bigDecimal.toPlainString, attr) }
        case ("@relative-x", _) => __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.bigDecimal.toPlainString, attr) }
        case ("@relative-y", _) => __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.bigDecimal.toPlainString, attr) }
        case ("@font-family", _) => __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
        case ("@font-style", _) => __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
        case ("@font-size", _) => __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
        case ("@font-weight", _) => __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
        case ("@color", _) => __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Styleu45text, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultMusicxml_TapFormat extends scalaxb.XMLFormat[musicxml.Tap] with scalaxb.CanWriteChildNodes[musicxml.Tap] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Tap] = seq match {
      case node: scala.xml.Node => Right(musicxml.Tap(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@hand").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Tapu45hand](x, scalaxb.ElemName(node) :: stack)) } map { "@hand" -> _ },
        (node \ "@default-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-x" -> _ },
        (node \ "@default-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-y" -> _ },
        (node \ "@relative-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-x" -> _ },
        (node \ "@relative-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-y" -> _ },
        (node \ "@font-family").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-family" -> _ },
        (node \ "@font-style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45style](x, scalaxb.ElemName(node) :: stack)) } map { "@font-style" -> _ },
        (node \ "@font-size").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-size" -> _ },
        (node \ "@font-weight").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45weight](x, scalaxb.ElemName(node) :: stack)) } map { "@font-weight" -> _ },
        (node \ "@color").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@color" -> _ },
        (node \ "@placement").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Aboveu45below](x, scalaxb.ElemName(node) :: stack)) } map { "@placement" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Tap, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@hand", _) => __obj.hand foreach { x => attr = scala.xml.Attribute(null, "hand", x.toString, attr) }
        case ("@default-x", _) => __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.bigDecimal.toPlainString, attr) }
        case ("@default-y", _) => __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.bigDecimal.toPlainString, attr) }
        case ("@relative-x", _) => __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.bigDecimal.toPlainString, attr) }
        case ("@relative-y", _) => __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.bigDecimal.toPlainString, attr) }
        case ("@font-family", _) => __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
        case ("@font-style", _) => __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
        case ("@font-size", _) => __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
        case ("@font-weight", _) => __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
        case ("@color", _) => __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
        case ("@placement", _) => __obj.placement foreach { x => attr = scala.xml.Attribute(null, "placement", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Tap, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultMusicxml_TechnicalFormat extends scalaxb.ElemNameParser[musicxml.Technical] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("technical")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[musicxml.Technical] =
      phrase(safeRep(((scalaxb.ElemName(None, "up-bow")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Emptyu45placementable](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "down-bow")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Emptyu45placementable](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "harmonic")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Harmonic](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "open-string")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Emptyu45placementable](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "thumb-position")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Emptyu45placementable](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "fingering")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Fingering](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "pluck")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Placementu45text](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "double-tongue")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Emptyu45placementable](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "triple-tongue")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Emptyu45placementable](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "stopped")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Emptyu45placementu45smufl](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "snap-pizzicato")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Emptyu45placementable](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "fret")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Fret](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "string")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.StringType](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "hammer-on")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Hammeru45onu45pullu45off](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "pull-off")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Hammeru45onu45pullu45off](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "bend")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Bend](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "tap")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Tap](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "heel")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Heelu45toe](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "toe")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Heelu45toe](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "fingernails")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Emptyu45placementable](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "hole")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Hole](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "arrow")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.ArrowType](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "handbell")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Handbell](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "brass-bend")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Emptyu45placementable](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "flip")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Emptyu45placementable](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "smear")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Emptyu45placementable](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "open")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Emptyu45placementu45smufl](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "half-muted")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Emptyu45placementu45smufl](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "harmon-mute")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Harmonu45mute](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "golpe")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Emptyu45placementable](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "other-technical")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Otheru45placementu45text](x, scalaxb.ElemName(node) :: stack))))) ^^
      { case p1 =>
      musicxml.Technical(p1,
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: musicxml.Technical, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Technical, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.technicaloption flatMap { x => scalaxb.toXML[scalaxb.DataRecord[musicxml.TechnicalOption]](x, x.namespace, x.key, __scope, false) })
  }

  trait DefaultMusicxml_Textu45elementu45dataFormat extends scalaxb.XMLFormat[musicxml.Textu45elementu45data] with scalaxb.CanWriteChildNodes[musicxml.Textu45elementu45data] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Textu45elementu45data] = seq match {
      case node: scala.xml.Node => Right(musicxml.Textu45elementu45data(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@font-family").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-family" -> _ },
        (node \ "@font-style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45style](x, scalaxb.ElemName(node) :: stack)) } map { "@font-style" -> _ },
        (node \ "@font-size").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-size" -> _ },
        (node \ "@font-weight").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45weight](x, scalaxb.ElemName(node) :: stack)) } map { "@font-weight" -> _ },
        (node \ "@color").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@color" -> _ },
        (node \ "@underline").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigInt](x, scalaxb.ElemName(node) :: stack)) } map { "@underline" -> _ },
        (node \ "@overline").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigInt](x, scalaxb.ElemName(node) :: stack)) } map { "@overline" -> _ },
        (node \ "@line-through").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigInt](x, scalaxb.ElemName(node) :: stack)) } map { "@line-through" -> _ },
        (node \ "@rotation").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@rotation" -> _ },
        (node \ "@letter-spacing").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@letter-spacing" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}lang").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}lang" -> _ },
        (node \ "@dir").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Textu45direction](x, scalaxb.ElemName(node) :: stack)) } map { "@dir" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Textu45elementu45data, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@font-family", _) => __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
        case ("@font-style", _) => __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
        case ("@font-size", _) => __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
        case ("@font-weight", _) => __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
        case ("@color", _) => __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
        case ("@underline", _) => __obj.underline foreach { x => attr = scala.xml.Attribute(null, "underline", x.toString, attr) }
        case ("@overline", _) => __obj.overline foreach { x => attr = scala.xml.Attribute(null, "overline", x.toString, attr) }
        case ("@line-through", _) => __obj.lineu45through foreach { x => attr = scala.xml.Attribute(null, "line-through", x.toString, attr) }
        case ("@rotation", _) => __obj.rotation foreach { x => attr = scala.xml.Attribute(null, "rotation", x.bigDecimal.toPlainString, attr) }
        case ("@letter-spacing", _) => __obj.letteru45spacing foreach { x => attr = scala.xml.Attribute(null, "letter-spacing", x.toString, attr) }
        case ("@{http://www.w3.org/XML/1998/namespace}lang", _) => __obj.xmllang foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", x.toString, attr) }
        case ("@dir", _) => __obj.dir foreach { x => attr = scala.xml.Attribute(null, "dir", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Textu45elementu45data, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultMusicxml_TieFormat extends scalaxb.XMLFormat[musicxml.Tie] with scalaxb.CanWriteChildNodes[musicxml.Tie] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Tie] = seq match {
      case node: scala.xml.Node => Right(musicxml.Tie(scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Startu45stop](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ },
        (node \ "@time-only").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@time-only" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Tie, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case ("@time-only", _) => __obj.timeu45only foreach { x => attr = scala.xml.Attribute(null, "time-only", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Tie, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil

  }

  trait DefaultMusicxml_TiedFormat extends scalaxb.XMLFormat[musicxml.Tied] with scalaxb.CanWriteChildNodes[musicxml.Tied] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Tied] = seq match {
      case node: scala.xml.Node => Right(musicxml.Tied(scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Tiedu45type](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ },
        (node \ "@number").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigInt](x, scalaxb.ElemName(node) :: stack)) } map { "@number" -> _ },
        (node \ "@line-type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Lineu45type](x, scalaxb.ElemName(node) :: stack)) } map { "@line-type" -> _ },
        (node \ "@dash-length").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@dash-length" -> _ },
        (node \ "@space-length").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@space-length" -> _ },
        (node \ "@default-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-x" -> _ },
        (node \ "@default-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-y" -> _ },
        (node \ "@relative-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-x" -> _ },
        (node \ "@relative-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-y" -> _ },
        (node \ "@placement").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Aboveu45below](x, scalaxb.ElemName(node) :: stack)) } map { "@placement" -> _ },
        (node \ "@orientation").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Overu45under](x, scalaxb.ElemName(node) :: stack)) } map { "@orientation" -> _ },
        (node \ "@bezier-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@bezier-x" -> _ },
        (node \ "@bezier-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@bezier-y" -> _ },
        (node \ "@bezier-x2").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@bezier-x2" -> _ },
        (node \ "@bezier-y2").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@bezier-y2" -> _ },
        (node \ "@bezier-offset").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@bezier-offset" -> _ },
        (node \ "@bezier-offset2").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@bezier-offset2" -> _ },
        (node \ "@color").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@color" -> _ },
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Tied, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case ("@number", _) => __obj.number foreach { x => attr = scala.xml.Attribute(null, "number", x.toString, attr) }
        case ("@line-type", _) => __obj.lineu45type foreach { x => attr = scala.xml.Attribute(null, "line-type", x.toString, attr) }
        case ("@dash-length", _) => __obj.dashu45length foreach { x => attr = scala.xml.Attribute(null, "dash-length", x.bigDecimal.toPlainString, attr) }
        case ("@space-length", _) => __obj.spaceu45length foreach { x => attr = scala.xml.Attribute(null, "space-length", x.bigDecimal.toPlainString, attr) }
        case ("@default-x", _) => __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.bigDecimal.toPlainString, attr) }
        case ("@default-y", _) => __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.bigDecimal.toPlainString, attr) }
        case ("@relative-x", _) => __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.bigDecimal.toPlainString, attr) }
        case ("@relative-y", _) => __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.bigDecimal.toPlainString, attr) }
        case ("@placement", _) => __obj.placement foreach { x => attr = scala.xml.Attribute(null, "placement", x.toString, attr) }
        case ("@orientation", _) => __obj.orientation foreach { x => attr = scala.xml.Attribute(null, "orientation", x.toString, attr) }
        case ("@bezier-x", _) => __obj.bezieru45x foreach { x => attr = scala.xml.Attribute(null, "bezier-x", x.bigDecimal.toPlainString, attr) }
        case ("@bezier-y", _) => __obj.bezieru45y foreach { x => attr = scala.xml.Attribute(null, "bezier-y", x.bigDecimal.toPlainString, attr) }
        case ("@bezier-x2", _) => __obj.bezieru45x2 foreach { x => attr = scala.xml.Attribute(null, "bezier-x2", x.bigDecimal.toPlainString, attr) }
        case ("@bezier-y2", _) => __obj.bezieru45y2 foreach { x => attr = scala.xml.Attribute(null, "bezier-y2", x.bigDecimal.toPlainString, attr) }
        case ("@bezier-offset", _) => __obj.bezieru45offset foreach { x => attr = scala.xml.Attribute(null, "bezier-offset", x.bigDecimal.toPlainString, attr) }
        case ("@bezier-offset2", _) => __obj.bezieru45offset2 foreach { x => attr = scala.xml.Attribute(null, "bezier-offset2", x.bigDecimal.toPlainString, attr) }
        case ("@color", _) => __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Tied, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil

  }

  trait DefaultMusicxml_Timeu45modificationableFormat extends scalaxb.XMLFormat[musicxml.Timeu45modificationable] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Timeu45modificationable] = seq match {
      case node: scala.xml.Node =>     
        scalaxb.Helper.instanceType(node) match {
          case (None, Some("metronome-tuplet")) => Right(scalaxb.fromXML[musicxml.Metronomeu45tuplet](node, stack))
          case _ => Right(scalaxb.fromXML[musicxml.Timeu45modification](node, stack))
        }
      case _ => Left("reads failed: seq must be scala.xml.Node")  
    }
    
    def writes(__obj: musicxml.Timeu45modificationable, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq = __obj match {
      case x: musicxml.Metronomeu45tuplet => scalaxb.toXML[musicxml.Metronomeu45tuplet](x, __namespace, __elementLabel, __scope, true)
      case x: musicxml.Timeu45modification => scalaxb.toXML[musicxml.Timeu45modification](x, __namespace, __elementLabel, __scope, __typeAttribute)
    }
  }
  trait DefaultMusicxml_Timeu45modificationFormat extends scalaxb.ElemNameParser[musicxml.Timeu45modification] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("time-modification")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[musicxml.Timeu45modification] =
      phrase((scalaxb.ElemName(None, "actual-notes")) ~ 
      (scalaxb.ElemName(None, "normal-notes")) ~ 
      opt(((scalaxb.ElemName(None, "normal-type")) ~ 
      safeRep(scalaxb.ElemName(None, "normal-dot"))) ^^ 
        { case p1 ~ p2 => musicxml.Timeu45modificationableSequence1(scalaxb.fromXML[musicxml.Noteu45typeu45value](p1, scalaxb.ElemName(node) :: stack),
        p2 map { scalaxb.fromXML[musicxml.Empty](_, scalaxb.ElemName(node) :: stack) }) }) ^^
      { case p1 ~ p2 ~ p3 =>
      musicxml.Timeu45modification(scalaxb.fromXML[BigInt](p1, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[BigInt](p2, scalaxb.ElemName(node) :: stack),
        p3) })
    
    def writesChildNodes(__obj: musicxml.Timeu45modification, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(scalaxb.toXML[BigInt](__obj.actualu45notes, None, Some("actual-notes"), __scope, false),
        scalaxb.toXML[BigInt](__obj.normalu45notes, None, Some("normal-notes"), __scope, false),
        __obj.timeu45modificationablesequence1 map { scalaxb.toXML[musicxml.Timeu45modificationableSequence1](_, None, Some("timeu45modificationablesequence1"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultMusicxml_Timeu45modificationableSequence1Format extends scalaxb.XMLFormat[musicxml.Timeu45modificationableSequence1] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Timeu45modificationableSequence1] = Left("don't call me.")
    
    def writes(__obj: musicxml.Timeu45modificationableSequence1, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(scalaxb.toXML[musicxml.Noteu45typeu45value](__obj.normalu45type, None, Some("normal-type"), __scope, false),
        __obj.normalu45dot flatMap { scalaxb.toXML[musicxml.Empty](_, None, Some("normal-dot"), __scope, false) })


  }

  trait DefaultMusicxml_TremoloFormat extends scalaxb.XMLFormat[musicxml.Tremolo] with scalaxb.CanWriteChildNodes[musicxml.Tremolo] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Tremolo] = seq match {
      case node: scala.xml.Node => Right(musicxml.Tremolo(scalaxb.fromXML[BigInt](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Tremolou45type](x, scalaxb.ElemName(node) :: stack)) } orElse Some(scalaxb.DataRecord(None, None, scalaxb.fromXML[musicxml.Tremolou45type](scala.xml.Text("single"), scalaxb.ElemName(node) :: stack))) map { "@type" -> _ },
        (node \ "@default-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-x" -> _ },
        (node \ "@default-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-y" -> _ },
        (node \ "@relative-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-x" -> _ },
        (node \ "@relative-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-y" -> _ },
        (node \ "@font-family").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-family" -> _ },
        (node \ "@font-style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45style](x, scalaxb.ElemName(node) :: stack)) } map { "@font-style" -> _ },
        (node \ "@font-size").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-size" -> _ },
        (node \ "@font-weight").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45weight](x, scalaxb.ElemName(node) :: stack)) } map { "@font-weight" -> _ },
        (node \ "@color").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@color" -> _ },
        (node \ "@placement").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Aboveu45below](x, scalaxb.ElemName(node) :: stack)) } map { "@placement" -> _ },
        (node \ "@smufl").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@smufl" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Tremolo, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => if (__obj.typeValue.toString != "single") attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case ("@default-x", _) => __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.bigDecimal.toPlainString, attr) }
        case ("@default-y", _) => __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.bigDecimal.toPlainString, attr) }
        case ("@relative-x", _) => __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.bigDecimal.toPlainString, attr) }
        case ("@relative-y", _) => __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.bigDecimal.toPlainString, attr) }
        case ("@font-family", _) => __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
        case ("@font-style", _) => __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
        case ("@font-size", _) => __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
        case ("@font-weight", _) => __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
        case ("@color", _) => __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
        case ("@placement", _) => __obj.placement foreach { x => attr = scala.xml.Attribute(null, "placement", x.toString, attr) }
        case ("@smufl", _) => __obj.smufl foreach { x => attr = scala.xml.Attribute(null, "smufl", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Tremolo, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultMusicxml_TupletFormat extends scalaxb.ElemNameParser[musicxml.Tuplet] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("tuplet")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[musicxml.Tuplet] =
      phrase(opt(scalaxb.ElemName(None, "tuplet-actual")) ~ 
      opt(scalaxb.ElemName(None, "tuplet-normal")) ^^
      { case p1 ~ p2 =>
      musicxml.Tuplet(p1.headOption map { scalaxb.fromXML[musicxml.Tupletu45portion](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[musicxml.Tupletu45portion](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Startu45stop](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ },
        (node \ "@number").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigInt](x, scalaxb.ElemName(node) :: stack)) } map { "@number" -> _ },
        (node \ "@bracket").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Yesu45no](x, scalaxb.ElemName(node) :: stack)) } map { "@bracket" -> _ },
        (node \ "@show-number").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Showu45tuplet](x, scalaxb.ElemName(node) :: stack)) } map { "@show-number" -> _ },
        (node \ "@show-type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Showu45tuplet](x, scalaxb.ElemName(node) :: stack)) } map { "@show-type" -> _ },
        (node \ "@line-shape").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Lineu45shape](x, scalaxb.ElemName(node) :: stack)) } map { "@line-shape" -> _ },
        (node \ "@default-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-x" -> _ },
        (node \ "@default-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-y" -> _ },
        (node \ "@relative-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-x" -> _ },
        (node \ "@relative-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-y" -> _ },
        (node \ "@placement").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Aboveu45below](x, scalaxb.ElemName(node) :: stack)) } map { "@placement" -> _ },
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: musicxml.Tuplet, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case ("@number", _) => __obj.number foreach { x => attr = scala.xml.Attribute(null, "number", x.toString, attr) }
        case ("@bracket", _) => __obj.bracket foreach { x => attr = scala.xml.Attribute(null, "bracket", x.toString, attr) }
        case ("@show-number", _) => __obj.showu45number foreach { x => attr = scala.xml.Attribute(null, "show-number", x.toString, attr) }
        case ("@show-type", _) => __obj.showu45type foreach { x => attr = scala.xml.Attribute(null, "show-type", x.toString, attr) }
        case ("@line-shape", _) => __obj.lineu45shape foreach { x => attr = scala.xml.Attribute(null, "line-shape", x.toString, attr) }
        case ("@default-x", _) => __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.bigDecimal.toPlainString, attr) }
        case ("@default-y", _) => __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.bigDecimal.toPlainString, attr) }
        case ("@relative-x", _) => __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.bigDecimal.toPlainString, attr) }
        case ("@relative-y", _) => __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.bigDecimal.toPlainString, attr) }
        case ("@placement", _) => __obj.placement foreach { x => attr = scala.xml.Attribute(null, "placement", x.toString, attr) }
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Tuplet, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.tupletu45actual map { scalaxb.toXML[musicxml.Tupletu45portion](_, None, Some("tuplet-actual"), __scope, false) } getOrElse {Nil},
        __obj.tupletu45normal map { scalaxb.toXML[musicxml.Tupletu45portion](_, None, Some("tuplet-normal"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultMusicxml_Tupletu45dotFormat extends scalaxb.XMLFormat[musicxml.Tupletu45dot] with scalaxb.CanWriteChildNodes[musicxml.Tupletu45dot] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Tupletu45dot] = seq match {
      case node: scala.xml.Node => Right(musicxml.Tupletu45dot(scala.collection.immutable.ListMap(List(
        (node \ "@font-family").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-family" -> _ },
        (node \ "@font-style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45style](x, scalaxb.ElemName(node) :: stack)) } map { "@font-style" -> _ },
        (node \ "@font-size").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-size" -> _ },
        (node \ "@font-weight").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45weight](x, scalaxb.ElemName(node) :: stack)) } map { "@font-weight" -> _ },
        (node \ "@color").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@color" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Tupletu45dot, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@font-family", _) => __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
        case ("@font-style", _) => __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
        case ("@font-size", _) => __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
        case ("@font-weight", _) => __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
        case ("@color", _) => __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Tupletu45dot, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil

  }

  trait DefaultMusicxml_Tupletu45numberFormat extends scalaxb.XMLFormat[musicxml.Tupletu45number] with scalaxb.CanWriteChildNodes[musicxml.Tupletu45number] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Tupletu45number] = seq match {
      case node: scala.xml.Node => Right(musicxml.Tupletu45number(scalaxb.fromXML[BigInt](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@font-family").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-family" -> _ },
        (node \ "@font-style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45style](x, scalaxb.ElemName(node) :: stack)) } map { "@font-style" -> _ },
        (node \ "@font-size").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-size" -> _ },
        (node \ "@font-weight").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45weight](x, scalaxb.ElemName(node) :: stack)) } map { "@font-weight" -> _ },
        (node \ "@color").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@color" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Tupletu45number, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@font-family", _) => __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
        case ("@font-style", _) => __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
        case ("@font-size", _) => __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
        case ("@font-weight", _) => __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
        case ("@color", _) => __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Tupletu45number, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultMusicxml_Tupletu45portionFormat extends scalaxb.ElemNameParser[musicxml.Tupletu45portion] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("tuplet-portion")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[musicxml.Tupletu45portion] =
      phrase(opt(scalaxb.ElemName(None, "tuplet-number")) ~ 
      opt(scalaxb.ElemName(None, "tuplet-type")) ~ 
      safeRep(scalaxb.ElemName(None, "tuplet-dot")) ^^
      { case p1 ~ p2 ~ p3 =>
      musicxml.Tupletu45portion(p1.headOption map { scalaxb.fromXML[musicxml.Tupletu45number](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[musicxml.Tupletu45type](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[musicxml.Tupletu45dot](_, scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: musicxml.Tupletu45portion, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.tupletu45number map { scalaxb.toXML[musicxml.Tupletu45number](_, None, Some("tuplet-number"), __scope, false) } getOrElse {Nil},
        __obj.tupletu45type map { scalaxb.toXML[musicxml.Tupletu45type](_, None, Some("tuplet-type"), __scope, false) } getOrElse {Nil},
        __obj.tupletu45dot flatMap { scalaxb.toXML[musicxml.Tupletu45dot](_, None, Some("tuplet-dot"), __scope, false) })

  }

  trait DefaultMusicxml_Tupletu45typeFormat extends scalaxb.XMLFormat[musicxml.Tupletu45type] with scalaxb.CanWriteChildNodes[musicxml.Tupletu45type] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Tupletu45type] = seq match {
      case node: scala.xml.Node => Right(musicxml.Tupletu45type(scalaxb.fromXML[musicxml.Noteu45typeu45value](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@font-family").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-family" -> _ },
        (node \ "@font-style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45style](x, scalaxb.ElemName(node) :: stack)) } map { "@font-style" -> _ },
        (node \ "@font-size").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-size" -> _ },
        (node \ "@font-weight").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45weight](x, scalaxb.ElemName(node) :: stack)) } map { "@font-weight" -> _ },
        (node \ "@color").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@color" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Tupletu45type, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@font-family", _) => __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
        case ("@font-style", _) => __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
        case ("@font-size", _) => __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
        case ("@font-weight", _) => __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
        case ("@color", _) => __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Tupletu45type, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultMusicxml_UnpitchedFormat extends scalaxb.ElemNameParser[musicxml.Unpitched] with Musicxml_Displayu45stepu45octaveGroupFormat {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("unpitched")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[musicxml.Unpitched] =
      phrase(opt(parseDisplayu45stepu45octaveGroup(node, scalaxb.ElemName(node) :: stack)) ^^
      { case p1 =>
      musicxml.Unpitched(p1) })
    
    def writesChildNodes(__obj: musicxml.Unpitched, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.displayu45stepu45octaveSequence1 map { scalaxb.toXML[musicxml.Displayu45stepu45octaveSequence](_, None, Some("displayu45stepu45octaveSequence1"), __scope, false) } getOrElse {Nil})
  }

  trait DefaultMusicxml_CreditFormat extends scalaxb.ElemNameParser[musicxml.Credit] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("credit")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[musicxml.Credit] =
      phrase(safeRep(scalaxb.ElemName(None, "credit-type")) ~ 
      safeRep(scalaxb.ElemName(None, "link")) ~ 
      safeRep(scalaxb.ElemName(None, "bookmark")) ~ 
      (((scalaxb.ElemName(None, "credit-image")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Image](x, scalaxb.ElemName(node) :: stack)))) ||| 
      (((((scalaxb.ElemName(None, "credit-words")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Formattedu45textu45id](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "credit-symbol")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Formattedu45symbolu45id](x, scalaxb.ElemName(node) :: stack))))) ~ 
      safeRep((safeRep(scalaxb.ElemName(None, "link")) ~ 
      safeRep(scalaxb.ElemName(None, "bookmark")) ~ 
      (((scalaxb.ElemName(None, "credit-words")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Formattedu45textu45id](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "credit-symbol")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Formattedu45symbolu45id](x, scalaxb.ElemName(node) :: stack)))))) ^^ 
        { case p1 ~ p2 ~ p3 => musicxml.CreditSequence2(p1 map { scalaxb.fromXML[musicxml.Link](_, scalaxb.ElemName(node) :: stack) },
        p2 map { scalaxb.fromXML[musicxml.Bookmark](_, scalaxb.ElemName(node) :: stack) },
        p3) })) ^^ 
        { case p1 ~ p2 => scalaxb.DataRecord(musicxml.CreditSequence1(p1,
        p2)) })) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      musicxml.Credit(p1 map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        p2 map { scalaxb.fromXML[musicxml.Link](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[musicxml.Bookmark](_, scalaxb.ElemName(node) :: stack) },
        p4,
        scala.collection.immutable.ListMap(List(
        (node \ "@page").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigInt](x, scalaxb.ElemName(node) :: stack)) } map { "@page" -> _ },
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: musicxml.Credit, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@page", _) => __obj.page foreach { x => attr = scala.xml.Attribute(null, "page", x.toString, attr) }
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Credit, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.creditu45type flatMap { scalaxb.toXML[String](_, None, Some("credit-type"), __scope, false) },
        __obj.link flatMap { scalaxb.toXML[musicxml.Link](_, None, Some("link"), __scope, false) },
        __obj.bookmark flatMap { scalaxb.toXML[musicxml.Bookmark](_, None, Some("bookmark"), __scope, false) },
        (Some(__obj.creditoption) map {x => scalaxb.toXML[scalaxb.DataRecord[musicxml.CreditOption]](x, x.namespace, x.key, __scope, false)}).get)

  }

  trait DefaultMusicxml_CreditSequence2Format extends scalaxb.XMLFormat[musicxml.CreditSequence2] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.CreditSequence2] = Left("don't call me.")
    
    def writes(__obj: musicxml.CreditSequence2, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(__obj.link flatMap { scalaxb.toXML[musicxml.Link](_, None, Some("link"), __scope, false) },
        __obj.bookmark flatMap { scalaxb.toXML[musicxml.Bookmark](_, None, Some("bookmark"), __scope, false) },
        (Some(__obj.creditoption3) map {x => scalaxb.toXML[scalaxb.DataRecord[musicxml.CreditOption3]](x, x.namespace, x.key, __scope, false)}).get)


  }

  trait DefaultMusicxml_CreditSequence1Format extends scalaxb.XMLFormat[musicxml.CreditSequence1] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.CreditSequence1] = Left("don't call me.")
    
    def writes(__obj: musicxml.CreditSequence1, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat((Some(__obj.creditoption2) map {x => scalaxb.toXML[scalaxb.DataRecord[musicxml.CreditOption2]](x, x.namespace, x.key, __scope, false)}).get,
        __obj.creditsequence2 flatMap { scalaxb.toXML[musicxml.CreditSequence2](_, None, Some("creditsequence2"), __scope, false) })


  }

  trait DefaultMusicxml_DefaultsFormat extends scalaxb.ElemNameParser[musicxml.Defaults] with Musicxml_LayoutGroupFormat {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("defaults")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[musicxml.Defaults] =
      phrase(opt(scalaxb.ElemName(None, "scaling")) ~ 
      (parseLayoutGroup(node, scalaxb.ElemName(node) :: stack)) ~ 
      opt(scalaxb.ElemName(None, "appearance")) ~ 
      opt(scalaxb.ElemName(None, "music-font")) ~ 
      opt(scalaxb.ElemName(None, "word-font")) ~ 
      safeRep(scalaxb.ElemName(None, "lyric-font")) ~ 
      safeRep(scalaxb.ElemName(None, "lyric-language")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 =>
      musicxml.Defaults(p1.headOption map { scalaxb.fromXML[musicxml.Scaling](_, scalaxb.ElemName(node) :: stack) },
        p2,
        p3.headOption map { scalaxb.fromXML[musicxml.Appearance](_, scalaxb.ElemName(node) :: stack) },
        p4.headOption map { scalaxb.fromXML[musicxml.Emptyu45font](_, scalaxb.ElemName(node) :: stack) },
        p5.headOption map { scalaxb.fromXML[musicxml.Emptyu45font](_, scalaxb.ElemName(node) :: stack) },
        p6 map { scalaxb.fromXML[musicxml.Lyricu45font](_, scalaxb.ElemName(node) :: stack) },
        p7 map { scalaxb.fromXML[musicxml.Lyricu45language](_, scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: musicxml.Defaults, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.scaling map { scalaxb.toXML[musicxml.Scaling](_, None, Some("scaling"), __scope, false) } getOrElse {Nil},
        scalaxb.toXML[musicxml.LayoutSequence](__obj.layoutSequence2, None, Some("layoutSequence2"), __scope, false),
        __obj.appearance map { scalaxb.toXML[musicxml.Appearance](_, None, Some("appearance"), __scope, false) } getOrElse {Nil},
        __obj.musicu45font map { scalaxb.toXML[musicxml.Emptyu45font](_, None, Some("music-font"), __scope, false) } getOrElse {Nil},
        __obj.wordu45font map { scalaxb.toXML[musicxml.Emptyu45font](_, None, Some("word-font"), __scope, false) } getOrElse {Nil},
        __obj.lyricu45font flatMap { scalaxb.toXML[musicxml.Lyricu45font](_, None, Some("lyric-font"), __scope, false) },
        __obj.lyricu45language flatMap { scalaxb.toXML[musicxml.Lyricu45language](_, None, Some("lyric-language"), __scope, false) })

  }

  trait DefaultMusicxml_Emptyu45fontFormat extends scalaxb.XMLFormat[musicxml.Emptyu45font] with scalaxb.CanWriteChildNodes[musicxml.Emptyu45font] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Emptyu45font] = seq match {
      case node: scala.xml.Node => Right(musicxml.Emptyu45font(scala.collection.immutable.ListMap(List(
        (node \ "@font-family").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-family" -> _ },
        (node \ "@font-style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45style](x, scalaxb.ElemName(node) :: stack)) } map { "@font-style" -> _ },
        (node \ "@font-size").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-size" -> _ },
        (node \ "@font-weight").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45weight](x, scalaxb.ElemName(node) :: stack)) } map { "@font-weight" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Emptyu45font, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@font-family", _) => __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
        case ("@font-style", _) => __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
        case ("@font-size", _) => __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
        case ("@font-weight", _) => __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Emptyu45font, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil

  }

  trait DefaultMusicxml_Groupu45barlineFormat extends scalaxb.XMLFormat[musicxml.Groupu45barline] with scalaxb.CanWriteChildNodes[musicxml.Groupu45barline] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Groupu45barline] = seq match {
      case node: scala.xml.Node => Right(musicxml.Groupu45barline(scalaxb.fromXML[musicxml.Groupu45barlineu45value](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@color").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@color" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Groupu45barline, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@color", _) => __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Groupu45barline, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultMusicxml_Groupu45nameFormat extends scalaxb.XMLFormat[musicxml.Groupu45name] with scalaxb.CanWriteChildNodes[musicxml.Groupu45name] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Groupu45name] = seq match {
      case node: scala.xml.Node => Right(musicxml.Groupu45name(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@default-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-x" -> _ },
        (node \ "@default-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-y" -> _ },
        (node \ "@relative-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-x" -> _ },
        (node \ "@relative-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-y" -> _ },
        (node \ "@font-family").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-family" -> _ },
        (node \ "@font-style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45style](x, scalaxb.ElemName(node) :: stack)) } map { "@font-style" -> _ },
        (node \ "@font-size").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-size" -> _ },
        (node \ "@font-weight").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45weight](x, scalaxb.ElemName(node) :: stack)) } map { "@font-weight" -> _ },
        (node \ "@color").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@color" -> _ },
        (node \ "@justify").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Leftu45centeru45right](x, scalaxb.ElemName(node) :: stack)) } map { "@justify" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Groupu45name, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@default-x", _) => __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.bigDecimal.toPlainString, attr) }
        case ("@default-y", _) => __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.bigDecimal.toPlainString, attr) }
        case ("@relative-x", _) => __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.bigDecimal.toPlainString, attr) }
        case ("@relative-y", _) => __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.bigDecimal.toPlainString, attr) }
        case ("@font-family", _) => __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
        case ("@font-style", _) => __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
        case ("@font-size", _) => __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
        case ("@font-weight", _) => __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
        case ("@color", _) => __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
        case ("@justify", _) => __obj.justify foreach { x => attr = scala.xml.Attribute(null, "justify", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Groupu45name, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultMusicxml_Groupu45symbolFormat extends scalaxb.XMLFormat[musicxml.Groupu45symbol] with scalaxb.CanWriteChildNodes[musicxml.Groupu45symbol] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Groupu45symbol] = seq match {
      case node: scala.xml.Node => Right(musicxml.Groupu45symbol(scalaxb.fromXML[musicxml.Groupu45symbolu45value](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@default-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-x" -> _ },
        (node \ "@default-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-y" -> _ },
        (node \ "@relative-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-x" -> _ },
        (node \ "@relative-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-y" -> _ },
        (node \ "@color").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@color" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Groupu45symbol, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@default-x", _) => __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.bigDecimal.toPlainString, attr) }
        case ("@default-y", _) => __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.bigDecimal.toPlainString, attr) }
        case ("@relative-x", _) => __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.bigDecimal.toPlainString, attr) }
        case ("@relative-y", _) => __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.bigDecimal.toPlainString, attr) }
        case ("@color", _) => __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Groupu45symbol, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultMusicxml_Lyricu45fontFormat extends scalaxb.XMLFormat[musicxml.Lyricu45font] with scalaxb.CanWriteChildNodes[musicxml.Lyricu45font] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Lyricu45font] = seq match {
      case node: scala.xml.Node => Right(musicxml.Lyricu45font(scala.collection.immutable.ListMap(List(
        (node \ "@number").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@number" -> _ },
        (node \ "@name").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@name" -> _ },
        (node \ "@font-family").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-family" -> _ },
        (node \ "@font-style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45style](x, scalaxb.ElemName(node) :: stack)) } map { "@font-style" -> _ },
        (node \ "@font-size").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-size" -> _ },
        (node \ "@font-weight").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45weight](x, scalaxb.ElemName(node) :: stack)) } map { "@font-weight" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Lyricu45font, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@number", _) => __obj.number foreach { x => attr = scala.xml.Attribute(null, "number", x.toString, attr) }
        case ("@name", _) => __obj.name foreach { x => attr = scala.xml.Attribute(null, "name", x.toString, attr) }
        case ("@font-family", _) => __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
        case ("@font-style", _) => __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
        case ("@font-size", _) => __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
        case ("@font-weight", _) => __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Lyricu45font, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil

  }

  trait DefaultMusicxml_Lyricu45languageFormat extends scalaxb.XMLFormat[musicxml.Lyricu45language] with scalaxb.CanWriteChildNodes[musicxml.Lyricu45language] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Lyricu45language] = seq match {
      case node: scala.xml.Node => Right(musicxml.Lyricu45language(scala.collection.immutable.ListMap(List(
        (node \ "@number").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@number" -> _ },
        (node \ "@name").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@name" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}lang").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}lang" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Lyricu45language, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@number", _) => __obj.number foreach { x => attr = scala.xml.Attribute(null, "number", x.toString, attr) }
        case ("@name", _) => __obj.name foreach { x => attr = scala.xml.Attribute(null, "name", x.toString, attr) }
        case ("@{http://www.w3.org/XML/1998/namespace}lang", _) => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", __obj.xmllang.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Lyricu45language, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil

  }

  trait DefaultMusicxml_Partu45groupFormat extends scalaxb.ElemNameParser[musicxml.Partu45group] with Musicxml_EditorialGroupFormat {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("part-group")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[musicxml.Partu45group] =
      phrase(opt(scalaxb.ElemName(None, "group-name")) ~ 
      opt(scalaxb.ElemName(None, "group-name-display")) ~ 
      opt(scalaxb.ElemName(None, "group-abbreviation")) ~ 
      opt(scalaxb.ElemName(None, "group-abbreviation-display")) ~ 
      opt(scalaxb.ElemName(None, "group-symbol")) ~ 
      opt(scalaxb.ElemName(None, "group-barline")) ~ 
      opt(scalaxb.ElemName(None, "group-time")) ~ 
      (parseEditorialGroup(node, scalaxb.ElemName(node) :: stack)) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 =>
      musicxml.Partu45group(p1.headOption map { scalaxb.fromXML[musicxml.Groupu45name](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[musicxml.Nameu45display](_, scalaxb.ElemName(node) :: stack) },
        p3.headOption map { scalaxb.fromXML[musicxml.Groupu45name](_, scalaxb.ElemName(node) :: stack) },
        p4.headOption map { scalaxb.fromXML[musicxml.Nameu45display](_, scalaxb.ElemName(node) :: stack) },
        p5.headOption map { scalaxb.fromXML[musicxml.Groupu45symbol](_, scalaxb.ElemName(node) :: stack) },
        p6.headOption map { scalaxb.fromXML[musicxml.Groupu45barline](_, scalaxb.ElemName(node) :: stack) },
        p7.headOption map { scalaxb.fromXML[musicxml.Empty](_, scalaxb.ElemName(node) :: stack) },
        p8,
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Startu45stop](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ },
        (node \ "@number").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } orElse Some(scalaxb.DataRecord(None, None, scalaxb.fromXML[String](scala.xml.Text("1"), scalaxb.ElemName(node) :: stack))) map { "@number" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: musicxml.Partu45group, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case ("@number", _) => if (__obj.number.toString != "1") attr = scala.xml.Attribute(null, "number", __obj.number.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Partu45group, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.groupu45name map { scalaxb.toXML[musicxml.Groupu45name](_, None, Some("group-name"), __scope, false) } getOrElse {Nil},
        __obj.groupu45nameu45display map { scalaxb.toXML[musicxml.Nameu45display](_, None, Some("group-name-display"), __scope, false) } getOrElse {Nil},
        __obj.groupu45abbreviation map { scalaxb.toXML[musicxml.Groupu45name](_, None, Some("group-abbreviation"), __scope, false) } getOrElse {Nil},
        __obj.groupu45abbreviationu45display map { scalaxb.toXML[musicxml.Nameu45display](_, None, Some("group-abbreviation-display"), __scope, false) } getOrElse {Nil},
        __obj.groupu45symbol map { scalaxb.toXML[musicxml.Groupu45symbol](_, None, Some("group-symbol"), __scope, false) } getOrElse {Nil},
        __obj.groupu45barline map { scalaxb.toXML[musicxml.Groupu45barline](_, None, Some("group-barline"), __scope, false) } getOrElse {Nil},
        __obj.groupu45time map { scalaxb.toXML[musicxml.Empty](_, None, Some("group-time"), __scope, false) } getOrElse {Nil},
        scalaxb.toXML[musicxml.EditorialSequence](__obj.editorialSequence8, None, Some("editorialSequence8"), __scope, false))

  }

  trait DefaultMusicxml_Partu45listFormat extends scalaxb.ElemNameParser[musicxml.Partu45list] with Musicxml_Partu45groupGroupFormat with Musicxml_Scoreu45partGroupFormat {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("part-list")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[musicxml.Partu45list] =
      phrase(safeRep(parsePartu45groupGroup(node, scalaxb.ElemName(node) :: stack)) ~ 
      (parseScoreu45partGroup(node, scalaxb.ElemName(node) :: stack)) ~ 
      safeRep((parsePartu45groupGroup(node, scalaxb.ElemName(node) :: stack, true)) ||| 
      (parseScoreu45partGroup(node, scalaxb.ElemName(node) :: stack, true))) ^^
      { case p1 ~ p2 ~ p3 =>
      musicxml.Partu45list(p1,
        p2,
        p3) })
    
    def writesChildNodes(__obj: musicxml.Partu45list, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.partu45groupSequence1 flatMap { scalaxb.toXML[musicxml.Partu45groupSequence](_, None, Some("partu45groupSequence1"), __scope, false) },
        scalaxb.toXML[musicxml.Scoreu45partSequence](__obj.scoreu45partSequence2, None, Some("scoreu45partSequence2"), __scope, false),
        __obj.partu45listoption flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) })

  }

  trait DefaultMusicxml_Partu45nameFormat extends scalaxb.XMLFormat[musicxml.Partu45name] with scalaxb.CanWriteChildNodes[musicxml.Partu45name] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Partu45name] = seq match {
      case node: scala.xml.Node => Right(musicxml.Partu45name(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@default-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-x" -> _ },
        (node \ "@default-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@default-y" -> _ },
        (node \ "@relative-x").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-x" -> _ },
        (node \ "@relative-y").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@relative-y" -> _ },
        (node \ "@font-family").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-family" -> _ },
        (node \ "@font-style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45style](x, scalaxb.ElemName(node) :: stack)) } map { "@font-style" -> _ },
        (node \ "@font-size").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@font-size" -> _ },
        (node \ "@font-weight").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Fontu45weight](x, scalaxb.ElemName(node) :: stack)) } map { "@font-weight" -> _ },
        (node \ "@color").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@color" -> _ },
        (node \ "@print-object").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Yesu45no](x, scalaxb.ElemName(node) :: stack)) } map { "@print-object" -> _ },
        (node \ "@justify").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Leftu45centeru45right](x, scalaxb.ElemName(node) :: stack)) } map { "@justify" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Partu45name, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@default-x", _) => __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.bigDecimal.toPlainString, attr) }
        case ("@default-y", _) => __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.bigDecimal.toPlainString, attr) }
        case ("@relative-x", _) => __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.bigDecimal.toPlainString, attr) }
        case ("@relative-y", _) => __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.bigDecimal.toPlainString, attr) }
        case ("@font-family", _) => __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
        case ("@font-style", _) => __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
        case ("@font-size", _) => __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
        case ("@font-weight", _) => __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
        case ("@color", _) => __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
        case ("@print-object", _) => __obj.printu45object foreach { x => attr = scala.xml.Attribute(null, "print-object", x.toString, attr) }
        case ("@justify", _) => __obj.justify foreach { x => attr = scala.xml.Attribute(null, "justify", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Partu45name, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))

  }

  trait DefaultMusicxml_Scoreu45instrumentFormat extends scalaxb.ElemNameParser[musicxml.Scoreu45instrument] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("score-instrument")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[musicxml.Scoreu45instrument] =
      phrase((scalaxb.ElemName(None, "instrument-name")) ~ 
      opt(scalaxb.ElemName(None, "instrument-abbreviation")) ~ 
      opt(scalaxb.ElemName(None, "instrument-sound")) ~ 
      opt(((scalaxb.ElemName(None, "solo")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Empty](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "ensemble")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack))))) ~ 
      opt(scalaxb.ElemName(None, "virtual-instrument")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 =>
      musicxml.Scoreu45instrument(scalaxb.fromXML[String](p1, scalaxb.ElemName(node) :: stack),
        p2.headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        p3.headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        p4,
        p5.headOption map { scalaxb.fromXML[musicxml.Virtualu45instrument](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: musicxml.Scoreu45instrument, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => attr = scala.xml.Attribute(null, "id", __obj.id.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Scoreu45instrument, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(scalaxb.toXML[String](__obj.instrumentu45name, None, Some("instrument-name"), __scope, false),
        __obj.instrumentu45abbreviation map { scalaxb.toXML[String](_, None, Some("instrument-abbreviation"), __scope, false) } getOrElse {Nil},
        __obj.instrumentu45sound map { scalaxb.toXML[String](_, None, Some("instrument-sound"), __scope, false) } getOrElse {Nil},
        __obj.scoreu45instrumentoption map { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) } getOrElse {Nil},
        __obj.virtualu45instrument map { scalaxb.toXML[musicxml.Virtualu45instrument](_, None, Some("virtual-instrument"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultMusicxml_Scoreu45partFormat extends scalaxb.ElemNameParser[musicxml.Scoreu45part] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("score-part")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[musicxml.Scoreu45part] =
      phrase(opt(scalaxb.ElemName(None, "identification")) ~ 
      (scalaxb.ElemName(None, "part-name")) ~ 
      opt(scalaxb.ElemName(None, "part-name-display")) ~ 
      opt(scalaxb.ElemName(None, "part-abbreviation")) ~ 
      opt(scalaxb.ElemName(None, "part-abbreviation-display")) ~ 
      safeRep(scalaxb.ElemName(None, "group")) ~ 
      safeRep(scalaxb.ElemName(None, "score-instrument")) ~ 
      safeRep((opt(scalaxb.ElemName(None, "midi-device")) ~ 
      opt(scalaxb.ElemName(None, "midi-instrument"))) ^^ 
        { case p1 ~ p2 => musicxml.Scoreu45partSequence1(p1.headOption map { scalaxb.fromXML[musicxml.Midiu45device](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[musicxml.Midiu45instrument](_, scalaxb.ElemName(node) :: stack) }) }) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 =>
      musicxml.Scoreu45part(p1.headOption map { scalaxb.fromXML[musicxml.Identification](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[musicxml.Partu45name](p2, scalaxb.ElemName(node) :: stack),
        p3.headOption map { scalaxb.fromXML[musicxml.Nameu45display](_, scalaxb.ElemName(node) :: stack) },
        p4.headOption map { scalaxb.fromXML[musicxml.Partu45name](_, scalaxb.ElemName(node) :: stack) },
        p5.headOption map { scalaxb.fromXML[musicxml.Nameu45display](_, scalaxb.ElemName(node) :: stack) },
        p6 map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        p7 map { scalaxb.fromXML[musicxml.Scoreu45instrument](_, scalaxb.ElemName(node) :: stack) },
        p8,
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: musicxml.Scoreu45part, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => attr = scala.xml.Attribute(null, "id", __obj.id.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Scoreu45part, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.identification map { scalaxb.toXML[musicxml.Identification](_, None, Some("identification"), __scope, false) } getOrElse {Nil},
        scalaxb.toXML[musicxml.Partu45name](__obj.partu45name, None, Some("part-name"), __scope, false),
        __obj.partu45nameu45display map { scalaxb.toXML[musicxml.Nameu45display](_, None, Some("part-name-display"), __scope, false) } getOrElse {Nil},
        __obj.partu45abbreviation map { scalaxb.toXML[musicxml.Partu45name](_, None, Some("part-abbreviation"), __scope, false) } getOrElse {Nil},
        __obj.partu45abbreviationu45display map { scalaxb.toXML[musicxml.Nameu45display](_, None, Some("part-abbreviation-display"), __scope, false) } getOrElse {Nil},
        __obj.group flatMap { scalaxb.toXML[String](_, None, Some("group"), __scope, false) },
        __obj.scoreu45instrument flatMap { scalaxb.toXML[musicxml.Scoreu45instrument](_, None, Some("score-instrument"), __scope, false) },
        __obj.scoreu45partsequence1 flatMap { scalaxb.toXML[musicxml.Scoreu45partSequence1](_, None, Some("scoreu45partsequence1"), __scope, false) })

  }

  trait DefaultMusicxml_Scoreu45partSequence1Format extends scalaxb.XMLFormat[musicxml.Scoreu45partSequence1] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Scoreu45partSequence1] = Left("don't call me.")
    
    def writes(__obj: musicxml.Scoreu45partSequence1, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(__obj.midiu45device map { scalaxb.toXML[musicxml.Midiu45device](_, None, Some("midi-device"), __scope, false) } getOrElse {Nil},
        __obj.midiu45instrument map { scalaxb.toXML[musicxml.Midiu45instrument](_, None, Some("midi-instrument"), __scope, false) } getOrElse {Nil})


  }

  trait DefaultMusicxml_Virtualu45instrumentFormat extends scalaxb.ElemNameParser[musicxml.Virtualu45instrument] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("virtual-instrument")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[musicxml.Virtualu45instrument] =
      phrase(opt(scalaxb.ElemName(None, "virtual-library")) ~ 
      opt(scalaxb.ElemName(None, "virtual-name")) ^^
      { case p1 ~ p2 =>
      musicxml.Virtualu45instrument(p1.headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: musicxml.Virtualu45instrument, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.virtualu45library map { scalaxb.toXML[String](_, None, Some("virtual-library"), __scope, false) } getOrElse {Nil},
        __obj.virtualu45name map { scalaxb.toXML[String](_, None, Some("virtual-name"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultMusicxml_WorkFormat extends scalaxb.ElemNameParser[musicxml.Work] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("work")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[musicxml.Work] =
      phrase(opt(scalaxb.ElemName(None, "work-number")) ~ 
      opt(scalaxb.ElemName(None, "work-title")) ~ 
      opt(scalaxb.ElemName(None, "opus")) ^^
      { case p1 ~ p2 ~ p3 =>
      musicxml.Work(p1.headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        p3.headOption map { scalaxb.fromXML[musicxml.Opus](_, scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: musicxml.Work, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.worku45number map { scalaxb.toXML[String](_, None, Some("work-number"), __scope, false) } getOrElse {Nil},
        __obj.worku45title map { scalaxb.toXML[String](_, None, Some("work-title"), __scope, false) } getOrElse {Nil},
        __obj.opus map { scalaxb.toXML[musicxml.Opus](_, None, Some("opus"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultMusicxml_MeasureFormat extends scalaxb.ElemNameParser[musicxml.Measure] with Musicxml_Musicu45dataGroupFormat {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[musicxml.Measure] =
      phrase(safeRep(parseMusicu45dataGroup(node, scalaxb.ElemName(node) :: stack)) ^^
      { case p1 =>
      musicxml.Measure(p1,
        scala.collection.immutable.ListMap(List(
        (node \ "@number").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@number" -> _ },
        (node \ "@text").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@text" -> _ },
        (node \ "@implicit").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Yesu45no](x, scalaxb.ElemName(node) :: stack)) } map { "@implicit" -> _ },
        (node \ "@non-controlling").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Yesu45no](x, scalaxb.ElemName(node) :: stack)) } map { "@non-controlling" -> _ },
        (node \ "@width").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@width" -> _ },
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: musicxml.Measure, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@number", _) => attr = scala.xml.Attribute(null, "number", __obj.number.toString, attr)
        case ("@text", _) => __obj.text foreach { x => attr = scala.xml.Attribute(null, "text", x.toString, attr) }
        case ("@implicit", _) => __obj.implicitValue foreach { x => attr = scala.xml.Attribute(null, "implicit", x.toString, attr) }
        case ("@non-controlling", _) => __obj.nonu45controlling foreach { x => attr = scala.xml.Attribute(null, "non-controlling", x.toString, attr) }
        case ("@width", _) => __obj.width foreach { x => attr = scala.xml.Attribute(null, "width", x.bigDecimal.toPlainString, attr) }
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Measure, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.musicu45dataOption11 flatMap { x => scalaxb.toXML[scalaxb.DataRecord[musicxml.Musicu45dataOption1]](x, x.namespace, x.key, __scope, false) })
  }

  trait DefaultMusicxml_PartFormat extends scalaxb.ElemNameParser[musicxml.Part] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[musicxml.Part] =
      phrase(safeRep(scalaxb.ElemName(None, "measure")) ^^
      { case p1 =>
      musicxml.Part(p1 map { scalaxb.fromXML[musicxml.Measure](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: musicxml.Part, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => attr = scala.xml.Attribute(null, "id", __obj.id.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Part, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.measure flatMap { scalaxb.toXML[musicxml.Measure](_, None, Some("measure"), __scope, false) })
  }

  trait DefaultMusicxml_Scoreu45partwiseFormat extends scalaxb.ElemNameParser[musicxml.Scoreu45partwise] with Musicxml_Scoreu45headerGroupFormat {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[musicxml.Scoreu45partwise] =
      phrase((parseScoreu45headerGroup(node, scalaxb.ElemName(node) :: stack)) ~ 
      safeRep(scalaxb.ElemName(None, "part")) ^^
      { case p1 ~ p2 =>
      musicxml.Scoreu45partwise(p1,
        p2 map { scalaxb.fromXML[musicxml.Part](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@version").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } orElse Some(scalaxb.DataRecord(None, None, scalaxb.fromXML[String](scala.xml.Text("1.0"), scalaxb.ElemName(node) :: stack))) map { "@version" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: musicxml.Scoreu45partwise, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@version", _) => if (__obj.version.toString != "1.0") attr = scala.xml.Attribute(null, "version", __obj.version.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Scoreu45partwise, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(scalaxb.toXML[musicxml.Scoreu45headerSequence](__obj.scoreu45headerSequence1, None, Some("scoreu45headerSequence1"), __scope, false),
        __obj.part flatMap { scalaxb.toXML[musicxml.Part](_, None, Some("part"), __scope, false) })

  }

  trait DefaultMusicxml_Part2Format extends scalaxb.ElemNameParser[musicxml.Part2] with Musicxml_Musicu45dataGroupFormat {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[musicxml.Part2] =
      phrase(safeRep(parseMusicu45dataGroup(node, scalaxb.ElemName(node) :: stack)) ^^
      { case p1 =>
      musicxml.Part2(p1,
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: musicxml.Part2, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => attr = scala.xml.Attribute(null, "id", __obj.id.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Part2, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.musicu45dataOption11 flatMap { x => scalaxb.toXML[scalaxb.DataRecord[musicxml.Musicu45dataOption1]](x, x.namespace, x.key, __scope, false) })
  }

  trait DefaultMusicxml_Measure2Format extends scalaxb.ElemNameParser[musicxml.Measure2] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[musicxml.Measure2] =
      phrase(safeRep(scalaxb.ElemName(None, "part")) ^^
      { case p1 =>
      musicxml.Measure2(p1 map { scalaxb.fromXML[musicxml.Part2](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@number").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@number" -> _ },
        (node \ "@text").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@text" -> _ },
        (node \ "@implicit").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Yesu45no](x, scalaxb.ElemName(node) :: stack)) } map { "@implicit" -> _ },
        (node \ "@non-controlling").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Yesu45no](x, scalaxb.ElemName(node) :: stack)) } map { "@non-controlling" -> _ },
        (node \ "@width").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) } map { "@width" -> _ },
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: musicxml.Measure2, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@number", _) => attr = scala.xml.Attribute(null, "number", __obj.number.toString, attr)
        case ("@text", _) => __obj.text foreach { x => attr = scala.xml.Attribute(null, "text", x.toString, attr) }
        case ("@implicit", _) => __obj.implicitValue foreach { x => attr = scala.xml.Attribute(null, "implicit", x.toString, attr) }
        case ("@non-controlling", _) => __obj.nonu45controlling foreach { x => attr = scala.xml.Attribute(null, "non-controlling", x.toString, attr) }
        case ("@width", _) => __obj.width foreach { x => attr = scala.xml.Attribute(null, "width", x.bigDecimal.toPlainString, attr) }
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Measure2, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.part flatMap { scalaxb.toXML[musicxml.Part2](_, None, Some("part"), __scope, false) })
  }

  trait DefaultMusicxml_Scoreu45timewiseFormat extends scalaxb.ElemNameParser[musicxml.Scoreu45timewise] with Musicxml_Scoreu45headerGroupFormat {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[musicxml.Scoreu45timewise] =
      phrase((parseScoreu45headerGroup(node, scalaxb.ElemName(node) :: stack)) ~ 
      safeRep(scalaxb.ElemName(None, "measure")) ^^
      { case p1 ~ p2 =>
      musicxml.Scoreu45timewise(p1,
        p2 map { scalaxb.fromXML[musicxml.Measure2](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@version").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } orElse Some(scalaxb.DataRecord(None, None, scalaxb.fromXML[String](scala.xml.Text("1.0"), scalaxb.ElemName(node) :: stack))) map { "@version" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: musicxml.Scoreu45timewise, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@version", _) => if (__obj.version.toString != "1.0") attr = scala.xml.Attribute(null, "version", __obj.version.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Scoreu45timewise, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(scalaxb.toXML[musicxml.Scoreu45headerSequence](__obj.scoreu45headerSequence1, None, Some("scoreu45headerSequence1"), __scope, false),
        __obj.measure flatMap { scalaxb.toXML[musicxml.Measure2](_, None, Some("measure"), __scope, false) })

  }


/** The score-part element is defined within a group due to its multiple uses within the part-list element.
*/
  trait Musicxml_Scoreu45partGroupFormat extends scalaxb.AnyElemNameParser {
    def parseScoreu45partGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[musicxml.Scoreu45partSequence] =
      (((scalaxb.ElemName(None, "score-part"))) ^^ 
        { case p1 => musicxml.Scoreu45partSequence(scalaxb.fromXML[musicxml.Scoreu45part](p1, scalaxb.ElemName(node) :: stack)) })
  
    def parseScoreu45partGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName], wrap: Boolean): Parser[scalaxb.DataRecord[Any]] =
      (((scalaxb.ElemName(None, "score-part"))) ^^ 
        { case p1 => scalaxb.DataRecord(musicxml.Scoreu45partSequence(scalaxb.fromXML[musicxml.Scoreu45part](p1, scalaxb.ElemName(node) :: stack))) })
    
    def parsemixedScoreu45partGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Seq[scalaxb.DataRecord[Any]]] =
      ((((scalaxb.ElemName(None, "score-part")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Scoreu45part](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) })
  }

  trait DefaultMusicxml_Scoreu45partSequenceFormat extends scalaxb.XMLFormat[musicxml.Scoreu45partSequence] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Scoreu45partSequence] = Left("don't call me.")
    
    def writes(__obj: musicxml.Scoreu45partSequence, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scalaxb.toXML[musicxml.Scoreu45part](__obj.scoreu45part, None, Some("score-part"), __scope, false)

  }

/** The part-group element is defined within a group due to its multiple uses within the part-list element.
*/
  trait Musicxml_Partu45groupGroupFormat extends scalaxb.AnyElemNameParser {
    def parsePartu45groupGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[musicxml.Partu45groupSequence] =
      (((scalaxb.ElemName(None, "part-group"))) ^^ 
        { case p1 => musicxml.Partu45groupSequence(scalaxb.fromXML[musicxml.Partu45group](p1, scalaxb.ElemName(node) :: stack)) })
  
    def parsePartu45groupGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName], wrap: Boolean): Parser[scalaxb.DataRecord[Any]] =
      (((scalaxb.ElemName(None, "part-group"))) ^^ 
        { case p1 => scalaxb.DataRecord(musicxml.Partu45groupSequence(scalaxb.fromXML[musicxml.Partu45group](p1, scalaxb.ElemName(node) :: stack))) })
    
    def parsemixedPartu45groupGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Seq[scalaxb.DataRecord[Any]]] =
      ((((scalaxb.ElemName(None, "part-group")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Partu45group](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) })
  }

  trait DefaultMusicxml_Partu45groupSequenceFormat extends scalaxb.XMLFormat[musicxml.Partu45groupSequence] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Partu45groupSequence] = Left("don't call me.")
    
    def writes(__obj: musicxml.Partu45groupSequence, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scalaxb.toXML[musicxml.Partu45group](__obj.partu45group, None, Some("part-group"), __scope, false)

  }

/** The full-note group is a sequence of the common note elements between cue/grace notes and regular (full) notes: pitch, chord, and rest information, but not duration (cue and grace notes do not have duration encoded). Unpitched elements are used for unpitched percussion, speaking voice, and other musical elements lacking determinate pitch.
*/
  trait Musicxml_Fullu45noteGroupFormat extends scalaxb.AnyElemNameParser {
    def parseFullu45noteGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[musicxml.Fullu45noteSequence] =
      ((opt(scalaxb.ElemName(None, "chord")) ~ 
      (((scalaxb.ElemName(None, "pitch")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Pitch](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "unpitched")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Unpitched](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "rest")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Rest](x, scalaxb.ElemName(node) :: stack)))))) ^^ 
        { case p1 ~ p2 => musicxml.Fullu45noteSequence(p1.headOption map { scalaxb.fromXML[musicxml.Empty](_, scalaxb.ElemName(node) :: stack) },
        p2) })
  
    def parseFullu45noteGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName], wrap: Boolean): Parser[scalaxb.DataRecord[Any]] =
      ((opt(scalaxb.ElemName(None, "chord")) ~ 
      (((scalaxb.ElemName(None, "pitch")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Pitch](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "unpitched")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Unpitched](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "rest")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Rest](x, scalaxb.ElemName(node) :: stack)))))) ^^ 
        { case p1 ~ p2 => scalaxb.DataRecord(musicxml.Fullu45noteSequence(p1.headOption map { scalaxb.fromXML[musicxml.Empty](_, scalaxb.ElemName(node) :: stack) },
        p2)) })
    
    def parsemixedFullu45noteGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Seq[scalaxb.DataRecord[Any]]] =
      (((opt(scalaxb.ElemName(None, "chord")) ^^ 
      (_ map { x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Empty](x, scalaxb.ElemName(node) :: stack)) })) ~ 
      optTextRecord ~ 
      (((((scalaxb.ElemName(None, "pitch")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Pitch](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(None, "unpitched")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Unpitched](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(None, "rest")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Rest](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) })) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 ~ p3 ~ p4 => Seq.concat(p1.toList,
        p2.toList,
        p3,
        p4.toList) })
  }

  trait DefaultMusicxml_Fullu45noteSequenceFormat extends scalaxb.XMLFormat[musicxml.Fullu45noteSequence] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Fullu45noteSequence] = Left("don't call me.")
    
    def writes(__obj: musicxml.Fullu45noteSequence, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(__obj.chord map { scalaxb.toXML[musicxml.Empty](_, None, Some("chord"), __scope, false) } getOrElse {Nil},
        (Some(__obj.fullu45noteoption1) map {x => scalaxb.toXML[scalaxb.DataRecord[musicxml.Fullu45noteOption1]](x, x.namespace, x.key, __scope, false)}).get)


  }


/** The duration element is defined within a group due to its uses within the note, figure-bass, backup, and forward elements.
*/
  trait Musicxml_DurationGroupFormat extends scalaxb.AnyElemNameParser {
    def parseDurationGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[musicxml.DurationSequence] =
      (((scalaxb.ElemName(None, "duration"))) ^^ 
        { case p1 => musicxml.DurationSequence(scalaxb.fromXML[BigDecimal](p1, scalaxb.ElemName(node) :: stack)) })
  
    def parseDurationGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName], wrap: Boolean): Parser[scalaxb.DataRecord[Any]] =
      (((scalaxb.ElemName(None, "duration"))) ^^ 
        { case p1 => scalaxb.DataRecord(musicxml.DurationSequence(scalaxb.fromXML[BigDecimal](p1, scalaxb.ElemName(node) :: stack))) })
    
    def parsemixedDurationGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Seq[scalaxb.DataRecord[Any]]] =
      ((((scalaxb.ElemName(None, "duration")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) })
  }

  trait DefaultMusicxml_DurationSequenceFormat extends scalaxb.XMLFormat[musicxml.DurationSequence] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.DurationSequence] = Left("don't call me.")
    
    def writes(__obj: musicxml.DurationSequence, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scalaxb.toXML[BigDecimal](__obj.duration, None, Some("duration"), __scope, false)

  }

/** The layout group specifies the sequence of page, system, and staff layout elements that is common to both the defaults and print elements.
*/
  trait Musicxml_LayoutGroupFormat extends scalaxb.AnyElemNameParser {
    def parseLayoutGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[musicxml.LayoutSequence] =
      ((opt(scalaxb.ElemName(None, "page-layout")) ~ 
      opt(scalaxb.ElemName(None, "system-layout")) ~ 
      safeRep(scalaxb.ElemName(None, "staff-layout"))) ^^ 
        { case p1 ~ p2 ~ p3 => musicxml.LayoutSequence(p1.headOption map { scalaxb.fromXML[musicxml.Pageu45layout](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[musicxml.Systemu45layout](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[musicxml.Staffu45layout](_, scalaxb.ElemName(node) :: stack) }) })
  
    def parseLayoutGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName], wrap: Boolean): Parser[scalaxb.DataRecord[Any]] =
      ((opt(scalaxb.ElemName(None, "page-layout")) ~ 
      opt(scalaxb.ElemName(None, "system-layout")) ~ 
      safeRep(scalaxb.ElemName(None, "staff-layout"))) ^^ 
        { case p1 ~ p2 ~ p3 => scalaxb.DataRecord(musicxml.LayoutSequence(p1.headOption map { scalaxb.fromXML[musicxml.Pageu45layout](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[musicxml.Systemu45layout](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[musicxml.Staffu45layout](_, scalaxb.ElemName(node) :: stack) })) })
    
    def parsemixedLayoutGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Seq[scalaxb.DataRecord[Any]]] =
      (((opt(scalaxb.ElemName(None, "page-layout")) ^^ 
      (_ map { x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Pageu45layout](x, scalaxb.ElemName(node) :: stack)) })) ~ 
      optTextRecord ~ 
      (opt(scalaxb.ElemName(None, "system-layout")) ^^ 
      (_ map { x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Systemu45layout](x, scalaxb.ElemName(node) :: stack)) })) ~ 
      optTextRecord ~ 
      (safeRep(scalaxb.ElemName(None, "staff-layout")) ^^ 
      (_.toSeq map { x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Staffu45layout](x, scalaxb.ElemName(node) :: stack)) })) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 => Seq.concat(p1.toList,
        p2.toList,
        p3.toList,
        p4.toList,
        p5,
        p6.toList) })
  }

  trait DefaultMusicxml_LayoutSequenceFormat extends scalaxb.XMLFormat[musicxml.LayoutSequence] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.LayoutSequence] = Left("don't call me.")
    
    def writes(__obj: musicxml.LayoutSequence, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(__obj.pageu45layout map { scalaxb.toXML[musicxml.Pageu45layout](_, None, Some("page-layout"), __scope, false) } getOrElse {Nil},
        __obj.systemu45layout map { scalaxb.toXML[musicxml.Systemu45layout](_, None, Some("system-layout"), __scope, false) } getOrElse {Nil},
        __obj.staffu45layout flatMap { scalaxb.toXML[musicxml.Staffu45layout](_, None, Some("staff-layout"), __scope, false) })


  }


/** A harmony element can contain many stacked chords (e.g. V of II). A sequence of harmony-chord groups is used for this type of secondary function, where V of II would be represented by a harmony-chord with a V function followed by a harmony-chord with a II function.

A root is a pitch name like C, D, E, where a function is an indication like I, II, III. It is an either/or choice to avoid data inconsistency.
*/
  trait Musicxml_Harmonyu45chordGroupFormat extends scalaxb.AnyElemNameParser {
    def parseHarmonyu45chordGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[musicxml.Harmonyu45chordSequence] =
      (((((scalaxb.ElemName(None, "root")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Root](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "function")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Styleu45text](x, scalaxb.ElemName(node) :: stack))))) ~ 
      (scalaxb.ElemName(None, "kind")) ~ 
      opt(scalaxb.ElemName(None, "inversion")) ~ 
      opt(scalaxb.ElemName(None, "bass")) ~ 
      safeRep(scalaxb.ElemName(None, "degree"))) ^^ 
        { case p1 ~ p2 ~ p3 ~ p4 ~ p5 => musicxml.Harmonyu45chordSequence(p1,
        scalaxb.fromXML[musicxml.Kind](p2, scalaxb.ElemName(node) :: stack),
        p3.headOption map { scalaxb.fromXML[musicxml.Inversion](_, scalaxb.ElemName(node) :: stack) },
        p4.headOption map { scalaxb.fromXML[musicxml.Bass](_, scalaxb.ElemName(node) :: stack) },
        p5 map { scalaxb.fromXML[musicxml.Degree](_, scalaxb.ElemName(node) :: stack) }) })
  
    def parseHarmonyu45chordGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName], wrap: Boolean): Parser[scalaxb.DataRecord[Any]] =
      (((((scalaxb.ElemName(None, "root")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Root](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "function")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Styleu45text](x, scalaxb.ElemName(node) :: stack))))) ~ 
      (scalaxb.ElemName(None, "kind")) ~ 
      opt(scalaxb.ElemName(None, "inversion")) ~ 
      opt(scalaxb.ElemName(None, "bass")) ~ 
      safeRep(scalaxb.ElemName(None, "degree"))) ^^ 
        { case p1 ~ p2 ~ p3 ~ p4 ~ p5 => scalaxb.DataRecord(musicxml.Harmonyu45chordSequence(p1,
        scalaxb.fromXML[musicxml.Kind](p2, scalaxb.ElemName(node) :: stack),
        p3.headOption map { scalaxb.fromXML[musicxml.Inversion](_, scalaxb.ElemName(node) :: stack) },
        p4.headOption map { scalaxb.fromXML[musicxml.Bass](_, scalaxb.ElemName(node) :: stack) },
        p5 map { scalaxb.fromXML[musicxml.Degree](_, scalaxb.ElemName(node) :: stack) })) })
    
    def parsemixedHarmonyu45chordGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Seq[scalaxb.DataRecord[Any]]] =
      (((((((scalaxb.ElemName(None, "root")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Root](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(None, "function")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Styleu45text](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) })) ~ 
      optTextRecord ~ 
      ((scalaxb.ElemName(None, "kind")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Kind](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord ~ 
      (opt(scalaxb.ElemName(None, "inversion")) ^^ 
      (_ map { x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Inversion](x, scalaxb.ElemName(node) :: stack)) })) ~ 
      optTextRecord ~ 
      (opt(scalaxb.ElemName(None, "bass")) ^^ 
      (_ map { x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Bass](x, scalaxb.ElemName(node) :: stack)) })) ~ 
      optTextRecord ~ 
      (safeRep(scalaxb.ElemName(None, "degree")) ^^ 
      (_.toSeq map { x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Degree](x, scalaxb.ElemName(node) :: stack)) })) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 ~ p9 ~ p10 => Seq.concat(p1,
        p2.toList,
        Seq(p3),
        p4.toList,
        p5.toList,
        p6.toList,
        p7.toList,
        p8.toList,
        p9,
        p10.toList) })
  }

  trait DefaultMusicxml_Harmonyu45chordSequenceFormat extends scalaxb.XMLFormat[musicxml.Harmonyu45chordSequence] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Harmonyu45chordSequence] = Left("don't call me.")
    
    def writes(__obj: musicxml.Harmonyu45chordSequence, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat((Some(__obj.harmonyu45chordoption1) map {x => scalaxb.toXML[scalaxb.DataRecord[musicxml.Harmonyu45chordOption1]](x, x.namespace, x.key, __scope, false)}).get,
        scalaxb.toXML[musicxml.Kind](__obj.kind, None, Some("kind"), __scope, false),
        __obj.inversion map { scalaxb.toXML[musicxml.Inversion](_, None, Some("inversion"), __scope, false) } getOrElse {Nil},
        __obj.bass map { scalaxb.toXML[musicxml.Bass](_, None, Some("bass"), __scope, false) } getOrElse {Nil},
        __obj.degree flatMap { scalaxb.toXML[musicxml.Degree](_, None, Some("degree"), __scope, false) })


  }


/** The traditional-key group represents a traditional key signature using the cycle of fifths.
*/
  trait Musicxml_Traditionalu45keyGroupFormat extends scalaxb.AnyElemNameParser {
    def parseTraditionalu45keyGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[musicxml.Traditionalu45keySequence] =
      ((opt(scalaxb.ElemName(None, "cancel")) ~ 
      (scalaxb.ElemName(None, "fifths")) ~ 
      opt(scalaxb.ElemName(None, "mode"))) ^^ 
        { case p1 ~ p2 ~ p3 => musicxml.Traditionalu45keySequence(p1.headOption map { scalaxb.fromXML[musicxml.Cancel](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[BigInt](p2, scalaxb.ElemName(node) :: stack),
        p3.headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }) })
  
    def parseTraditionalu45keyGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName], wrap: Boolean): Parser[scalaxb.DataRecord[Any]] =
      ((opt(scalaxb.ElemName(None, "cancel")) ~ 
      (scalaxb.ElemName(None, "fifths")) ~ 
      opt(scalaxb.ElemName(None, "mode"))) ^^ 
        { case p1 ~ p2 ~ p3 => scalaxb.DataRecord(musicxml.Traditionalu45keySequence(p1.headOption map { scalaxb.fromXML[musicxml.Cancel](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[BigInt](p2, scalaxb.ElemName(node) :: stack),
        p3.headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) })) })
    
    def parsemixedTraditionalu45keyGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Seq[scalaxb.DataRecord[Any]]] =
      (((opt(scalaxb.ElemName(None, "cancel")) ^^ 
      (_ map { x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Cancel](x, scalaxb.ElemName(node) :: stack)) })) ~ 
      optTextRecord ~ 
      ((scalaxb.ElemName(None, "fifths")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[BigInt](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord ~ 
      (opt(scalaxb.ElemName(None, "mode")) ^^ 
      (_ map { x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) })) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 => Seq.concat(p1.toList,
        p2.toList,
        Seq(p3),
        p4.toList,
        p5.toList,
        p6.toList) })
  }

  trait DefaultMusicxml_Traditionalu45keySequenceFormat extends scalaxb.XMLFormat[musicxml.Traditionalu45keySequence] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Traditionalu45keySequence] = Left("don't call me.")
    
    def writes(__obj: musicxml.Traditionalu45keySequence, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(__obj.cancel map { scalaxb.toXML[musicxml.Cancel](_, None, Some("cancel"), __scope, false) } getOrElse {Nil},
        scalaxb.toXML[BigInt](__obj.fifths, None, Some("fifths"), __scope, false),
        __obj.mode map { scalaxb.toXML[String](_, None, Some("mode"), __scope, false) } getOrElse {Nil})


  }


/** The slash group combines elements used for more complete specification of the slash and beat-repeat measure-style elements. They have the same values as the type and dot elements, and define what the beat is for the display of repetition marks. If not present, the beat is based on the current time signature.
*/
  trait Musicxml_SlashGroupFormat extends scalaxb.AnyElemNameParser {
    def parseSlashGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[musicxml.SlashSequence] =
      ((opt(((scalaxb.ElemName(None, "slash-type")) ~ 
      safeRep(scalaxb.ElemName(None, "slash-dot"))) ^^ 
        { case p1 ~ p2 => musicxml.SlashSequence2(scalaxb.fromXML[musicxml.Noteu45typeu45value](p1, scalaxb.ElemName(node) :: stack),
        p2 map { scalaxb.fromXML[musicxml.Empty](_, scalaxb.ElemName(node) :: stack) }) }) ~ 
      safeRep(scalaxb.ElemName(None, "except-voice"))) ^^ 
        { case p1 ~ p2 => musicxml.SlashSequence(p1,
        p2 map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }) })
  
    def parseSlashGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName], wrap: Boolean): Parser[scalaxb.DataRecord[Any]] =
      ((opt(((scalaxb.ElemName(None, "slash-type")) ~ 
      safeRep(scalaxb.ElemName(None, "slash-dot"))) ^^ 
        { case p1 ~ p2 => musicxml.SlashSequence2(scalaxb.fromXML[musicxml.Noteu45typeu45value](p1, scalaxb.ElemName(node) :: stack),
        p2 map { scalaxb.fromXML[musicxml.Empty](_, scalaxb.ElemName(node) :: stack) }) }) ~ 
      safeRep(scalaxb.ElemName(None, "except-voice"))) ^^ 
        { case p1 ~ p2 => scalaxb.DataRecord(musicxml.SlashSequence(p1,
        p2 map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) })) })
    
    def parsemixedSlashGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Seq[scalaxb.DataRecord[Any]]] =
      ((opt((((scalaxb.ElemName(None, "slash-type")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord ~ 
      (safeRep(scalaxb.ElemName(None, "slash-dot")) ^^ 
      (_.toSeq map { x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Empty](x, scalaxb.ElemName(node) :: stack)) })) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 ~ p3 ~ p4 => Seq.concat(Seq(p1),
        p2.toList,
        p3,
        p4.toList) }) ~ 
      optTextRecord ~ 
      (safeRep(scalaxb.ElemName(None, "except-voice")) ^^ 
      (_.toSeq map { x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) })) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 ~ p3 ~ p4 => Seq.concat(p1 getOrElse {Nil},
        p2.toList,
        p3,
        p4.toList) })
  }

  trait DefaultMusicxml_SlashSequenceFormat extends scalaxb.XMLFormat[musicxml.SlashSequence] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.SlashSequence] = Left("don't call me.")
    
    def writes(__obj: musicxml.SlashSequence, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(__obj.slashsequence2 map { scalaxb.toXML[musicxml.SlashSequence2](_, None, Some("slashsequence2"), __scope, false) } getOrElse {Nil},
        __obj.exceptu45voice flatMap { scalaxb.toXML[String](_, None, Some("except-voice"), __scope, false) })


  }

  trait DefaultMusicxml_SlashSequence2Format extends scalaxb.XMLFormat[musicxml.SlashSequence2] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.SlashSequence2] = Left("don't call me.")
    
    def writes(__obj: musicxml.SlashSequence2, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(scalaxb.toXML[musicxml.Noteu45typeu45value](__obj.slashu45type, None, Some("slash-type"), __scope, false),
        __obj.slashu45dot flatMap { scalaxb.toXML[musicxml.Empty](_, None, Some("slash-dot"), __scope, false) })


  }


/** The voice is used to distinguish between multiple voices (what MuseData calls tracks) in individual parts. It is defined within a group due to its multiple uses within the MusicXML schema.
*/
  trait Musicxml_VoiceGroupFormat extends scalaxb.AnyElemNameParser {
    def parseVoiceGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[musicxml.VoiceSequence] =
      (((scalaxb.ElemName(None, "voice"))) ^^ 
        { case p1 => musicxml.VoiceSequence(scalaxb.fromXML[String](p1, scalaxb.ElemName(node) :: stack)) })
  
    def parseVoiceGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName], wrap: Boolean): Parser[scalaxb.DataRecord[Any]] =
      (((scalaxb.ElemName(None, "voice"))) ^^ 
        { case p1 => scalaxb.DataRecord(musicxml.VoiceSequence(scalaxb.fromXML[String](p1, scalaxb.ElemName(node) :: stack))) })
    
    def parsemixedVoiceGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Seq[scalaxb.DataRecord[Any]]] =
      ((((scalaxb.ElemName(None, "voice")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) })
  }

  trait DefaultMusicxml_VoiceSequenceFormat extends scalaxb.XMLFormat[musicxml.VoiceSequence] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.VoiceSequence] = Left("don't call me.")
    
    def writes(__obj: musicxml.VoiceSequence, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scalaxb.toXML[String](__obj.voice, None, Some("voice"), __scope, false)

  }

/** The staff element is defined within a group due to its use by both notes and direction elements.
*/
  trait Musicxml_StaffGroupFormat extends scalaxb.AnyElemNameParser {
    def parseStaffGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[musicxml.StaffSequence] =
      (((scalaxb.ElemName(None, "staff"))) ^^ 
        { case p1 => musicxml.StaffSequence(scalaxb.fromXML[BigInt](p1, scalaxb.ElemName(node) :: stack)) })
  
    def parseStaffGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName], wrap: Boolean): Parser[scalaxb.DataRecord[Any]] =
      (((scalaxb.ElemName(None, "staff"))) ^^ 
        { case p1 => scalaxb.DataRecord(musicxml.StaffSequence(scalaxb.fromXML[BigInt](p1, scalaxb.ElemName(node) :: stack))) })
    
    def parsemixedStaffGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Seq[scalaxb.DataRecord[Any]]] =
      ((((scalaxb.ElemName(None, "staff")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[BigInt](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) })
  }

  trait DefaultMusicxml_StaffSequenceFormat extends scalaxb.XMLFormat[musicxml.StaffSequence] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.StaffSequence] = Left("don't call me.")
    
    def writes(__obj: musicxml.StaffSequence, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scalaxb.toXML[BigInt](__obj.staff, None, Some("staff"), __scope, false)

  }

/** The footnote element specifies editorial information that appears in footnotes in the printed score. It is defined within a group due to its multiple uses within the MusicXML schema.
*/
  trait Musicxml_FootnoteGroupFormat extends scalaxb.AnyElemNameParser {
    def parseFootnoteGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[musicxml.FootnoteSequence] =
      (((scalaxb.ElemName(None, "footnote"))) ^^ 
        { case p1 => musicxml.FootnoteSequence(scalaxb.fromXML[musicxml.Formattedu45text](p1, scalaxb.ElemName(node) :: stack)) })
  
    def parseFootnoteGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName], wrap: Boolean): Parser[scalaxb.DataRecord[Any]] =
      (((scalaxb.ElemName(None, "footnote"))) ^^ 
        { case p1 => scalaxb.DataRecord(musicxml.FootnoteSequence(scalaxb.fromXML[musicxml.Formattedu45text](p1, scalaxb.ElemName(node) :: stack))) })
    
    def parsemixedFootnoteGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Seq[scalaxb.DataRecord[Any]]] =
      ((((scalaxb.ElemName(None, "footnote")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Formattedu45text](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) })
  }

  trait DefaultMusicxml_FootnoteSequenceFormat extends scalaxb.XMLFormat[musicxml.FootnoteSequence] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.FootnoteSequence] = Left("don't call me.")
    
    def writes(__obj: musicxml.FootnoteSequence, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scalaxb.toXML[musicxml.Formattedu45text](__obj.footnote, None, Some("footnote"), __scope, false)

  }

/** The editorial-voice group supports the common combination of editorial and voice information for a musical element.
*/
  trait Musicxml_Editorialu45voiceGroupFormat extends Musicxml_FootnoteGroupFormat with Musicxml_LevelGroupFormat with Musicxml_VoiceGroupFormat {
    def parseEditorialu45voiceGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[musicxml.Editorialu45voiceSequence] =
      ((opt(parseFootnoteGroup(node, scalaxb.ElemName(node) :: stack)) ~ 
      opt(parseLevelGroup(node, scalaxb.ElemName(node) :: stack)) ~ 
      opt(parseVoiceGroup(node, scalaxb.ElemName(node) :: stack))) ^^ 
        { case p1 ~ p2 ~ p3 => musicxml.Editorialu45voiceSequence(p1,
        p2,
        p3) })
  
    def parseEditorialu45voiceGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName], wrap: Boolean): Parser[scalaxb.DataRecord[Any]] =
      ((opt(parseFootnoteGroup(node, scalaxb.ElemName(node) :: stack)) ~ 
      opt(parseLevelGroup(node, scalaxb.ElemName(node) :: stack)) ~ 
      opt(parseVoiceGroup(node, scalaxb.ElemName(node) :: stack))) ^^ 
        { case p1 ~ p2 ~ p3 => scalaxb.DataRecord(musicxml.Editorialu45voiceSequence(p1,
        p2,
        p3)) })
    
    def parsemixedEditorialu45voiceGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Seq[scalaxb.DataRecord[Any]]] =
      ((opt(parsemixedFootnoteGroup(node, scalaxb.ElemName(node) :: stack)) ~ 
      optTextRecord ~ 
      opt(parsemixedLevelGroup(node, scalaxb.ElemName(node) :: stack)) ~ 
      optTextRecord ~ 
      opt(parsemixedVoiceGroup(node, scalaxb.ElemName(node) :: stack)) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 => Seq.concat(p1 getOrElse {Nil},
        p2.toList,
        p3 getOrElse {Nil},
        p4.toList,
        p5 getOrElse {Nil},
        p6.toList) })
  }

  trait DefaultMusicxml_Editorialu45voiceSequenceFormat extends scalaxb.XMLFormat[musicxml.Editorialu45voiceSequence] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Editorialu45voiceSequence] = Left("don't call me.")
    
    def writes(__obj: musicxml.Editorialu45voiceSequence, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(__obj.footnoteSequence1 map { scalaxb.toXML[musicxml.FootnoteSequence](_, None, Some("footnoteSequence1"), __scope, false) } getOrElse {Nil},
        __obj.levelSequence2 map { scalaxb.toXML[musicxml.LevelSequence](_, None, Some("levelSequence2"), __scope, false) } getOrElse {Nil},
        __obj.voiceSequence3 map { scalaxb.toXML[musicxml.VoiceSequence](_, None, Some("voiceSequence3"), __scope, false) } getOrElse {Nil})


  }


/** The editorial group specifies editorial information for a musical element.
*/
  trait Musicxml_EditorialGroupFormat extends Musicxml_FootnoteGroupFormat with Musicxml_LevelGroupFormat {
    def parseEditorialGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[musicxml.EditorialSequence] =
      ((opt(parseFootnoteGroup(node, scalaxb.ElemName(node) :: stack)) ~ 
      opt(parseLevelGroup(node, scalaxb.ElemName(node) :: stack))) ^^ 
        { case p1 ~ p2 => musicxml.EditorialSequence(p1,
        p2) })
  
    def parseEditorialGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName], wrap: Boolean): Parser[scalaxb.DataRecord[Any]] =
      ((opt(parseFootnoteGroup(node, scalaxb.ElemName(node) :: stack)) ~ 
      opt(parseLevelGroup(node, scalaxb.ElemName(node) :: stack))) ^^ 
        { case p1 ~ p2 => scalaxb.DataRecord(musicxml.EditorialSequence(p1,
        p2)) })
    
    def parsemixedEditorialGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Seq[scalaxb.DataRecord[Any]]] =
      ((opt(parsemixedFootnoteGroup(node, scalaxb.ElemName(node) :: stack)) ~ 
      optTextRecord ~ 
      opt(parsemixedLevelGroup(node, scalaxb.ElemName(node) :: stack)) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 ~ p3 ~ p4 => Seq.concat(p1 getOrElse {Nil},
        p2.toList,
        p3 getOrElse {Nil},
        p4.toList) })
  }

  trait DefaultMusicxml_EditorialSequenceFormat extends scalaxb.XMLFormat[musicxml.EditorialSequence] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.EditorialSequence] = Left("don't call me.")
    
    def writes(__obj: musicxml.EditorialSequence, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(__obj.footnoteSequence1 map { scalaxb.toXML[musicxml.FootnoteSequence](_, None, Some("footnoteSequence1"), __scope, false) } getOrElse {Nil},
        __obj.levelSequence2 map { scalaxb.toXML[musicxml.LevelSequence](_, None, Some("levelSequence2"), __scope, false) } getOrElse {Nil})


  }


/** The editorial-voice-direction group supports the common combination of editorial and voice information for a direction element. It is separate from the editorial-voice element because extensions and restrictions might be different for directions than for the note and forward elements.
*/
  trait Musicxml_Editorialu45voiceu45directionGroupFormat extends Musicxml_FootnoteGroupFormat with Musicxml_LevelGroupFormat with Musicxml_VoiceGroupFormat {
    def parseEditorialu45voiceu45directionGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[musicxml.Editorialu45voiceu45directionSequence] =
      ((opt(parseFootnoteGroup(node, scalaxb.ElemName(node) :: stack)) ~ 
      opt(parseLevelGroup(node, scalaxb.ElemName(node) :: stack)) ~ 
      opt(parseVoiceGroup(node, scalaxb.ElemName(node) :: stack))) ^^ 
        { case p1 ~ p2 ~ p3 => musicxml.Editorialu45voiceu45directionSequence(p1,
        p2,
        p3) })
  
    def parseEditorialu45voiceu45directionGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName], wrap: Boolean): Parser[scalaxb.DataRecord[Any]] =
      ((opt(parseFootnoteGroup(node, scalaxb.ElemName(node) :: stack)) ~ 
      opt(parseLevelGroup(node, scalaxb.ElemName(node) :: stack)) ~ 
      opt(parseVoiceGroup(node, scalaxb.ElemName(node) :: stack))) ^^ 
        { case p1 ~ p2 ~ p3 => scalaxb.DataRecord(musicxml.Editorialu45voiceu45directionSequence(p1,
        p2,
        p3)) })
    
    def parsemixedEditorialu45voiceu45directionGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Seq[scalaxb.DataRecord[Any]]] =
      ((opt(parsemixedFootnoteGroup(node, scalaxb.ElemName(node) :: stack)) ~ 
      optTextRecord ~ 
      opt(parsemixedLevelGroup(node, scalaxb.ElemName(node) :: stack)) ~ 
      optTextRecord ~ 
      opt(parsemixedVoiceGroup(node, scalaxb.ElemName(node) :: stack)) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 => Seq.concat(p1 getOrElse {Nil},
        p2.toList,
        p3 getOrElse {Nil},
        p4.toList,
        p5 getOrElse {Nil},
        p6.toList) })
  }

  trait DefaultMusicxml_Editorialu45voiceu45directionSequenceFormat extends scalaxb.XMLFormat[musicxml.Editorialu45voiceu45directionSequence] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Editorialu45voiceu45directionSequence] = Left("don't call me.")
    
    def writes(__obj: musicxml.Editorialu45voiceu45directionSequence, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(__obj.footnoteSequence1 map { scalaxb.toXML[musicxml.FootnoteSequence](_, None, Some("footnoteSequence1"), __scope, false) } getOrElse {Nil},
        __obj.levelSequence2 map { scalaxb.toXML[musicxml.LevelSequence](_, None, Some("levelSequence2"), __scope, false) } getOrElse {Nil},
        __obj.voiceSequence3 map { scalaxb.toXML[musicxml.VoiceSequence](_, None, Some("voiceSequence3"), __scope, false) } getOrElse {Nil})


  }


/** The level element specifies editorial information for different MusicXML elements. It is defined within a group due to its multiple uses within the MusicXML schema.
*/
  trait Musicxml_LevelGroupFormat extends scalaxb.AnyElemNameParser {
    def parseLevelGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[musicxml.LevelSequence] =
      (((scalaxb.ElemName(None, "level"))) ^^ 
        { case p1 => musicxml.LevelSequence(scalaxb.fromXML[musicxml.Level](p1, scalaxb.ElemName(node) :: stack)) })
  
    def parseLevelGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName], wrap: Boolean): Parser[scalaxb.DataRecord[Any]] =
      (((scalaxb.ElemName(None, "level"))) ^^ 
        { case p1 => scalaxb.DataRecord(musicxml.LevelSequence(scalaxb.fromXML[musicxml.Level](p1, scalaxb.ElemName(node) :: stack))) })
    
    def parsemixedLevelGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Seq[scalaxb.DataRecord[Any]]] =
      ((((scalaxb.ElemName(None, "level")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Level](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) })
  }

  trait DefaultMusicxml_LevelSequenceFormat extends scalaxb.XMLFormat[musicxml.LevelSequence] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.LevelSequence] = Left("don't call me.")
    
    def writes(__obj: musicxml.LevelSequence, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scalaxb.toXML[musicxml.Level](__obj.level, None, Some("level"), __scope, false)

  }

/** The tuning group contains the sequence of elements common to the staff-tuning and accord elements.
*/
  trait Musicxml_TuningGroupFormat extends scalaxb.AnyElemNameParser {
    def parseTuningGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[musicxml.TuningSequence] =
      (((scalaxb.ElemName(None, "tuning-step")) ~ 
      opt(scalaxb.ElemName(None, "tuning-alter")) ~ 
      (scalaxb.ElemName(None, "tuning-octave"))) ^^ 
        { case p1 ~ p2 ~ p3 => musicxml.TuningSequence(scalaxb.fromXML[musicxml.Step](p1, scalaxb.ElemName(node) :: stack),
        p2.headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[BigInt](p3, scalaxb.ElemName(node) :: stack)) })
  
    def parseTuningGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName], wrap: Boolean): Parser[scalaxb.DataRecord[Any]] =
      (((scalaxb.ElemName(None, "tuning-step")) ~ 
      opt(scalaxb.ElemName(None, "tuning-alter")) ~ 
      (scalaxb.ElemName(None, "tuning-octave"))) ^^ 
        { case p1 ~ p2 ~ p3 => scalaxb.DataRecord(musicxml.TuningSequence(scalaxb.fromXML[musicxml.Step](p1, scalaxb.ElemName(node) :: stack),
        p2.headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[BigInt](p3, scalaxb.ElemName(node) :: stack))) })
    
    def parsemixedTuningGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Seq[scalaxb.DataRecord[Any]]] =
      ((((scalaxb.ElemName(None, "tuning-step")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord ~ 
      (opt(scalaxb.ElemName(None, "tuning-alter")) ^^ 
      (_ map { x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)) })) ~ 
      optTextRecord ~ 
      ((scalaxb.ElemName(None, "tuning-octave")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[BigInt](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 => Seq.concat(Seq(p1),
        p2.toList,
        p3.toList,
        p4.toList,
        Seq(p5),
        p6.toList) })
  }

  trait DefaultMusicxml_TuningSequenceFormat extends scalaxb.XMLFormat[musicxml.TuningSequence] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.TuningSequence] = Left("don't call me.")
    
    def writes(__obj: musicxml.TuningSequence, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(scalaxb.toXML[musicxml.Step](__obj.tuningu45step, None, Some("tuning-step"), __scope, false),
        __obj.tuningu45alter map { scalaxb.toXML[BigDecimal](_, None, Some("tuning-alter"), __scope, false) } getOrElse {Nil},
        scalaxb.toXML[BigInt](__obj.tuningu45octave, None, Some("tuning-octave"), __scope, false))


  }


/** The non-traditional-key group represents a single alteration within a non-traditional key signature. A sequence of these groups makes up a non-traditional key signature
*/
  trait Musicxml_Nonu45traditionalu45keyGroupFormat extends scalaxb.AnyElemNameParser {
    def parseNonu45traditionalu45keyGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[musicxml.Nonu45traditionalu45keySequence] =
      (((scalaxb.ElemName(None, "key-step")) ~ 
      (scalaxb.ElemName(None, "key-alter")) ~ 
      opt(scalaxb.ElemName(None, "key-accidental"))) ^^ 
        { case p1 ~ p2 ~ p3 => musicxml.Nonu45traditionalu45keySequence(scalaxb.fromXML[musicxml.Step](p1, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[BigDecimal](p2, scalaxb.ElemName(node) :: stack),
        p3.headOption map { scalaxb.fromXML[musicxml.Keyu45accidental](_, scalaxb.ElemName(node) :: stack) }) })
  
    def parseNonu45traditionalu45keyGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName], wrap: Boolean): Parser[scalaxb.DataRecord[Any]] =
      (((scalaxb.ElemName(None, "key-step")) ~ 
      (scalaxb.ElemName(None, "key-alter")) ~ 
      opt(scalaxb.ElemName(None, "key-accidental"))) ^^ 
        { case p1 ~ p2 ~ p3 => scalaxb.DataRecord(musicxml.Nonu45traditionalu45keySequence(scalaxb.fromXML[musicxml.Step](p1, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[BigDecimal](p2, scalaxb.ElemName(node) :: stack),
        p3.headOption map { scalaxb.fromXML[musicxml.Keyu45accidental](_, scalaxb.ElemName(node) :: stack) })) })
    
    def parsemixedNonu45traditionalu45keyGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Seq[scalaxb.DataRecord[Any]]] =
      ((((scalaxb.ElemName(None, "key-step")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord ~ 
      ((scalaxb.ElemName(None, "key-alter")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord ~ 
      (opt(scalaxb.ElemName(None, "key-accidental")) ^^ 
      (_ map { x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Keyu45accidental](x, scalaxb.ElemName(node) :: stack)) })) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 => Seq.concat(Seq(p1),
        p2.toList,
        Seq(p3),
        p4.toList,
        p5.toList,
        p6.toList) })
  }

  trait DefaultMusicxml_Nonu45traditionalu45keySequenceFormat extends scalaxb.XMLFormat[musicxml.Nonu45traditionalu45keySequence] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Nonu45traditionalu45keySequence] = Left("don't call me.")
    
    def writes(__obj: musicxml.Nonu45traditionalu45keySequence, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(scalaxb.toXML[musicxml.Step](__obj.keyu45step, None, Some("key-step"), __scope, false),
        scalaxb.toXML[BigDecimal](__obj.keyu45alter, None, Some("key-alter"), __scope, false),
        __obj.keyu45accidental map { scalaxb.toXML[musicxml.Keyu45accidental](_, None, Some("key-accidental"), __scope, false) } getOrElse {Nil})


  }


/** Time signatures are represented by the beats element for the numerator and the beat-type element for the denominator.
*/
  trait Musicxml_Timeu45signatureGroupFormat extends scalaxb.AnyElemNameParser {
    def parseTimeu45signatureGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[musicxml.Timeu45signatureSequence] =
      (((scalaxb.ElemName(None, "beats")) ~ 
      (scalaxb.ElemName(None, "beat-type"))) ^^ 
        { case p1 ~ p2 => musicxml.Timeu45signatureSequence(scalaxb.fromXML[String](p1, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[String](p2, scalaxb.ElemName(node) :: stack)) })
  
    def parseTimeu45signatureGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName], wrap: Boolean): Parser[scalaxb.DataRecord[Any]] =
      (((scalaxb.ElemName(None, "beats")) ~ 
      (scalaxb.ElemName(None, "beat-type"))) ^^ 
        { case p1 ~ p2 => scalaxb.DataRecord(musicxml.Timeu45signatureSequence(scalaxb.fromXML[String](p1, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[String](p2, scalaxb.ElemName(node) :: stack))) })
    
    def parsemixedTimeu45signatureGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Seq[scalaxb.DataRecord[Any]]] =
      ((((scalaxb.ElemName(None, "beats")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord ~ 
      ((scalaxb.ElemName(None, "beat-type")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 ~ p3 ~ p4 => Seq.concat(Seq(p1),
        p2.toList,
        Seq(p3),
        p4.toList) })
  }

  trait DefaultMusicxml_Timeu45signatureSequenceFormat extends scalaxb.XMLFormat[musicxml.Timeu45signatureSequence] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Timeu45signatureSequence] = Left("don't call me.")
    
    def writes(__obj: musicxml.Timeu45signatureSequence, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(scalaxb.toXML[String](__obj.beats, None, Some("beats"), __scope, false),
        scalaxb.toXML[String](__obj.beatu45type, None, Some("beat-type"), __scope, false))


  }


/** The beat-unit group combines elements used repeatedly in the metronome element to specify a note within a metronome mark.
*/
  trait Musicxml_Beatu45unitGroupFormat extends scalaxb.AnyElemNameParser {
    def parseBeatu45unitGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[musicxml.Beatu45unitSequence] =
      (((scalaxb.ElemName(None, "beat-unit")) ~ 
      safeRep(scalaxb.ElemName(None, "beat-unit-dot"))) ^^ 
        { case p1 ~ p2 => musicxml.Beatu45unitSequence(scalaxb.fromXML[musicxml.Noteu45typeu45value](p1, scalaxb.ElemName(node) :: stack),
        p2 map { scalaxb.fromXML[musicxml.Empty](_, scalaxb.ElemName(node) :: stack) }) })
  
    def parseBeatu45unitGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName], wrap: Boolean): Parser[scalaxb.DataRecord[Any]] =
      (((scalaxb.ElemName(None, "beat-unit")) ~ 
      safeRep(scalaxb.ElemName(None, "beat-unit-dot"))) ^^ 
        { case p1 ~ p2 => scalaxb.DataRecord(musicxml.Beatu45unitSequence(scalaxb.fromXML[musicxml.Noteu45typeu45value](p1, scalaxb.ElemName(node) :: stack),
        p2 map { scalaxb.fromXML[musicxml.Empty](_, scalaxb.ElemName(node) :: stack) })) })
    
    def parsemixedBeatu45unitGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Seq[scalaxb.DataRecord[Any]]] =
      ((((scalaxb.ElemName(None, "beat-unit")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord ~ 
      (safeRep(scalaxb.ElemName(None, "beat-unit-dot")) ^^ 
      (_.toSeq map { x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Empty](x, scalaxb.ElemName(node) :: stack)) })) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 ~ p3 ~ p4 => Seq.concat(Seq(p1),
        p2.toList,
        p3,
        p4.toList) })
  }

  trait DefaultMusicxml_Beatu45unitSequenceFormat extends scalaxb.XMLFormat[musicxml.Beatu45unitSequence] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Beatu45unitSequence] = Left("don't call me.")
    
    def writes(__obj: musicxml.Beatu45unitSequence, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(scalaxb.toXML[musicxml.Noteu45typeu45value](__obj.beatu45unit, None, Some("beat-unit"), __scope, false),
        __obj.beatu45unitu45dot flatMap { scalaxb.toXML[musicxml.Empty](_, None, Some("beat-unit-dot"), __scope, false) })


  }


/** The all-margins group specifies both horizontal and vertical margins in tenths.
*/
  trait Musicxml_Allu45marginsGroupFormat extends Musicxml_Leftu45rightu45marginsGroupFormat {
    def parseAllu45marginsGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[musicxml.Allu45marginsSequence] =
      (((parseLeftu45rightu45marginsGroup(node, scalaxb.ElemName(node) :: stack)) ~ 
      (scalaxb.ElemName(None, "top-margin")) ~ 
      (scalaxb.ElemName(None, "bottom-margin"))) ^^ 
        { case p1 ~ p2 ~ p3 => musicxml.Allu45marginsSequence(p1,
        scalaxb.fromXML[BigDecimal](p2, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[BigDecimal](p3, scalaxb.ElemName(node) :: stack)) })
  
    def parseAllu45marginsGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName], wrap: Boolean): Parser[scalaxb.DataRecord[Any]] =
      (((parseLeftu45rightu45marginsGroup(node, scalaxb.ElemName(node) :: stack)) ~ 
      (scalaxb.ElemName(None, "top-margin")) ~ 
      (scalaxb.ElemName(None, "bottom-margin"))) ^^ 
        { case p1 ~ p2 ~ p3 => scalaxb.DataRecord(musicxml.Allu45marginsSequence(p1,
        scalaxb.fromXML[BigDecimal](p2, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[BigDecimal](p3, scalaxb.ElemName(node) :: stack))) })
    
    def parsemixedAllu45marginsGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Seq[scalaxb.DataRecord[Any]]] =
      (((parsemixedLeftu45rightu45marginsGroup(node, scalaxb.ElemName(node) :: stack)) ~ 
      optTextRecord ~ 
      ((scalaxb.ElemName(None, "top-margin")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord ~ 
      ((scalaxb.ElemName(None, "bottom-margin")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 => Seq.concat(p1,
        p2.toList,
        Seq(p3),
        p4.toList,
        Seq(p5),
        p6.toList) })
  }

  trait DefaultMusicxml_Allu45marginsSequenceFormat extends scalaxb.XMLFormat[musicxml.Allu45marginsSequence] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Allu45marginsSequence] = Left("don't call me.")
    
    def writes(__obj: musicxml.Allu45marginsSequence, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(scalaxb.toXML[musicxml.Leftu45rightu45marginsSequence](__obj.leftu45rightu45marginsSequence1, None, Some("leftu45rightu45marginsSequence1"), __scope, false),
        scalaxb.toXML[BigDecimal](__obj.topu45margin, None, Some("top-margin"), __scope, false),
        scalaxb.toXML[BigDecimal](__obj.bottomu45margin, None, Some("bottom-margin"), __scope, false))


  }


/** The left-right-margins group specifies horizontal margins in tenths.
*/
  trait Musicxml_Leftu45rightu45marginsGroupFormat extends scalaxb.AnyElemNameParser {
    def parseLeftu45rightu45marginsGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[musicxml.Leftu45rightu45marginsSequence] =
      (((scalaxb.ElemName(None, "left-margin")) ~ 
      (scalaxb.ElemName(None, "right-margin"))) ^^ 
        { case p1 ~ p2 => musicxml.Leftu45rightu45marginsSequence(scalaxb.fromXML[BigDecimal](p1, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[BigDecimal](p2, scalaxb.ElemName(node) :: stack)) })
  
    def parseLeftu45rightu45marginsGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName], wrap: Boolean): Parser[scalaxb.DataRecord[Any]] =
      (((scalaxb.ElemName(None, "left-margin")) ~ 
      (scalaxb.ElemName(None, "right-margin"))) ^^ 
        { case p1 ~ p2 => scalaxb.DataRecord(musicxml.Leftu45rightu45marginsSequence(scalaxb.fromXML[BigDecimal](p1, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[BigDecimal](p2, scalaxb.ElemName(node) :: stack))) })
    
    def parsemixedLeftu45rightu45marginsGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Seq[scalaxb.DataRecord[Any]]] =
      ((((scalaxb.ElemName(None, "left-margin")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord ~ 
      ((scalaxb.ElemName(None, "right-margin")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[BigDecimal](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 ~ p3 ~ p4 => Seq.concat(Seq(p1),
        p2.toList,
        Seq(p3),
        p4.toList) })
  }

  trait DefaultMusicxml_Leftu45rightu45marginsSequenceFormat extends scalaxb.XMLFormat[musicxml.Leftu45rightu45marginsSequence] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Leftu45rightu45marginsSequence] = Left("don't call me.")
    
    def writes(__obj: musicxml.Leftu45rightu45marginsSequence, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(scalaxb.toXML[BigDecimal](__obj.leftu45margin, None, Some("left-margin"), __scope, false),
        scalaxb.toXML[BigDecimal](__obj.rightu45margin, None, Some("right-margin"), __scope, false))


  }


/** The display-step-octave group contains the sequence of elements used by both the rest and unpitched elements. This group is used to place rests and unpitched elements on the staff without implying that these elements have pitch. Positioning follows the current clef. If percussion clef is used, the display-step and display-octave elements are interpreted as if in treble clef, with a G in octave 4 on line 2. If not present, the note is placed on the middle line of the staff, generally used for a one-line staff.
*/
  trait Musicxml_Displayu45stepu45octaveGroupFormat extends scalaxb.AnyElemNameParser {
    def parseDisplayu45stepu45octaveGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[musicxml.Displayu45stepu45octaveSequence] =
      (((scalaxb.ElemName(None, "display-step")) ~ 
      (scalaxb.ElemName(None, "display-octave"))) ^^ 
        { case p1 ~ p2 => musicxml.Displayu45stepu45octaveSequence(scalaxb.fromXML[musicxml.Step](p1, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[BigInt](p2, scalaxb.ElemName(node) :: stack)) })
  
    def parseDisplayu45stepu45octaveGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName], wrap: Boolean): Parser[scalaxb.DataRecord[Any]] =
      (((scalaxb.ElemName(None, "display-step")) ~ 
      (scalaxb.ElemName(None, "display-octave"))) ^^ 
        { case p1 ~ p2 => scalaxb.DataRecord(musicxml.Displayu45stepu45octaveSequence(scalaxb.fromXML[musicxml.Step](p1, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[BigInt](p2, scalaxb.ElemName(node) :: stack))) })
    
    def parsemixedDisplayu45stepu45octaveGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Seq[scalaxb.DataRecord[Any]]] =
      ((((scalaxb.ElemName(None, "display-step")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord ~ 
      ((scalaxb.ElemName(None, "display-octave")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[BigInt](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 ~ p3 ~ p4 => Seq.concat(Seq(p1),
        p2.toList,
        Seq(p3),
        p4.toList) })
  }

  trait DefaultMusicxml_Displayu45stepu45octaveSequenceFormat extends scalaxb.XMLFormat[musicxml.Displayu45stepu45octaveSequence] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Displayu45stepu45octaveSequence] = Left("don't call me.")
    
    def writes(__obj: musicxml.Displayu45stepu45octaveSequence, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(scalaxb.toXML[musicxml.Step](__obj.displayu45step, None, Some("display-step"), __scope, false),
        scalaxb.toXML[BigInt](__obj.displayu45octave, None, Some("display-octave"), __scope, false))


  }


/** The music-data group contains the basic musical data that is either associated with a part or a measure, depending on whether the partwise or timewise hierarchy is used.
*/
  trait Musicxml_Musicu45dataGroupFormat extends scalaxb.AnyElemNameParser {
    def parseMusicu45dataGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[scalaxb.DataRecord[musicxml.Musicu45dataOption1]] =
      (((scalaxb.ElemName(None, "note")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Note](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "backup")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Backup](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "forward")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Forward](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "direction")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Direction](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "attributes")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.AttributesType](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "harmony")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Harmony](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "figured-bass")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Figuredu45bass](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "print")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Print](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "sound")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Sound](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "barline")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Barline](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "grouping")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Grouping](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "link")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Link](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "bookmark")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Bookmark](x, scalaxb.ElemName(node) :: stack)))))
  
    def parseMusicu45dataGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName], wrap: Boolean): Parser[scalaxb.DataRecord[musicxml.Musicu45dataOption1]] =
      (((scalaxb.ElemName(None, "note")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Note](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "backup")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Backup](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "forward")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Forward](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "direction")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Direction](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "attributes")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.AttributesType](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "harmony")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Harmony](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "figured-bass")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Figuredu45bass](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "print")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Print](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "sound")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Sound](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "barline")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Barline](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "grouping")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Grouping](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "link")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Link](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "bookmark")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Bookmark](x, scalaxb.ElemName(node) :: stack)))))
    
    def parsemixedMusicu45dataGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Seq[scalaxb.DataRecord[Any]]] =
      (((((scalaxb.ElemName(None, "note")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Note](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(None, "backup")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Backup](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(None, "forward")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Forward](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(None, "direction")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Direction](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(None, "attributes")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.AttributesType](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(None, "harmony")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Harmony](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(None, "figured-bass")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Figuredu45bass](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(None, "print")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Print](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(None, "sound")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Sound](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(None, "barline")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Barline](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(None, "grouping")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Grouping](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(None, "link")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Link](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(None, "bookmark")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Bookmark](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }))
  }


/** The score-header group contains basic score metadata about the work and movement, score-wide defaults for layout and fonts, credits that appear on the first or following pages, and the part list.
*/
  trait Musicxml_Scoreu45headerGroupFormat extends scalaxb.AnyElemNameParser {
    def parseScoreu45headerGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[musicxml.Scoreu45headerSequence] =
      ((opt(scalaxb.ElemName(None, "work")) ~ 
      opt(scalaxb.ElemName(None, "movement-number")) ~ 
      opt(scalaxb.ElemName(None, "movement-title")) ~ 
      opt(scalaxb.ElemName(None, "identification")) ~ 
      opt(scalaxb.ElemName(None, "defaults")) ~ 
      safeRep(scalaxb.ElemName(None, "credit")) ~ 
      (scalaxb.ElemName(None, "part-list"))) ^^ 
        { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 => musicxml.Scoreu45headerSequence(p1.headOption map { scalaxb.fromXML[musicxml.Work](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        p3.headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        p4.headOption map { scalaxb.fromXML[musicxml.Identification](_, scalaxb.ElemName(node) :: stack) },
        p5.headOption map { scalaxb.fromXML[musicxml.Defaults](_, scalaxb.ElemName(node) :: stack) },
        p6 map { scalaxb.fromXML[musicxml.Credit](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[musicxml.Partu45list](p7, scalaxb.ElemName(node) :: stack)) })
  
    def parseScoreu45headerGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName], wrap: Boolean): Parser[scalaxb.DataRecord[Any]] =
      ((opt(scalaxb.ElemName(None, "work")) ~ 
      opt(scalaxb.ElemName(None, "movement-number")) ~ 
      opt(scalaxb.ElemName(None, "movement-title")) ~ 
      opt(scalaxb.ElemName(None, "identification")) ~ 
      opt(scalaxb.ElemName(None, "defaults")) ~ 
      safeRep(scalaxb.ElemName(None, "credit")) ~ 
      (scalaxb.ElemName(None, "part-list"))) ^^ 
        { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 => scalaxb.DataRecord(musicxml.Scoreu45headerSequence(p1.headOption map { scalaxb.fromXML[musicxml.Work](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        p3.headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        p4.headOption map { scalaxb.fromXML[musicxml.Identification](_, scalaxb.ElemName(node) :: stack) },
        p5.headOption map { scalaxb.fromXML[musicxml.Defaults](_, scalaxb.ElemName(node) :: stack) },
        p6 map { scalaxb.fromXML[musicxml.Credit](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[musicxml.Partu45list](p7, scalaxb.ElemName(node) :: stack))) })
    
    def parsemixedScoreu45headerGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Seq[scalaxb.DataRecord[Any]]] =
      (((opt(scalaxb.ElemName(None, "work")) ^^ 
      (_ map { x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Work](x, scalaxb.ElemName(node) :: stack)) })) ~ 
      optTextRecord ~ 
      (opt(scalaxb.ElemName(None, "movement-number")) ^^ 
      (_ map { x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) })) ~ 
      optTextRecord ~ 
      (opt(scalaxb.ElemName(None, "movement-title")) ^^ 
      (_ map { x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) })) ~ 
      optTextRecord ~ 
      (opt(scalaxb.ElemName(None, "identification")) ^^ 
      (_ map { x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Identification](x, scalaxb.ElemName(node) :: stack)) })) ~ 
      optTextRecord ~ 
      (opt(scalaxb.ElemName(None, "defaults")) ^^ 
      (_ map { x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Defaults](x, scalaxb.ElemName(node) :: stack)) })) ~ 
      optTextRecord ~ 
      (safeRep(scalaxb.ElemName(None, "credit")) ^^ 
      (_.toSeq map { x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Credit](x, scalaxb.ElemName(node) :: stack)) })) ~ 
      optTextRecord ~ 
      ((scalaxb.ElemName(None, "part-list")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Partu45list](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 ~ p9 ~ p10 ~ p11 ~ p12 ~ p13 ~ p14 => Seq.concat(p1.toList,
        p2.toList,
        p3.toList,
        p4.toList,
        p5.toList,
        p6.toList,
        p7.toList,
        p8.toList,
        p9.toList,
        p10.toList,
        p11,
        p12.toList,
        Seq(p13),
        p14.toList) })
  }

  trait DefaultMusicxml_Scoreu45headerSequenceFormat extends scalaxb.XMLFormat[musicxml.Scoreu45headerSequence] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Scoreu45headerSequence] = Left("don't call me.")
    
    def writes(__obj: musicxml.Scoreu45headerSequence, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(__obj.work map { scalaxb.toXML[musicxml.Work](_, None, Some("work"), __scope, false) } getOrElse {Nil},
        __obj.movementu45number map { scalaxb.toXML[String](_, None, Some("movement-number"), __scope, false) } getOrElse {Nil},
        __obj.movementu45title map { scalaxb.toXML[String](_, None, Some("movement-title"), __scope, false) } getOrElse {Nil},
        __obj.identification map { scalaxb.toXML[musicxml.Identification](_, None, Some("identification"), __scope, false) } getOrElse {Nil},
        __obj.defaults map { scalaxb.toXML[musicxml.Defaults](_, None, Some("defaults"), __scope, false) } getOrElse {Nil},
        __obj.credit flatMap { scalaxb.toXML[musicxml.Credit](_, None, Some("credit"), __scope, false) },
        scalaxb.toXML[musicxml.Partu45list](__obj.partu45list, None, Some("part-list"), __scope, false))


  }

  trait DefaultMusicxml_Partu45nameu45textFormat extends scalaxb.AttributeGroupFormat[musicxml.Partu45nameu45text] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Partu45nameu45text] = seq match {
      case node: scala.xml.Node => Right(musicxml.Partu45nameu45text((node \ "@default-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@default-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@relative-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@relative-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@font-family").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@font-style").headOption map { scalaxb.fromXML[musicxml.Fontu45style](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@font-size").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@font-weight").headOption map { scalaxb.fromXML[musicxml.Fontu45weight](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@color").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@print-object").headOption map { scalaxb.fromXML[musicxml.Yesu45no](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@justify").headOption map { scalaxb.fromXML[musicxml.Leftu45centeru45right](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: musicxml.Partu45nameu45text, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.bigDecimal.toPlainString, attr) }
      __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.bigDecimal.toPlainString, attr) }
      __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.bigDecimal.toPlainString, attr) }
      __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.bigDecimal.toPlainString, attr) }
      __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
      __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
      __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
      __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
      __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
      __obj.printu45object foreach { x => attr = scala.xml.Attribute(null, "print-object", x.toString, attr) }
      __obj.justify foreach { x => attr = scala.xml.Attribute(null, "justify", x.toString, attr) }
      attr
    }
  }

  trait DefaultMusicxml_Measureu45attributesFormat extends scalaxb.AttributeGroupFormat[musicxml.Measureu45attributes] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Measureu45attributes] = seq match {
      case node: scala.xml.Node => Right(musicxml.Measureu45attributes(scalaxb.fromXML[String]((node \ "@number"), scalaxb.ElemName(node) :: stack),
      (node \ "@text").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@implicit").headOption map { scalaxb.fromXML[musicxml.Yesu45no](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@non-controlling").headOption map { scalaxb.fromXML[musicxml.Yesu45no](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@width").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@id").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: musicxml.Measureu45attributes, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      attr = scala.xml.Attribute(null, "number", __obj.number.toString, attr)
      __obj.text foreach { x => attr = scala.xml.Attribute(null, "text", x.toString, attr) }
      __obj.implicitValue foreach { x => attr = scala.xml.Attribute(null, "implicit", x.toString, attr) }
      __obj.nonu45controlling foreach { x => attr = scala.xml.Attribute(null, "non-controlling", x.toString, attr) }
      __obj.width foreach { x => attr = scala.xml.Attribute(null, "width", x.bigDecimal.toPlainString, attr) }
      __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
      attr
    }
  }

  trait DefaultMusicxml_Linku45attributesFormat extends scalaxb.AttributeGroupFormat[musicxml.Linku45attributes] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Linku45attributes] = seq match {
      case node: scala.xml.Node => Right(musicxml.Linku45attributes(scalaxb.fromXML[java.net.URI]((node \ "@{http://www.w3.org/1999/xlink}href"), scalaxb.ElemName(node) :: stack),
      scalaxb.fromXML[musicxml.Type](scala.xml.Text("simple"), scalaxb.ElemName(node) :: stack),
      (node \ "@{http://www.w3.org/1999/xlink}role").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@{http://www.w3.org/1999/xlink}title").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@{http://www.w3.org/1999/xlink}show").headOption map { scalaxb.fromXML[musicxml.Show](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[musicxml.Show](scala.xml.Text("replace"), scalaxb.ElemName(node) :: stack) },
      (node \ "@{http://www.w3.org/1999/xlink}actuate").headOption map { scalaxb.fromXML[musicxml.Actuate](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[musicxml.Actuate](scala.xml.Text("onRequest"), scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: musicxml.Linku45attributes, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/1999/xlink"), "href", __obj.xlinkhref.toString, attr)
      attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/1999/xlink"), "type", __obj.xlinktype.toString, attr)
      __obj.xlinkrole foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/1999/xlink"), "role", x.toString, attr) }
      __obj.xlinktitle foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/1999/xlink"), "title", x.toString, attr) }
      if (__obj.xlinkshow.toString != "replace") attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/1999/xlink"), "show", __obj.xlinkshow.toString, attr)
      if (__obj.xlinkactuate.toString != "onRequest") attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/1999/xlink"), "actuate", __obj.xlinkactuate.toString, attr)
      attr
    }
  }

  trait DefaultMusicxml_Printu45attributesFormat extends scalaxb.AttributeGroupFormat[musicxml.Printu45attributes] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Printu45attributes] = seq match {
      case node: scala.xml.Node => Right(musicxml.Printu45attributes((node \ "@staff-spacing").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@new-system").headOption map { scalaxb.fromXML[musicxml.Yesu45no](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@new-page").headOption map { scalaxb.fromXML[musicxml.Yesu45no](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@blank-page").headOption map { scalaxb.fromXML[BigInt](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@page-number").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: musicxml.Printu45attributes, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      __obj.staffu45spacing foreach { x => attr = scala.xml.Attribute(null, "staff-spacing", x.bigDecimal.toPlainString, attr) }
      __obj.newu45system foreach { x => attr = scala.xml.Attribute(null, "new-system", x.toString, attr) }
      __obj.newu45page foreach { x => attr = scala.xml.Attribute(null, "new-page", x.toString, attr) }
      __obj.blanku45page foreach { x => attr = scala.xml.Attribute(null, "blank-page", x.toString, attr) }
      __obj.pageu45number foreach { x => attr = scala.xml.Attribute(null, "page-number", x.toString, attr) }
      attr
    }
  }

  trait DefaultMusicxml_Yu45positionFormat extends scalaxb.AttributeGroupFormat[musicxml.Yu45position] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Yu45position] = seq match {
      case node: scala.xml.Node => Right(musicxml.Yu45position((node \ "@default-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@default-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@relative-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@relative-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: musicxml.Yu45position, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.bigDecimal.toPlainString, attr) }
      __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.bigDecimal.toPlainString, attr) }
      __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.bigDecimal.toPlainString, attr) }
      __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.bigDecimal.toPlainString, attr) }
      attr
    }
  }

  trait DefaultMusicxml_Valignu45imageTypeFormat extends scalaxb.AttributeGroupFormat[musicxml.Valignu45imageType] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Valignu45imageType] = seq match {
      case node: scala.xml.Node => Right(musicxml.Valignu45imageType((node \ "@valign").headOption map { scalaxb.fromXML[musicxml.Valignu45image](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: musicxml.Valignu45imageType, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      __obj.valign foreach { x => attr = scala.xml.Attribute(null, "valign", x.toString, attr) }
      attr
    }
  }
  trait DefaultMusicxml_Trillu45soundFormat extends scalaxb.AttributeGroupFormat[musicxml.Trillu45sound] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Trillu45sound] = seq match {
      case node: scala.xml.Node => Right(musicxml.Trillu45sound((node \ "@start-note").headOption map { scalaxb.fromXML[musicxml.Startu45note](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@trill-step").headOption map { scalaxb.fromXML[musicxml.Trillu45step](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@two-note-turn").headOption map { scalaxb.fromXML[musicxml.Twou45noteu45turn](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@accelerate").headOption map { scalaxb.fromXML[musicxml.Yesu45no](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@beats").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@second-beat").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@last-beat").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: musicxml.Trillu45sound, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      __obj.startu45note foreach { x => attr = scala.xml.Attribute(null, "start-note", x.toString, attr) }
      __obj.trillu45step foreach { x => attr = scala.xml.Attribute(null, "trill-step", x.toString, attr) }
      __obj.twou45noteu45turn foreach { x => attr = scala.xml.Attribute(null, "two-note-turn", x.toString, attr) }
      __obj.accelerate foreach { x => attr = scala.xml.Attribute(null, "accelerate", x.toString, attr) }
      __obj.beats foreach { x => attr = scala.xml.Attribute(null, "beats", x.bigDecimal.toPlainString, attr) }
      __obj.secondu45beat foreach { x => attr = scala.xml.Attribute(null, "second-beat", x.bigDecimal.toPlainString, attr) }
      __obj.lastu45beat foreach { x => attr = scala.xml.Attribute(null, "last-beat", x.bigDecimal.toPlainString, attr) }
      attr
    }
  }

  trait DefaultMusicxml_Textu45formattingFormat extends scalaxb.AttributeGroupFormat[musicxml.Textu45formatting] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Textu45formatting] = seq match {
      case node: scala.xml.Node => Right(musicxml.Textu45formatting((node \ "@justify").headOption map { scalaxb.fromXML[musicxml.Leftu45centeru45right](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@default-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@default-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@relative-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@relative-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@font-family").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@font-style").headOption map { scalaxb.fromXML[musicxml.Fontu45style](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@font-size").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@font-weight").headOption map { scalaxb.fromXML[musicxml.Fontu45weight](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@color").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@halign").headOption map { scalaxb.fromXML[musicxml.Leftu45centeru45right](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@valign").headOption map { scalaxb.fromXML[musicxml.Valign](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@underline").headOption map { scalaxb.fromXML[BigInt](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@overline").headOption map { scalaxb.fromXML[BigInt](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@line-through").headOption map { scalaxb.fromXML[BigInt](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@rotation").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@letter-spacing").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@line-height").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@{http://www.w3.org/XML/1998/namespace}lang").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@{http://www.w3.org/XML/1998/namespace}space").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@dir").headOption map { scalaxb.fromXML[musicxml.Textu45direction](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@enclosure").headOption map { scalaxb.fromXML[musicxml.Enclosureu45shape](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: musicxml.Textu45formatting, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      __obj.justify foreach { x => attr = scala.xml.Attribute(null, "justify", x.toString, attr) }
      __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.bigDecimal.toPlainString, attr) }
      __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.bigDecimal.toPlainString, attr) }
      __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.bigDecimal.toPlainString, attr) }
      __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.bigDecimal.toPlainString, attr) }
      __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
      __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
      __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
      __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
      __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
      __obj.halign foreach { x => attr = scala.xml.Attribute(null, "halign", x.toString, attr) }
      __obj.valign foreach { x => attr = scala.xml.Attribute(null, "valign", x.toString, attr) }
      __obj.underline foreach { x => attr = scala.xml.Attribute(null, "underline", x.toString, attr) }
      __obj.overline foreach { x => attr = scala.xml.Attribute(null, "overline", x.toString, attr) }
      __obj.lineu45through foreach { x => attr = scala.xml.Attribute(null, "line-through", x.toString, attr) }
      __obj.rotation foreach { x => attr = scala.xml.Attribute(null, "rotation", x.bigDecimal.toPlainString, attr) }
      __obj.letteru45spacing foreach { x => attr = scala.xml.Attribute(null, "letter-spacing", x.toString, attr) }
      __obj.lineu45height foreach { x => attr = scala.xml.Attribute(null, "line-height", x.toString, attr) }
      __obj.xmllang foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", x.toString, attr) }
      __obj.xmlspace foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "space", x.toString, attr) }
      __obj.dir foreach { x => attr = scala.xml.Attribute(null, "dir", x.toString, attr) }
      __obj.enclosure foreach { x => attr = scala.xml.Attribute(null, "enclosure", x.toString, attr) }
      attr
    }
  }

  trait DefaultMusicxml_Textu45decorationFormat extends scalaxb.AttributeGroupFormat[musicxml.Textu45decoration] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Textu45decoration] = seq match {
      case node: scala.xml.Node => Right(musicxml.Textu45decoration((node \ "@underline").headOption map { scalaxb.fromXML[BigInt](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@overline").headOption map { scalaxb.fromXML[BigInt](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@line-through").headOption map { scalaxb.fromXML[BigInt](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: musicxml.Textu45decoration, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      __obj.underline foreach { x => attr = scala.xml.Attribute(null, "underline", x.toString, attr) }
      __obj.overline foreach { x => attr = scala.xml.Attribute(null, "overline", x.toString, attr) }
      __obj.lineu45through foreach { x => attr = scala.xml.Attribute(null, "line-through", x.toString, attr) }
      attr
    }
  }

  trait DefaultMusicxml_SmuflFormat extends scalaxb.AttributeGroupFormat[musicxml.Smufl] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Smufl] = seq match {
      case node: scala.xml.Node => Right(musicxml.Smufl((node \ "@smufl").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: musicxml.Smufl, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      __obj.smufl foreach { x => attr = scala.xml.Attribute(null, "smufl", x.toString, attr) }
      attr
    }
  }
  trait DefaultMusicxml_Printu45styleu45alignFormat extends scalaxb.AttributeGroupFormat[musicxml.Printu45styleu45align] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Printu45styleu45align] = seq match {
      case node: scala.xml.Node => Right(musicxml.Printu45styleu45align((node \ "@default-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@default-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@relative-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@relative-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@font-family").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@font-style").headOption map { scalaxb.fromXML[musicxml.Fontu45style](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@font-size").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@font-weight").headOption map { scalaxb.fromXML[musicxml.Fontu45weight](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@color").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@halign").headOption map { scalaxb.fromXML[musicxml.Leftu45centeru45right](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@valign").headOption map { scalaxb.fromXML[musicxml.Valign](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: musicxml.Printu45styleu45align, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.bigDecimal.toPlainString, attr) }
      __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.bigDecimal.toPlainString, attr) }
      __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.bigDecimal.toPlainString, attr) }
      __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.bigDecimal.toPlainString, attr) }
      __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
      __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
      __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
      __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
      __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
      __obj.halign foreach { x => attr = scala.xml.Attribute(null, "halign", x.toString, attr) }
      __obj.valign foreach { x => attr = scala.xml.Attribute(null, "valign", x.toString, attr) }
      attr
    }
  }

  trait DefaultMusicxml_Printu45spacingFormat extends scalaxb.AttributeGroupFormat[musicxml.Printu45spacing] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Printu45spacing] = seq match {
      case node: scala.xml.Node => Right(musicxml.Printu45spacing((node \ "@print-spacing").headOption map { scalaxb.fromXML[musicxml.Yesu45no](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: musicxml.Printu45spacing, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      __obj.printu45spacing foreach { x => attr = scala.xml.Attribute(null, "print-spacing", x.toString, attr) }
      attr
    }
  }
  trait DefaultMusicxml_PositionFormat extends scalaxb.AttributeGroupFormat[musicxml.Position] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Position] = seq match {
      case node: scala.xml.Node => Right(musicxml.Position((node \ "@default-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@default-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@relative-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@relative-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: musicxml.Position, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.bigDecimal.toPlainString, attr) }
      __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.bigDecimal.toPlainString, attr) }
      __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.bigDecimal.toPlainString, attr) }
      __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.bigDecimal.toPlainString, attr) }
      attr
    }
  }

  trait DefaultMusicxml_OrientationFormat extends scalaxb.AttributeGroupFormat[musicxml.Orientation] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Orientation] = seq match {
      case node: scala.xml.Node => Right(musicxml.Orientation((node \ "@orientation").headOption map { scalaxb.fromXML[musicxml.Overu45under](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: musicxml.Orientation, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      __obj.orientation foreach { x => attr = scala.xml.Attribute(null, "orientation", x.toString, attr) }
      attr
    }
  }
  trait DefaultMusicxml_Lineu45typeTypeFormat extends scalaxb.AttributeGroupFormat[musicxml.Lineu45typeType] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Lineu45typeType] = seq match {
      case node: scala.xml.Node => Right(musicxml.Lineu45typeType((node \ "@line-type").headOption map { scalaxb.fromXML[musicxml.Lineu45type](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: musicxml.Lineu45typeType, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      __obj.lineu45type foreach { x => attr = scala.xml.Attribute(null, "line-type", x.toString, attr) }
      attr
    }
  }
  trait DefaultMusicxml_Lineu45lengthTypeFormat extends scalaxb.AttributeGroupFormat[musicxml.Lineu45lengthType] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Lineu45lengthType] = seq match {
      case node: scala.xml.Node => Right(musicxml.Lineu45lengthType((node \ "@line-length").headOption map { scalaxb.fromXML[musicxml.Lineu45length](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: musicxml.Lineu45lengthType, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      __obj.lineu45length foreach { x => attr = scala.xml.Attribute(null, "line-length", x.toString, attr) }
      attr
    }
  }
  trait DefaultMusicxml_Levelu45displayFormat extends scalaxb.AttributeGroupFormat[musicxml.Levelu45display] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Levelu45display] = seq match {
      case node: scala.xml.Node => Right(musicxml.Levelu45display((node \ "@parentheses").headOption map { scalaxb.fromXML[musicxml.Yesu45no](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@bracket").headOption map { scalaxb.fromXML[musicxml.Yesu45no](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@size").headOption map { scalaxb.fromXML[musicxml.Symbolu45size](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: musicxml.Levelu45display, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      __obj.parentheses foreach { x => attr = scala.xml.Attribute(null, "parentheses", x.toString, attr) }
      __obj.bracket foreach { x => attr = scala.xml.Attribute(null, "bracket", x.toString, attr) }
      __obj.size foreach { x => attr = scala.xml.Attribute(null, "size", x.toString, attr) }
      attr
    }
  }

  trait DefaultMusicxml_JustifyFormat extends scalaxb.AttributeGroupFormat[musicxml.Justify] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Justify] = seq match {
      case node: scala.xml.Node => Right(musicxml.Justify((node \ "@justify").headOption map { scalaxb.fromXML[musicxml.Leftu45centeru45right](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: musicxml.Justify, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      __obj.justify foreach { x => attr = scala.xml.Attribute(null, "justify", x.toString, attr) }
      attr
    }
  }
  trait DefaultMusicxml_FontFormat extends scalaxb.AttributeGroupFormat[musicxml.Font] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Font] = seq match {
      case node: scala.xml.Node => Right(musicxml.Font((node \ "@font-family").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@font-style").headOption map { scalaxb.fromXML[musicxml.Fontu45style](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@font-size").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@font-weight").headOption map { scalaxb.fromXML[musicxml.Fontu45weight](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: musicxml.Font, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
      __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
      __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
      __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
      attr
    }
  }

  trait DefaultMusicxml_Documentu45attributesFormat extends scalaxb.AttributeGroupFormat[musicxml.Documentu45attributes] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Documentu45attributes] = seq match {
      case node: scala.xml.Node => Right(musicxml.Documentu45attributes((node \ "@version").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[String](scala.xml.Text("1.0"), scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: musicxml.Documentu45attributes, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      if (__obj.version.toString != "1.0") attr = scala.xml.Attribute(null, "version", __obj.version.toString, attr)
      attr
    }
  }
  trait DefaultMusicxml_Dashedu45formattingFormat extends scalaxb.AttributeGroupFormat[musicxml.Dashedu45formatting] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Dashedu45formatting] = seq match {
      case node: scala.xml.Node => Right(musicxml.Dashedu45formatting((node \ "@dash-length").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@space-length").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: musicxml.Dashedu45formatting, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      __obj.dashu45length foreach { x => attr = scala.xml.Attribute(null, "dash-length", x.bigDecimal.toPlainString, attr) }
      __obj.spaceu45length foreach { x => attr = scala.xml.Attribute(null, "space-length", x.bigDecimal.toPlainString, attr) }
      attr
    }
  }

  trait DefaultMusicxml_BezierFormat extends scalaxb.AttributeGroupFormat[musicxml.Bezier] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Bezier] = seq match {
      case node: scala.xml.Node => Right(musicxml.Bezier((node \ "@bezier-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@bezier-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@bezier-x2").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@bezier-y2").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@bezier-offset").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@bezier-offset2").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: musicxml.Bezier, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      __obj.bezieru45x foreach { x => attr = scala.xml.Attribute(null, "bezier-x", x.bigDecimal.toPlainString, attr) }
      __obj.bezieru45y foreach { x => attr = scala.xml.Attribute(null, "bezier-y", x.bigDecimal.toPlainString, attr) }
      __obj.bezieru45x2 foreach { x => attr = scala.xml.Attribute(null, "bezier-x2", x.bigDecimal.toPlainString, attr) }
      __obj.bezieru45y2 foreach { x => attr = scala.xml.Attribute(null, "bezier-y2", x.bigDecimal.toPlainString, attr) }
      __obj.bezieru45offset foreach { x => attr = scala.xml.Attribute(null, "bezier-offset", x.bigDecimal.toPlainString, attr) }
      __obj.bezieru45offset2 foreach { x => attr = scala.xml.Attribute(null, "bezier-offset2", x.bigDecimal.toPlainString, attr) }
      attr
    }
  }

  trait DefaultMusicxml_Bendu45soundFormat extends scalaxb.AttributeGroupFormat[musicxml.Bendu45sound] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Bendu45sound] = seq match {
      case node: scala.xml.Node => Right(musicxml.Bendu45sound((node \ "@accelerate").headOption map { scalaxb.fromXML[musicxml.Yesu45no](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@beats").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@first-beat").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@last-beat").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: musicxml.Bendu45sound, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      __obj.accelerate foreach { x => attr = scala.xml.Attribute(null, "accelerate", x.toString, attr) }
      __obj.beats foreach { x => attr = scala.xml.Attribute(null, "beats", x.bigDecimal.toPlainString, attr) }
      __obj.firstu45beat foreach { x => attr = scala.xml.Attribute(null, "first-beat", x.bigDecimal.toPlainString, attr) }
      __obj.lastu45beat foreach { x => attr = scala.xml.Attribute(null, "last-beat", x.bigDecimal.toPlainString, attr) }
      attr
    }
  }

  trait DefaultMusicxml_ColorFormat extends scalaxb.AttributeGroupFormat[musicxml.Color] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Color] = seq match {
      case node: scala.xml.Node => Right(musicxml.Color((node \ "@color").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: musicxml.Color, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
      attr
    }
  }
  trait DefaultMusicxml_DirectiveTypeFormat extends scalaxb.AttributeGroupFormat[musicxml.DirectiveType] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.DirectiveType] = seq match {
      case node: scala.xml.Node => Right(musicxml.DirectiveType((node \ "@directive").headOption map { scalaxb.fromXML[musicxml.Yesu45no](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: musicxml.DirectiveType, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      __obj.directive foreach { x => attr = scala.xml.Attribute(null, "directive", x.toString, attr) }
      attr
    }
  }
  trait DefaultMusicxml_EnclosureFormat extends scalaxb.AttributeGroupFormat[musicxml.Enclosure] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Enclosure] = seq match {
      case node: scala.xml.Node => Right(musicxml.Enclosure((node \ "@enclosure").headOption map { scalaxb.fromXML[musicxml.Enclosureu45shape](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: musicxml.Enclosure, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      __obj.enclosure foreach { x => attr = scala.xml.Attribute(null, "enclosure", x.toString, attr) }
      attr
    }
  }
  trait DefaultMusicxml_HalignFormat extends scalaxb.AttributeGroupFormat[musicxml.Halign] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Halign] = seq match {
      case node: scala.xml.Node => Right(musicxml.Halign((node \ "@halign").headOption map { scalaxb.fromXML[musicxml.Leftu45centeru45right](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: musicxml.Halign, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      __obj.halign foreach { x => attr = scala.xml.Attribute(null, "halign", x.toString, attr) }
      attr
    }
  }
  trait DefaultMusicxml_Letteru45spacingFormat extends scalaxb.AttributeGroupFormat[musicxml.Letteru45spacing] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Letteru45spacing] = seq match {
      case node: scala.xml.Node => Right(musicxml.Letteru45spacing((node \ "@letter-spacing").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: musicxml.Letteru45spacing, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      __obj.letteru45spacing foreach { x => attr = scala.xml.Attribute(null, "letter-spacing", x.toString, attr) }
      attr
    }
  }
  trait DefaultMusicxml_Lineu45heightFormat extends scalaxb.AttributeGroupFormat[musicxml.Lineu45height] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Lineu45height] = seq match {
      case node: scala.xml.Node => Right(musicxml.Lineu45height((node \ "@line-height").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: musicxml.Lineu45height, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      __obj.lineu45height foreach { x => attr = scala.xml.Attribute(null, "line-height", x.toString, attr) }
      attr
    }
  }
  trait DefaultMusicxml_Lineu45shapeTypeFormat extends scalaxb.AttributeGroupFormat[musicxml.Lineu45shapeType] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Lineu45shapeType] = seq match {
      case node: scala.xml.Node => Right(musicxml.Lineu45shapeType((node \ "@line-shape").headOption map { scalaxb.fromXML[musicxml.Lineu45shape](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: musicxml.Lineu45shapeType, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      __obj.lineu45shape foreach { x => attr = scala.xml.Attribute(null, "line-shape", x.toString, attr) }
      attr
    }
  }
  trait DefaultMusicxml_Optionalu45uniqueu45idFormat extends scalaxb.AttributeGroupFormat[musicxml.Optionalu45uniqueu45id] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Optionalu45uniqueu45id] = seq match {
      case node: scala.xml.Node => Right(musicxml.Optionalu45uniqueu45id((node \ "@id").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: musicxml.Optionalu45uniqueu45id, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
      attr
    }
  }
  trait DefaultMusicxml_PlacementFormat extends scalaxb.AttributeGroupFormat[musicxml.Placement] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Placement] = seq match {
      case node: scala.xml.Node => Right(musicxml.Placement((node \ "@placement").headOption map { scalaxb.fromXML[musicxml.Aboveu45below](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: musicxml.Placement, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      __obj.placement foreach { x => attr = scala.xml.Attribute(null, "placement", x.toString, attr) }
      attr
    }
  }
  trait DefaultMusicxml_Printu45objectFormat extends scalaxb.AttributeGroupFormat[musicxml.Printu45object] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Printu45object] = seq match {
      case node: scala.xml.Node => Right(musicxml.Printu45object((node \ "@print-object").headOption map { scalaxb.fromXML[musicxml.Yesu45no](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: musicxml.Printu45object, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      __obj.printu45object foreach { x => attr = scala.xml.Attribute(null, "print-object", x.toString, attr) }
      attr
    }
  }
  trait DefaultMusicxml_Printu45styleFormat extends scalaxb.AttributeGroupFormat[musicxml.Printu45style] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Printu45style] = seq match {
      case node: scala.xml.Node => Right(musicxml.Printu45style((node \ "@default-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@default-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@relative-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@relative-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@font-family").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@font-style").headOption map { scalaxb.fromXML[musicxml.Fontu45style](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@font-size").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@font-weight").headOption map { scalaxb.fromXML[musicxml.Fontu45weight](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@color").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: musicxml.Printu45style, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.bigDecimal.toPlainString, attr) }
      __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.bigDecimal.toPlainString, attr) }
      __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.bigDecimal.toPlainString, attr) }
      __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.bigDecimal.toPlainString, attr) }
      __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
      __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
      __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
      __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
      __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
      attr
    }
  }

  trait DefaultMusicxml_PrintoutFormat extends scalaxb.AttributeGroupFormat[musicxml.Printout] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Printout] = seq match {
      case node: scala.xml.Node => Right(musicxml.Printout((node \ "@print-object").headOption map { scalaxb.fromXML[musicxml.Yesu45no](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@print-dot").headOption map { scalaxb.fromXML[musicxml.Yesu45no](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@print-spacing").headOption map { scalaxb.fromXML[musicxml.Yesu45no](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@print-lyric").headOption map { scalaxb.fromXML[musicxml.Yesu45no](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: musicxml.Printout, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      __obj.printu45object foreach { x => attr = scala.xml.Attribute(null, "print-object", x.toString, attr) }
      __obj.printu45dot foreach { x => attr = scala.xml.Attribute(null, "print-dot", x.toString, attr) }
      __obj.printu45spacing foreach { x => attr = scala.xml.Attribute(null, "print-spacing", x.toString, attr) }
      __obj.printu45lyric foreach { x => attr = scala.xml.Attribute(null, "print-lyric", x.toString, attr) }
      attr
    }
  }

  trait DefaultMusicxml_Symbolu45formattingFormat extends scalaxb.AttributeGroupFormat[musicxml.Symbolu45formatting] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Symbolu45formatting] = seq match {
      case node: scala.xml.Node => Right(musicxml.Symbolu45formatting((node \ "@justify").headOption map { scalaxb.fromXML[musicxml.Leftu45centeru45right](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@default-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@default-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@relative-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@relative-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@font-family").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@font-style").headOption map { scalaxb.fromXML[musicxml.Fontu45style](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@font-size").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@font-weight").headOption map { scalaxb.fromXML[musicxml.Fontu45weight](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@color").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@halign").headOption map { scalaxb.fromXML[musicxml.Leftu45centeru45right](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@valign").headOption map { scalaxb.fromXML[musicxml.Valign](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@underline").headOption map { scalaxb.fromXML[BigInt](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@overline").headOption map { scalaxb.fromXML[BigInt](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@line-through").headOption map { scalaxb.fromXML[BigInt](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@rotation").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@letter-spacing").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@line-height").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@dir").headOption map { scalaxb.fromXML[musicxml.Textu45direction](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@enclosure").headOption map { scalaxb.fromXML[musicxml.Enclosureu45shape](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: musicxml.Symbolu45formatting, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      __obj.justify foreach { x => attr = scala.xml.Attribute(null, "justify", x.toString, attr) }
      __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.bigDecimal.toPlainString, attr) }
      __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.bigDecimal.toPlainString, attr) }
      __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.bigDecimal.toPlainString, attr) }
      __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.bigDecimal.toPlainString, attr) }
      __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
      __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
      __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
      __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
      __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
      __obj.halign foreach { x => attr = scala.xml.Attribute(null, "halign", x.toString, attr) }
      __obj.valign foreach { x => attr = scala.xml.Attribute(null, "valign", x.toString, attr) }
      __obj.underline foreach { x => attr = scala.xml.Attribute(null, "underline", x.toString, attr) }
      __obj.overline foreach { x => attr = scala.xml.Attribute(null, "overline", x.toString, attr) }
      __obj.lineu45through foreach { x => attr = scala.xml.Attribute(null, "line-through", x.toString, attr) }
      __obj.rotation foreach { x => attr = scala.xml.Attribute(null, "rotation", x.bigDecimal.toPlainString, attr) }
      __obj.letteru45spacing foreach { x => attr = scala.xml.Attribute(null, "letter-spacing", x.toString, attr) }
      __obj.lineu45height foreach { x => attr = scala.xml.Attribute(null, "line-height", x.toString, attr) }
      __obj.dir foreach { x => attr = scala.xml.Attribute(null, "dir", x.toString, attr) }
      __obj.enclosure foreach { x => attr = scala.xml.Attribute(null, "enclosure", x.toString, attr) }
      attr
    }
  }

  trait DefaultMusicxml_Textu45directionTypeFormat extends scalaxb.AttributeGroupFormat[musicxml.Textu45directionType] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Textu45directionType] = seq match {
      case node: scala.xml.Node => Right(musicxml.Textu45directionType((node \ "@dir").headOption map { scalaxb.fromXML[musicxml.Textu45direction](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: musicxml.Textu45directionType, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      __obj.dir foreach { x => attr = scala.xml.Attribute(null, "dir", x.toString, attr) }
      attr
    }
  }
  trait DefaultMusicxml_Textu45rotationFormat extends scalaxb.AttributeGroupFormat[musicxml.Textu45rotation] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Textu45rotation] = seq match {
      case node: scala.xml.Node => Right(musicxml.Textu45rotation((node \ "@rotation").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: musicxml.Textu45rotation, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      __obj.rotation foreach { x => attr = scala.xml.Attribute(null, "rotation", x.bigDecimal.toPlainString, attr) }
      attr
    }
  }
  trait DefaultMusicxml_ValignTypeFormat extends scalaxb.AttributeGroupFormat[musicxml.ValignType] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.ValignType] = seq match {
      case node: scala.xml.Node => Right(musicxml.ValignType((node \ "@valign").headOption map { scalaxb.fromXML[musicxml.Valign](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: musicxml.ValignType, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      __obj.valign foreach { x => attr = scala.xml.Attribute(null, "valign", x.toString, attr) }
      attr
    }
  }
  trait DefaultMusicxml_Xu45positionFormat extends scalaxb.AttributeGroupFormat[musicxml.Xu45position] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Xu45position] = seq match {
      case node: scala.xml.Node => Right(musicxml.Xu45position((node \ "@default-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@default-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@relative-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@relative-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: musicxml.Xu45position, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.bigDecimal.toPlainString, attr) }
      __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.bigDecimal.toPlainString, attr) }
      __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.bigDecimal.toPlainString, attr) }
      __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.bigDecimal.toPlainString, attr) }
      attr
    }
  }

  trait DefaultMusicxml_Imageu45attributesFormat extends scalaxb.AttributeGroupFormat[musicxml.Imageu45attributes] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Imageu45attributes] = seq match {
      case node: scala.xml.Node => Right(musicxml.Imageu45attributes(scalaxb.fromXML[java.net.URI]((node \ "@source"), scalaxb.ElemName(node) :: stack),
      scalaxb.fromXML[String]((node \ "@type"), scalaxb.ElemName(node) :: stack),
      (node \ "@height").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@width").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@default-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@default-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@relative-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@relative-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@halign").headOption map { scalaxb.fromXML[musicxml.Leftu45centeru45right](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@valign").headOption map { scalaxb.fromXML[musicxml.Valignu45image](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: musicxml.Imageu45attributes, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      attr = scala.xml.Attribute(null, "source", __obj.source.toString, attr)
      attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
      __obj.height foreach { x => attr = scala.xml.Attribute(null, "height", x.bigDecimal.toPlainString, attr) }
      __obj.width foreach { x => attr = scala.xml.Attribute(null, "width", x.bigDecimal.toPlainString, attr) }
      __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.bigDecimal.toPlainString, attr) }
      __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.bigDecimal.toPlainString, attr) }
      __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.bigDecimal.toPlainString, attr) }
      __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.bigDecimal.toPlainString, attr) }
      __obj.halign foreach { x => attr = scala.xml.Attribute(null, "halign", x.toString, attr) }
      __obj.valign foreach { x => attr = scala.xml.Attribute(null, "valign", x.toString, attr) }
      attr
    }
  }

  trait DefaultMusicxml_Elementu45positionFormat extends scalaxb.AttributeGroupFormat[musicxml.Elementu45position] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Elementu45position] = seq match {
      case node: scala.xml.Node => Right(musicxml.Elementu45position((node \ "@element").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@position").headOption map { scalaxb.fromXML[BigInt](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: musicxml.Elementu45position, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      __obj.element foreach { x => attr = scala.xml.Attribute(null, "element", x.toString, attr) }
      __obj.position foreach { x => attr = scala.xml.Attribute(null, "position", x.toString, attr) }
      attr
    }
  }

  trait DefaultMusicxml_Groupu45nameu45textFormat extends scalaxb.AttributeGroupFormat[musicxml.Groupu45nameu45text] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Groupu45nameu45text] = seq match {
      case node: scala.xml.Node => Right(musicxml.Groupu45nameu45text((node \ "@default-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@default-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@relative-x").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@relative-y").headOption map { scalaxb.fromXML[BigDecimal](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@font-family").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@font-style").headOption map { scalaxb.fromXML[musicxml.Fontu45style](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@font-size").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@font-weight").headOption map { scalaxb.fromXML[musicxml.Fontu45weight](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@color").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@justify").headOption map { scalaxb.fromXML[musicxml.Leftu45centeru45right](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: musicxml.Groupu45nameu45text, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      __obj.defaultu45x foreach { x => attr = scala.xml.Attribute(null, "default-x", x.bigDecimal.toPlainString, attr) }
      __obj.defaultu45y foreach { x => attr = scala.xml.Attribute(null, "default-y", x.bigDecimal.toPlainString, attr) }
      __obj.relativeu45x foreach { x => attr = scala.xml.Attribute(null, "relative-x", x.bigDecimal.toPlainString, attr) }
      __obj.relativeu45y foreach { x => attr = scala.xml.Attribute(null, "relative-y", x.bigDecimal.toPlainString, attr) }
      __obj.fontu45family foreach { x => attr = scala.xml.Attribute(null, "font-family", x.toString, attr) }
      __obj.fontu45style foreach { x => attr = scala.xml.Attribute(null, "font-style", x.toString, attr) }
      __obj.fontu45size foreach { x => attr = scala.xml.Attribute(null, "font-size", x.toString, attr) }
      __obj.fontu45weight foreach { x => attr = scala.xml.Attribute(null, "font-weight", x.toString, attr) }
      __obj.color foreach { x => attr = scala.xml.Attribute(null, "color", x.toString, attr) }
      __obj.justify foreach { x => attr = scala.xml.Attribute(null, "justify", x.toString, attr) }
      attr
    }
  }

  trait DefaultMusicxml_Partu45attributesFormat extends scalaxb.AttributeGroupFormat[musicxml.Partu45attributes] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Partu45attributes] = seq match {
      case node: scala.xml.Node => Right(musicxml.Partu45attributes(scalaxb.fromXML[String]((node \ "@id"), scalaxb.ElemName(node) :: stack)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: musicxml.Partu45attributes, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      attr = scala.xml.Attribute(null, "id", __obj.id.toString, attr)
      attr
    }
  }
  def buildMusicxml_Yesu45noFormat = new DefaultMusicxml_Yesu45noFormat {}
  trait DefaultMusicxml_Yesu45noFormat extends scalaxb.XMLFormat[musicxml.Yesu45no] {
    val targetNamespace: Option[String] = None
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): musicxml.Yesu45no =
        (fromString0(value, scope)).apply(scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, musicxml.Yesu45no] = {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("yes")) => musicxml.Yes
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("no")) => musicxml.No

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Yesu45no] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: musicxml.Yesu45no, __namespace: Option[String], __elementLabel: Option[String],
      __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq = scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull,
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  trait DefaultMusicxml_OpusFormat extends scalaxb.ElemNameParser[musicxml.Opus] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("opus")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[musicxml.Opus] =
      phrase(opt(scalaxb.ElemName(None, "title")) ~ 
      safeRep(((scalaxb.ElemName(None, "opus")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Opus](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "opus-link")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Opusu45link](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(None, "score")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[musicxml.Score](x, scalaxb.ElemName(node) :: stack))))) ^^
      { case p1 ~ p2 =>
      musicxml.Opus(p1.headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        p2,
        scala.collection.immutable.ListMap(List(
        (node \ "@version").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } orElse Some(scalaxb.DataRecord(None, None, scalaxb.fromXML[String](scala.xml.Text("1.0"), scalaxb.ElemName(node) :: stack))) map { "@version" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: musicxml.Opus, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@version", _) => if (__obj.version.toString != "1.0") attr = scala.xml.Attribute(null, "version", __obj.version.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Opus, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.title map { scalaxb.toXML[String](_, None, Some("title"), __scope, false) } getOrElse {Nil},
        __obj.opusoption flatMap { x => scalaxb.toXML[scalaxb.DataRecord[musicxml.OpusOption]](x, x.namespace, x.key, __scope, false) })

  }

  trait DefaultMusicxml_Opusu45linkFormat extends scalaxb.XMLFormat[musicxml.Opusu45link] with scalaxb.CanWriteChildNodes[musicxml.Opusu45link] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Opusu45link] = seq match {
      case node: scala.xml.Node => Right(musicxml.Opusu45link(scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/1999/xlink}href").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[java.net.URI](x, scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/1999/xlink}href" -> _ },
        Some(scalaxb.DataRecord(None, None, scalaxb.fromXML[musicxml.Type](scala.xml.Text("simple"), scalaxb.ElemName(node) :: stack))) map { "@{http://www.w3.org/1999/xlink}type" -> _ },
        (node \ "@{http://www.w3.org/1999/xlink}role").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/1999/xlink}role" -> _ },
        (node \ "@{http://www.w3.org/1999/xlink}title").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/1999/xlink}title" -> _ },
        (node \ "@{http://www.w3.org/1999/xlink}show").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Show](x, scalaxb.ElemName(node) :: stack)) } orElse Some(scalaxb.DataRecord(None, None, scalaxb.fromXML[musicxml.Show](scala.xml.Text("replace"), scalaxb.ElemName(node) :: stack))) map { "@{http://www.w3.org/1999/xlink}show" -> _ },
        (node \ "@{http://www.w3.org/1999/xlink}actuate").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Actuate](x, scalaxb.ElemName(node) :: stack)) } orElse Some(scalaxb.DataRecord(None, None, scalaxb.fromXML[musicxml.Actuate](scala.xml.Text("onRequest"), scalaxb.ElemName(node) :: stack))) map { "@{http://www.w3.org/1999/xlink}actuate" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Opusu45link, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/1999/xlink}href", _) => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/1999/xlink"), "href", __obj.xlinkhref.toString, attr)
        case ("@{http://www.w3.org/1999/xlink}type", _) => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/1999/xlink"), "type", __obj.xlinktype.toString, attr)
        case ("@{http://www.w3.org/1999/xlink}role", _) => __obj.xlinkrole foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/1999/xlink"), "role", x.toString, attr) }
        case ("@{http://www.w3.org/1999/xlink}title", _) => __obj.xlinktitle foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/1999/xlink"), "title", x.toString, attr) }
        case ("@{http://www.w3.org/1999/xlink}show", _) => if (__obj.xlinkshow.toString != "replace") attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/1999/xlink"), "show", __obj.xlinkshow.toString, attr)
        case ("@{http://www.w3.org/1999/xlink}actuate", _) => if (__obj.xlinkactuate.toString != "onRequest") attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/1999/xlink"), "actuate", __obj.xlinkactuate.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Opusu45link, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil

  }

  trait DefaultMusicxml_ScoreFormat extends scalaxb.XMLFormat[musicxml.Score] with scalaxb.CanWriteChildNodes[musicxml.Score] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Score] = seq match {
      case node: scala.xml.Node => Right(musicxml.Score(scala.collection.immutable.ListMap(List(
        (node \ "@{http://www.w3.org/1999/xlink}href").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[java.net.URI](x, scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/1999/xlink}href" -> _ },
        Some(scalaxb.DataRecord(None, None, scalaxb.fromXML[musicxml.Type](scala.xml.Text("simple"), scalaxb.ElemName(node) :: stack))) map { "@{http://www.w3.org/1999/xlink}type" -> _ },
        (node \ "@{http://www.w3.org/1999/xlink}role").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/1999/xlink}role" -> _ },
        (node \ "@{http://www.w3.org/1999/xlink}title").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/1999/xlink}title" -> _ },
        (node \ "@{http://www.w3.org/1999/xlink}show").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Show](x, scalaxb.ElemName(node) :: stack)) } orElse Some(scalaxb.DataRecord(None, None, scalaxb.fromXML[musicxml.Show](scala.xml.Text("replace"), scalaxb.ElemName(node) :: stack))) map { "@{http://www.w3.org/1999/xlink}show" -> _ },
        (node \ "@{http://www.w3.org/1999/xlink}actuate").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Actuate](x, scalaxb.ElemName(node) :: stack)) } orElse Some(scalaxb.DataRecord(None, None, scalaxb.fromXML[musicxml.Actuate](scala.xml.Text("onRequest"), scalaxb.ElemName(node) :: stack))) map { "@{http://www.w3.org/1999/xlink}actuate" -> _ },
        (node \ "@new-page").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[musicxml.Yesu45no](x, scalaxb.ElemName(node) :: stack)) } map { "@new-page" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: musicxml.Score, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@{http://www.w3.org/1999/xlink}href", _) => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/1999/xlink"), "href", __obj.xlinkhref.toString, attr)
        case ("@{http://www.w3.org/1999/xlink}type", _) => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/1999/xlink"), "type", __obj.xlinktype.toString, attr)
        case ("@{http://www.w3.org/1999/xlink}role", _) => __obj.xlinkrole foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/1999/xlink"), "role", x.toString, attr) }
        case ("@{http://www.w3.org/1999/xlink}title", _) => __obj.xlinktitle foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/1999/xlink"), "title", x.toString, attr) }
        case ("@{http://www.w3.org/1999/xlink}show", _) => if (__obj.xlinkshow.toString != "replace") attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/1999/xlink"), "show", __obj.xlinkshow.toString, attr)
        case ("@{http://www.w3.org/1999/xlink}actuate", _) => if (__obj.xlinkactuate.toString != "onRequest") attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/1999/xlink"), "actuate", __obj.xlinkactuate.toString, attr)
        case ("@new-page", _) => __obj.newu45page foreach { x => attr = scala.xml.Attribute(null, "new-page", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: musicxml.Score, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil

  }


  def buildMusicxml_TypeFormat = new DefaultMusicxml_TypeFormat {}
  trait DefaultMusicxml_TypeFormat extends scalaxb.XMLFormat[musicxml.Type] {
    val targetNamespace: Option[String] = Some("http://www.w3.org/1999/xlink")

    def fromString(value: String, scope: scala.xml.NamespaceBinding): musicxml.Type =
        (fromString0(value, scope)).apply(scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, musicxml.Type] = {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("simple")) => musicxml.Simple

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Type] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: musicxml.Type, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def buildMusicxml_ShowFormat = new DefaultMusicxml_ShowFormat {}
  trait DefaultMusicxml_ShowFormat extends scalaxb.XMLFormat[musicxml.Show] {
    val targetNamespace: Option[String] = Some("http://www.w3.org/1999/xlink")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): musicxml.Show =
        (fromString0(value, scope)).apply(scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, musicxml.Show] = {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("new")) => musicxml.New
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("replace")) => musicxml.Replace
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("embed")) => musicxml.Embed
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("other")) => musicxml.OtherValue5
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("none")) => musicxml.NoneTypeValue15

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Show] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: musicxml.Show, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def buildMusicxml_ActuateFormat = new DefaultMusicxml_ActuateFormat {}
  trait DefaultMusicxml_ActuateFormat extends scalaxb.XMLFormat[musicxml.Actuate] {
    val targetNamespace: Option[String] = Some("http://www.w3.org/1999/xlink")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): musicxml.Actuate =
        (fromString0(value, scope)).apply(scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, musicxml.Actuate] = {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("onRequest")) => musicxml.OnRequest
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("onLoad")) => musicxml.OnLoad
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("other")) => musicxml.OtherValue6
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("none")) => musicxml.NoneTypeValue16

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.Actuate] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: musicxml.Actuate, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  def buildMusicxml_SpaceTypeFormat = new DefaultMusicxml_SpaceTypeFormat {}
  trait DefaultMusicxml_SpaceTypeFormat extends scalaxb.XMLFormat[musicxml.SpaceType] {
    val targetNamespace: Option[String] = Some("http://www.w3.org/XML/1998/namespace")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): musicxml.SpaceType =
        (fromString0(value, scope)).apply(scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, musicxml.SpaceType] = {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("default")) => musicxml.Default
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("preserve")) => musicxml.Preserve

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.SpaceType] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: musicxml.SpaceType, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }
  trait DefaultMusicxml_SpecialAttrsFormat extends scalaxb.AttributeGroupFormat[musicxml.SpecialAttrs] {
    val targetNamespace: Option[String] = Some("http://www.w3.org/XML/1998/namespace")
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, musicxml.SpecialAttrs] = seq match {
      case node: scala.xml.Node => Right(musicxml.SpecialAttrs((node \ "@{http://www.w3.org/XML/1998/namespace}base").headOption map { scalaxb.fromXML[java.net.URI](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@{http://www.w3.org/XML/1998/namespace}lang").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@{http://www.w3.org/XML/1998/namespace}space").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@{http://www.w3.org/XML/1998/namespace}id").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: musicxml.SpecialAttrs, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      __obj.xmlbase foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "base", x.toString, attr) }
      __obj.xmllang foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", x.toString, attr) }
      __obj.xmlspace foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "space", x.toString, attr) }
      __obj.xmlid foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "id", x.toString, attr) }
      attr
    }
  }


}

